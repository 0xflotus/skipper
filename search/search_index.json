{
    "docs": [
        {
            "location": "/", 
            "text": "Architecture\n\n\nSkipper is written as library and has also 2 binaries, named \nskipper\n\nand \neskip\n.", 
            "title": "Architecture"
        }, 
        {
            "location": "/#architecture", 
            "text": "Skipper is written as library and has also 2 binaries, named  skipper \nand  eskip .", 
            "title": "Architecture"
        }, 
        {
            "location": "/deployments/", 
            "text": "Deployments and Data-Clients\n\n\nEdge HTTP Routing\n\n\nEdge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.\n\n\nOn the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.\n\n\nIn this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.\n\n\nTo support this scenario we have the \netcd dataclient\n.\n\n\nEtcd\n is a distributed database.\n\n\nTODO: why we use ETCD for this purpose\n\n\nKubernetes Ingress\n\n\nKubernetes Ingress\n is the\ncomponent responsible to route traffic into your\n\nKubernetes\n cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the\n\nkubernetes dataclient\n and is used in\nproduction since end of 2016.\n\n\nSkipper as ingress controller does not need to have any file\nconfiguration or anything external which configures skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.\n\n\nRead more about \nSkipper's kubernetes dataclient\n.\n\n\nInkeeper Routes API\n\n\nSkipper\n can read from an\n\nInkeeper API\n, if you like to\ncreate routes via an API.\nOur \nInkeeper API dataclient\n can be used\nas well. It was used in production in the past. (TODO: do we use it somwhere?)\n\n\nDemos / Talks\n\n\nIn demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe \nroute-string dataclient\n.\n\n\nSimple Routes File\n\n\nThe most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the \nEskip file dataclient\n is about.", 
            "title": "Deployments"
        }, 
        {
            "location": "/deployments/#deployments-and-data-clients", 
            "text": "", 
            "title": "Deployments and Data-Clients"
        }, 
        {
            "location": "/deployments/#edge-http-routing", 
            "text": "Edge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.  On the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.  In this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.  To support this scenario we have the  etcd dataclient .  Etcd  is a distributed database.  TODO: why we use ETCD for this purpose", 
            "title": "Edge HTTP Routing"
        }, 
        {
            "location": "/deployments/#kubernetes-ingress", 
            "text": "Kubernetes Ingress  is the\ncomponent responsible to route traffic into your Kubernetes  cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the kubernetes dataclient  and is used in\nproduction since end of 2016.  Skipper as ingress controller does not need to have any file\nconfiguration or anything external which configures skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.  Read more about  Skipper's kubernetes dataclient .", 
            "title": "Kubernetes Ingress"
        }, 
        {
            "location": "/deployments/#inkeeper-routes-api", 
            "text": "Skipper  can read from an Inkeeper API , if you like to\ncreate routes via an API.\nOur  Inkeeper API dataclient  can be used\nas well. It was used in production in the past. (TODO: do we use it somwhere?)", 
            "title": "Inkeeper Routes API"
        }, 
        {
            "location": "/deployments/#demos-talks", 
            "text": "In demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe  route-string dataclient .", 
            "title": "Demos / Talks"
        }, 
        {
            "location": "/deployments/#simple-routes-file", 
            "text": "The most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the  Eskip file dataclient  is about.", 
            "title": "Simple Routes File"
        }, 
        {
            "location": "/dataclients/eskip-file/", 
            "text": "Eskip File\n\n\nEskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The \nfile format eskip\n\nshows your route definitions in a clear way:\n\n\n% cat example.eskip\nhello: Path(\"/hello\") -\n \"https://www.example.org\"'\n\n\n\nThe \nskipper project\n has two\nbinaries, one is \nskipper\n, the other is \neskip\n.\n\nEskip\n\ncan be used to validate the syntax of your routes file before\nreloading a production server:\n\n\n% eskip check example.eskip\n\n\n\nA more complicated example with different routes, matches,\n\npredicates\n and\n\nfilters\n shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:\n\n\n% cat complicated_example.eskip\nhost-header-match:\n         Host(\"^skipper.teapot.org$\")\n         -\n setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -\n \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaidu-path-match:\n        Path(\"/baidu\")\n        -\n setRequestHeader(\"Host\", \"www.baidu.com\")\n        -\n setPath(\"/s\")\n        -\n setQuery(\"wd\", \"godoc skipper\")\n        -\n \"http://www.baidu.com\";\ngoogle-wildcard-match:\n        *\n        -\n setPath(\"/search\")\n        -\n setQuery(\"q\", \"godoc skipper\")\n        -\n \"https://www.google.com\";\nyandex-wildacard-if-cookie:\n        * \n Cookie(\"yandex\", \"true\")\n        -\n setPath(\"/search/\")\n        -\n setQuery(\"text\", \"godoc skipper\")\n        -\n tee(\"http://127.0.0.1:12345/\")\n        -\n \"https://yandex.ru\";\n\n\n\nThe former example shows 4 routes: host-header-match,\nbaidu-path-match, google-wildcard-match and yandex-wildcard-if-cookie.\n\n\n\n\nhost-header-match:\n\n\nused if HTTP host header is exactly: \"skipper.teapot.org\",\n\n\nsets a Basic Authorization header and\n\n\nsends the modified request to https://target-to.auth-with.basic-auth.enterprise.com\n\n\nbaidu-path-match:\n\n\nused in case the request patch matches /baidu\n\n\nit will set the Host header to the proxy request\n\n\nit will set the path from /baidu to /s\n\n\nit will set the querystring to \"ws=godoc skipper\" and\n\n\nsends the modified request to http://baidu.com\n\n\ngoogle-wildcard-match:\n\n\nused as default if no other route matches\n\n\nit will set the path to /search\n\n\nit will set the querystring to \"q=godoc skipper\" and\n\n\nsends the modified request to https://www.google.com\n\n\nyandex-wildcard-if-cookie:\n\n\nused as default if a Cookie named \"yandex\" has the value \"true\"\n\n\nit will set the path to /search/\n\n\nit will set the querystring to \"text=godoc skipper\"\n\n\nit will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix \ntee\n) and drop the response and\n\n\nsends the modified request to https://yandex.ru\n\n\n\n\nMore examples you find in \neskip file format\n\ndescription, in \nfilters\n\nand in \npredicates\n.\n\n\nEskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):\n\n\n% curl localhost:9911/routes\n*\n  -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -\n inlineContent(\"{\\\"foo\\\": 3}\")\n  -\n \nshunt", 
            "title": "Eskip"
        }, 
        {
            "location": "/dataclients/eskip-file/#eskip-file", 
            "text": "Eskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The  file format eskip \nshows your route definitions in a clear way:  % cat example.eskip\nhello: Path(\"/hello\") -  \"https://www.example.org\"'  The  skipper project  has two\nbinaries, one is  skipper , the other is  eskip . Eskip \ncan be used to validate the syntax of your routes file before\nreloading a production server:  % eskip check example.eskip  A more complicated example with different routes, matches, predicates  and filters  shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:  % cat complicated_example.eskip\nhost-header-match:\n         Host(\"^skipper.teapot.org$\")\n         -  setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -  \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaidu-path-match:\n        Path(\"/baidu\")\n        -  setRequestHeader(\"Host\", \"www.baidu.com\")\n        -  setPath(\"/s\")\n        -  setQuery(\"wd\", \"godoc skipper\")\n        -  \"http://www.baidu.com\";\ngoogle-wildcard-match:\n        *\n        -  setPath(\"/search\")\n        -  setQuery(\"q\", \"godoc skipper\")\n        -  \"https://www.google.com\";\nyandex-wildacard-if-cookie:\n        *   Cookie(\"yandex\", \"true\")\n        -  setPath(\"/search/\")\n        -  setQuery(\"text\", \"godoc skipper\")\n        -  tee(\"http://127.0.0.1:12345/\")\n        -  \"https://yandex.ru\";  The former example shows 4 routes: host-header-match,\nbaidu-path-match, google-wildcard-match and yandex-wildcard-if-cookie.   host-header-match:  used if HTTP host header is exactly: \"skipper.teapot.org\",  sets a Basic Authorization header and  sends the modified request to https://target-to.auth-with.basic-auth.enterprise.com  baidu-path-match:  used in case the request patch matches /baidu  it will set the Host header to the proxy request  it will set the path from /baidu to /s  it will set the querystring to \"ws=godoc skipper\" and  sends the modified request to http://baidu.com  google-wildcard-match:  used as default if no other route matches  it will set the path to /search  it will set the querystring to \"q=godoc skipper\" and  sends the modified request to https://www.google.com  yandex-wildcard-if-cookie:  used as default if a Cookie named \"yandex\" has the value \"true\"  it will set the path to /search/  it will set the querystring to \"text=godoc skipper\"  it will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix  tee ) and drop the response and  sends the modified request to https://yandex.ru   More examples you find in  eskip file format \ndescription, in  filters \nand in  predicates .  Eskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):  % curl localhost:9911/routes\n*\n  -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -  inlineContent(\"{\\\"foo\\\": 3}\")\n  -   shunt", 
            "title": "Eskip File"
        }, 
        {
            "location": "/dataclients/etcd/", 
            "text": "ETCD\n\n\nTODO", 
            "title": "Etcd"
        }, 
        {
            "location": "/dataclients/etcd/#etcd", 
            "text": "TODO", 
            "title": "ETCD"
        }, 
        {
            "location": "/dataclients/inkeeper-api/", 
            "text": "Inkeeper API\n\n\nTODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/inkeeper-api/#inkeeper-api", 
            "text": "TODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/kubernetes/", 
            "text": "Kubernetes\n\n\nSkipper's Kubernetes dataclient can be used, if you want to run skipper as\n\nkubernetes-ingress-controller\n.\nIt will get it's route information from provisioned\n\nIngress Objects\n.\nDetailed information you find in our \ngodoc for dataclient kubernetes\n.\n\n\nSkipper Features\n\n\nSkipper has the following main features:\n\n\n\n\nFilters - create, update, delete all kind of HTTP data\n\n\ncollection of base http manipulations\n: for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling\n\n\ncookie handling\n\n\ncircuitbreakers\n: consecutiveBreaker or rateBreaker\n\n\nratelimit\n: based on client or backend data\n\n\nShadow traffic: \ntee()\n\n\nPredicates - advanced matching capability\n\n\nURL Path match: \nPath(\"/foo\")\n\n\nHost header match: \nHost(\"^www.example.org$\")\n\n\nQuerystring\n: \nQueryParam(\"featureX\")\n\n\nCookie based\n: \nCookie(\"alpha\", /^enabled$/)\n\n\nsource whitelist\n: \nSource(\"1.2.3.4/24\")\n\n\ntime based interval\n\n\ntraffic by percentage\n supports also sticky sessions\n\n\nKubernetes integration\n\n\nAll Filters and Predicates can be used with 2 annotations\n\n\nPredicates: \nzalando.org/skipper-predicate\n\n\nFilters: \nzalando.org/skipper-filter\n\n\n\n\n\n\nmetrics\n\n\naccess logs\n\n\nBlue-Green deployments, with another Ingress annotation \nzalando.org/backend-weights\n, see Advanced Examples section\n\n\n\n\n3 Minutes Skipper in Kubernetes introduction\n\n\nYou should have a base understanding of \nKubernetes\n and\n\nIngress\n.\n\n\nPrerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.\n\n\nWe start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.\n\n\n% cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.9.115\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.9.115\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.115\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n        resources:\n          limits:\n            cpu: 200m\n            memory: 200Mi\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5\n\n\n\nWe now deploy a simple demo application serving html:\n\n\n% cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.117\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -\n inlineContent(\\\"\nbody style='color: white; background-color: green;'\nh1\nHello!\n/h1\n\\\") -\n \nshunt\n\"\n        ports:\n        - containerPort: 9090\n\n\n\nWe deploy a service type ClusterIP that we will select from ingress:\n\n\n% cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: sszuecs-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: sszuecs-demo\n\n\n\nTo deploy both, you have to run:\n\n\n% kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml\n\n\n\nNow we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:\n\n\n% cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo.\nmydomain.org\n\n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80\n\n\n\nTo deploy this ingress, you have to run:\n\n\n% kubectl create -f demo-ing.yaml\n\n\n\nSkipper will configure itself for the given ingress, such that you can test doing:\n\n\n% curl -v -H\"Host: skipper-demo.\nmydomain.org\n\" http://\nnodeip\n:9999/\n\n\n\nThe next question you may ask is: how to expose this to your customers?\n\n\nThe answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS \n.\n\nto your frontend loadbalancer IP that directs all traffic from \n.\n\nto all Kubernetes worker nodes on TCP port 9999.\n\n\nA more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example\n\nkube-aws-ingress-controller\n,\nand your DNS, \nexternal-dns\n\nautomatically.\n\n\nAdvanced Examples\n\n\nBlue-Green deployments\n\n\nTo do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification. \nzalando.org/backend-weights\n\nis a hash map, which key relates to the \nserviceName\n of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.\n\n\nIn the following example \nmy-app-1\n service will get \n80%\n of the traffic\nand \nmy-app-2\n will get \n20%\n of the traffic:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /\n\n\n\nCircuitbreaker\n\n\nConsecutive Breaker\n\n\nThe \nconsecutiveBreaker\n\nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments\n\ndocumented\n:\n\n\nconsecutiveBreaker(15)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRate Breaker\n\n\nThe \nrateBreaker\n\nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments\n\ndocumented\n.\n\n\nrateBreaker(30, 300)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRatelimits\n\n\nMore details you will find in \nratelimit package\n\nand \nkubernetes dataclient\n documentation.\n\n\nClient Ratelimits\n\n\nThe example shows 3 calls per minute per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(3, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nService Ratelimits\n\n\nThe example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nuse Predicates\n\n\nPredicates\n\nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.\n\n\nYou can use all kinds of \npredicates\n\nwith \nfilters\n together.\n\n\nFeature Toggle\n\n\nThis ingress route will only be matched if there is a Querystring\n\"version=alpha\" defined in the request. Like this you can easily build\nfeature toggles.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha\nspec:\n  rules:\n  - host: alpha-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80\n\n\n\nChaining Filters\n\n\nYou can set multiple filters in a chain similar to the \neskip format\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -\n requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes", 
            "text": "Skipper's Kubernetes dataclient can be used, if you want to run skipper as kubernetes-ingress-controller .\nIt will get it's route information from provisioned Ingress Objects .\nDetailed information you find in our  godoc for dataclient kubernetes .", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#skipper-features", 
            "text": "Skipper has the following main features:   Filters - create, update, delete all kind of HTTP data  collection of base http manipulations : for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling  cookie handling  circuitbreakers : consecutiveBreaker or rateBreaker  ratelimit : based on client or backend data  Shadow traffic:  tee()  Predicates - advanced matching capability  URL Path match:  Path(\"/foo\")  Host header match:  Host(\"^www.example.org$\")  Querystring :  QueryParam(\"featureX\")  Cookie based :  Cookie(\"alpha\", /^enabled$/)  source whitelist :  Source(\"1.2.3.4/24\")  time based interval  traffic by percentage  supports also sticky sessions  Kubernetes integration  All Filters and Predicates can be used with 2 annotations  Predicates:  zalando.org/skipper-predicate  Filters:  zalando.org/skipper-filter    metrics  access logs  Blue-Green deployments, with another Ingress annotation  zalando.org/backend-weights , see Advanced Examples section", 
            "title": "Skipper Features"
        }, 
        {
            "location": "/dataclients/kubernetes/#3-minutes-skipper-in-kubernetes-introduction", 
            "text": "You should have a base understanding of  Kubernetes  and Ingress .  Prerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.  We start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.  % cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.9.115\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.9.115\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.115\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n        resources:\n          limits:\n            cpu: 200m\n            memory: 200Mi\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5  We now deploy a simple demo application serving html:  % cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.117\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -  inlineContent(\\\" body style='color: white; background-color: green;' h1 Hello! /h1 \\\") -   shunt \"\n        ports:\n        - containerPort: 9090  We deploy a service type ClusterIP that we will select from ingress:  % cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: sszuecs-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: sszuecs-demo  To deploy both, you have to run:  % kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml  Now we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:  % cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo. mydomain.org \n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80  To deploy this ingress, you have to run:  % kubectl create -f demo-ing.yaml  Skipper will configure itself for the given ingress, such that you can test doing:  % curl -v -H\"Host: skipper-demo. mydomain.org \" http:// nodeip :9999/  The next question you may ask is: how to expose this to your customers?  The answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS  . \nto your frontend loadbalancer IP that directs all traffic from  . \nto all Kubernetes worker nodes on TCP port 9999.  A more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example kube-aws-ingress-controller ,\nand your DNS,  external-dns \nautomatically.", 
            "title": "3 Minutes Skipper in Kubernetes introduction"
        }, 
        {
            "location": "/dataclients/kubernetes/#advanced-examples", 
            "text": "", 
            "title": "Advanced Examples"
        }, 
        {
            "location": "/dataclients/kubernetes/#blue-green-deployments", 
            "text": "To do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification.  zalando.org/backend-weights \nis a hash map, which key relates to the  serviceName  of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.  In the following example  my-app-1  service will get  80%  of the traffic\nand  my-app-2  will get  20%  of the traffic:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /", 
            "title": "Blue-Green deployments"
        }, 
        {
            "location": "/dataclients/kubernetes/#circuitbreaker", 
            "text": "", 
            "title": "Circuitbreaker"
        }, 
        {
            "location": "/dataclients/kubernetes/#consecutive-breaker", 
            "text": "The  consecutiveBreaker \nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments documented :  consecutiveBreaker(15)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Consecutive Breaker"
        }, 
        {
            "location": "/dataclients/kubernetes/#rate-breaker", 
            "text": "The  rateBreaker \nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments documented .  rateBreaker(30, 300)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Rate Breaker"
        }, 
        {
            "location": "/dataclients/kubernetes/#ratelimits", 
            "text": "More details you will find in  ratelimit package \nand  kubernetes dataclient  documentation.", 
            "title": "Ratelimits"
        }, 
        {
            "location": "/dataclients/kubernetes/#client-ratelimits", 
            "text": "The example shows 3 calls per minute per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(3, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Client Ratelimits"
        }, 
        {
            "location": "/dataclients/kubernetes/#service-ratelimits", 
            "text": "The example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Service Ratelimits"
        }, 
        {
            "location": "/dataclients/kubernetes/#use-predicates", 
            "text": "Predicates \nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.  You can use all kinds of  predicates \nwith  filters  together.", 
            "title": "use Predicates"
        }, 
        {
            "location": "/dataclients/kubernetes/#feature-toggle", 
            "text": "This ingress route will only be matched if there is a Querystring\n\"version=alpha\" defined in the request. Like this you can easily build\nfeature toggles.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha\nspec:\n  rules:\n  - host: alpha-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80", 
            "title": "Feature Toggle"
        }, 
        {
            "location": "/dataclients/kubernetes/#chaining-filters", 
            "text": "You can set multiple filters in a chain similar to the  eskip format .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -  requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Chaining Filters"
        }, 
        {
            "location": "/dataclients/route-string/", 
            "text": "Route String\n\n\nRoute string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.\n\n\nServe text\n\n\nServe with \nContent-Type: text/plain; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nServe HTML with CSS\n\n\nServe with \nContent-Type: text/html; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nServe JSON\n\n\nServe with \nContent-Type: application/json; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n% skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#route-string", 
            "text": "Route string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#serve-text", 
            "text": "Serve with  Content-Type: text/plain; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '", 
            "title": "Serve text"
        }, 
        {
            "location": "/dataclients/route-string/#serve-html-with-css", 
            "text": "Serve with  Content-Type: text/html; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '", 
            "title": "Serve HTML with CSS"
        }, 
        {
            "location": "/dataclients/route-string/#serve-json", 
            "text": "Serve with  Content-Type: application/json; charset=utf-8  Example (Open your browser http://localhost:9090/):  % skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '", 
            "title": "Serve JSON"
        }
    ]
}