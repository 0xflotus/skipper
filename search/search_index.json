{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Architecture Skipper is written as a library and is also a multi binary project with 2 binaries, named skipper and eskip . Skipper is the HTTP proxy and eskip is a CLI application to verify, print, update or delete Skipper routes. Skipper's internal architecture is split into different packages. The skipper package has connections to multiple dataclient , that pull information from different sources, for example static routes from an eskip file or dynamic routes from Kubernetes ingress objects. The proxy package gets the routes populated by skipper and has always a current routing table which will be replaced on change. A route is one entry in the routing table. A route consists of one or more predicate , that are used to find a route for a given HTTP request. A route can also have one or more filter , that can modify the content of the request or response. A route always points to a backend, or it's a <shunt> , meaning that skipper serves the requests for the route, or a <loopback> , meaning that the request will be matched against the routing table again after filters have modified it. Opentracing API is supported via skipper-plugins . For example Jaeger is supported. Skipper has a rich set of metrics that are exposed as json, but can be exported in Prometheus format. Route processing Package skipper has a Go http.Server and does the ListenAndServe call with the loggingHandler wrapped proxy . The loggingHandler is basically a middleware for the proxy providing access logs and both implement the plain Go http.Handler interface . For each incoming http.Request the proxy will create a request context and enhance it with an Opentracing API Span. It will check proxy global ratelimits first and after that lookup the route in the routing table. After that skipper will apply all request filters, that can modify the http.Request . It will then check the route local ratelimits, the circuitbreakers and do the backend call. If the backend call got a TCP or TLS connection error in a loadbalanced route, skipper will do a retry to another backend of that loadbalanced group automatically. Just before the response to the caller, skipper will process the response filters, that can change the http.Response . In two special cases, skipper doesn't forward the request to the backend. When the route is shunted ( <shunt> ), skipper serves the request alone, by using only the filters. When the route is a <loopback> , the request is passed to the routing table for finding another route, based on the changes that the filters made to the request. Routing mechanism The routing executes the following steps in the typical case: Select the best fitting route by matching the request against the predicates. When no route found, respond with 404 (unless the default status code is configured to a different value). Execute the filters defined in the route in normal order on the request. The filters may or may not alter the request. Forward the request to the backend defined by the route and receive a response. Execute the filters defined in the route in reverse order on the response. The filters may or may not alter the response. Respond to the incoming request with the resulting response. Route matching Skipper can handle a relatively large number of routes with acceptable performance, while being able to use any attribute of the incoming HTTP requests to distinguish between them. In order to be able to do so, the path matching predicates ( Path() and PathSubtree() but not PathRegexp() ) have a special role during route matching, which is a tradeoff by design, and needs to be kept in mind to understand in some cases why a certain route was matched for a request instead of another. The route matching logic can be summed up as follows: Lookup in the path tree based on the Path() and the PathSubtree() predicates, using the path component of the incoming request's URI. Then the remaining predicates of the found route(s) are evaluated. the path lookup is a radix tree with O(log(n)) time complexity in case of intersecting paths, the more specific path is matched in the tree PathRegexp() is not used in the tree, but it is evaluated only after Path() or PathSubtree() , just like e.g. Method() or Host() . If step #1 matches multiple routes, which means there are multiple routes in the same position of the path tree, and all other predicates match the request, too, then the route with the most defined predicates is matched. this is an O(n) lookup, but only on the same leaf the root of the tree is considered a single leaf, so if not using the Path() or PathSubtree() predicates, the entire lookup will become O(n) over all the routes. If #2 results in multiple matching routes, then one route will be selected. It is unspecified which one.","title":"Architecture"},{"location":"#architecture","text":"Skipper is written as a library and is also a multi binary project with 2 binaries, named skipper and eskip . Skipper is the HTTP proxy and eskip is a CLI application to verify, print, update or delete Skipper routes. Skipper's internal architecture is split into different packages. The skipper package has connections to multiple dataclient , that pull information from different sources, for example static routes from an eskip file or dynamic routes from Kubernetes ingress objects. The proxy package gets the routes populated by skipper and has always a current routing table which will be replaced on change. A route is one entry in the routing table. A route consists of one or more predicate , that are used to find a route for a given HTTP request. A route can also have one or more filter , that can modify the content of the request or response. A route always points to a backend, or it's a <shunt> , meaning that skipper serves the requests for the route, or a <loopback> , meaning that the request will be matched against the routing table again after filters have modified it. Opentracing API is supported via skipper-plugins . For example Jaeger is supported. Skipper has a rich set of metrics that are exposed as json, but can be exported in Prometheus format.","title":"Architecture"},{"location":"#route-processing","text":"Package skipper has a Go http.Server and does the ListenAndServe call with the loggingHandler wrapped proxy . The loggingHandler is basically a middleware for the proxy providing access logs and both implement the plain Go http.Handler interface . For each incoming http.Request the proxy will create a request context and enhance it with an Opentracing API Span. It will check proxy global ratelimits first and after that lookup the route in the routing table. After that skipper will apply all request filters, that can modify the http.Request . It will then check the route local ratelimits, the circuitbreakers and do the backend call. If the backend call got a TCP or TLS connection error in a loadbalanced route, skipper will do a retry to another backend of that loadbalanced group automatically. Just before the response to the caller, skipper will process the response filters, that can change the http.Response . In two special cases, skipper doesn't forward the request to the backend. When the route is shunted ( <shunt> ), skipper serves the request alone, by using only the filters. When the route is a <loopback> , the request is passed to the routing table for finding another route, based on the changes that the filters made to the request.","title":"Route processing"},{"location":"#routing-mechanism","text":"The routing executes the following steps in the typical case: Select the best fitting route by matching the request against the predicates. When no route found, respond with 404 (unless the default status code is configured to a different value). Execute the filters defined in the route in normal order on the request. The filters may or may not alter the request. Forward the request to the backend defined by the route and receive a response. Execute the filters defined in the route in reverse order on the response. The filters may or may not alter the response. Respond to the incoming request with the resulting response.","title":"Routing mechanism"},{"location":"#route-matching","text":"Skipper can handle a relatively large number of routes with acceptable performance, while being able to use any attribute of the incoming HTTP requests to distinguish between them. In order to be able to do so, the path matching predicates ( Path() and PathSubtree() but not PathRegexp() ) have a special role during route matching, which is a tradeoff by design, and needs to be kept in mind to understand in some cases why a certain route was matched for a request instead of another. The route matching logic can be summed up as follows: Lookup in the path tree based on the Path() and the PathSubtree() predicates, using the path component of the incoming request's URI. Then the remaining predicates of the found route(s) are evaluated. the path lookup is a radix tree with O(log(n)) time complexity in case of intersecting paths, the more specific path is matched in the tree PathRegexp() is not used in the tree, but it is evaluated only after Path() or PathSubtree() , just like e.g. Method() or Host() . If step #1 matches multiple routes, which means there are multiple routes in the same position of the path tree, and all other predicates match the request, too, then the route with the most defined predicates is matched. this is an O(n) lookup, but only on the same leaf the root of the tree is considered a single leaf, so if not using the Path() or PathSubtree() predicates, the entire lookup will become O(n) over all the routes. If #2 results in multiple matching routes, then one route will be selected. It is unspecified which one.","title":"Route matching"},{"location":"deployments/","text":"Deployments and Data-Clients Edge HTTP Routing Edge HTTP routing is the first hit to your production HTTP loadbalancer. Skipper can serve this well and reliably in production since 2016. On the edge you want to dispatch incoming HTTP requests to your backends, which could be a microservice architecture. In this deployment mode you might have 100k HTTP routes, which are used in production and modified by many parties. To support this scenario we have the etcd dataclient . Etcd is a distributed database. TODO: why we use ETCD for this purpose Kubernetes Ingress Kubernetes Ingress is the component responsible to route traffic into your Kubernetes cluster. As deployer you can define an ingress object and an ingress controller will make sure incoming traffic gets routed to her backend service as defined. Skipper supports this scenario with the Kubernetes dataclient and is used in production since end of 2016. Skipper as ingress controller does not need to have any file configuration or anything external which configures Skipper. Skipper automatically finds Ingress objects and configures routes automatically, without reloading. The only requirement is to target all traffic you want to serve with Kubernetes to a loadbalancer pool of Skippers. This is a clear advantage over other ingress controllers like nginx, haproxy or envoy. Read more about Skipper's Kubernetes dataclient . Innkeeper Routes API Skipper can read from an Innkeeper API , if you like to create routes via an API. Our Innkeeper API dataclient can be used as well. It was used in production in the past. (TODO: do we use it somewhere?) Demos / Talks In demos you may want to show arbitrary hello world applications. You can easily describe html or json output on the command line with the route-string dataclient . Simple Routes File The most static deployment that is known from apache, nginx or haproxy is write your routes into a file and start your http server. This is what the Eskip file dataclient is about.","title":"Deployments"},{"location":"deployments/#deployments-and-data-clients","text":"","title":"Deployments and Data-Clients"},{"location":"deployments/#edge-http-routing","text":"Edge HTTP routing is the first hit to your production HTTP loadbalancer. Skipper can serve this well and reliably in production since 2016. On the edge you want to dispatch incoming HTTP requests to your backends, which could be a microservice architecture. In this deployment mode you might have 100k HTTP routes, which are used in production and modified by many parties. To support this scenario we have the etcd dataclient . Etcd is a distributed database. TODO: why we use ETCD for this purpose","title":"Edge HTTP Routing"},{"location":"deployments/#kubernetes-ingress","text":"Kubernetes Ingress is the component responsible to route traffic into your Kubernetes cluster. As deployer you can define an ingress object and an ingress controller will make sure incoming traffic gets routed to her backend service as defined. Skipper supports this scenario with the Kubernetes dataclient and is used in production since end of 2016. Skipper as ingress controller does not need to have any file configuration or anything external which configures Skipper. Skipper automatically finds Ingress objects and configures routes automatically, without reloading. The only requirement is to target all traffic you want to serve with Kubernetes to a loadbalancer pool of Skippers. This is a clear advantage over other ingress controllers like nginx, haproxy or envoy. Read more about Skipper's Kubernetes dataclient .","title":"Kubernetes Ingress"},{"location":"deployments/#innkeeper-routes-api","text":"Skipper can read from an Innkeeper API , if you like to create routes via an API. Our Innkeeper API dataclient can be used as well. It was used in production in the past. (TODO: do we use it somewhere?)","title":"Innkeeper Routes API"},{"location":"deployments/#demos-talks","text":"In demos you may want to show arbitrary hello world applications. You can easily describe html or json output on the command line with the route-string dataclient .","title":"Demos / Talks"},{"location":"deployments/#simple-routes-file","text":"The most static deployment that is known from apache, nginx or haproxy is write your routes into a file and start your http server. This is what the Eskip file dataclient is about.","title":"Simple Routes File"},{"location":"development/","text":"How to develop a Filter A filter is part of a route and can change arbitary http data in the http.Request and http.Response path of a proxy. The filter example shows a non trivial diff of a filter implementation, that implements an authnz webhook. It shows global settings passed via flags, user documentation, developer documentation for library users, the filter implementation and some test cases. Tests should test the actual filter implementation in a proxy setup. How to pass options to your filter Set a default and a Usage string as const. Add a var to hold the value and put the flag to the category, that makes the most sense. If a filter, predicate or dataclient need Options passed from flags, then you should register the filter in skipper.go , the main library entrypoint. In case you do not need options from flags, use MakeRegistry() in ./filters/builtin/builtin.go to register your filter. diff --git a/cmd/skipper/main.go b/cmd/skipper/main.go index 28f18f9..4530b85 100644 --- a/cmd/skipper/main.go +++ b/cmd/skipper/main.go @@ -59,9 +59,10 @@ const ( defaultOAuthTokeninfoTimeout = 2 * time.Second defaultOAuthTokenintrospectionTimeout = 2 * time.Second + defaultWebhookTimeout = 2 * time.Second // generic: addressUsage = \"network address that skipper should listen on\" @@ -141,6 +142,8 @@ const ( oauth2TokeninfoURLUsage = \"sets the default tokeninfo URL to query information about an incoming OAuth2 token in oauth2Tokeninfo filters\" oauth2TokeninfoTimeoutUsage = \"sets the default tokeninfo request timeout duration to 2000ms\" oauth2TokenintrospectionTimeoutUsage = \"sets the default tokenintrospection request timeout duration to 2000ms\" + webhookTimeoutUsage = \"sets the webhook request timeout duration, defaults to 2s\" + // connections, timeouts: idleConnsPerHostUsage = \"maximum idle connections per backend host\" closeIdleConnsPeriodUsage = \"period of closing all idle connections in seconds or as a duration string. Not closing when less than 0\" @@ -243,13 +246,14 @@ var ( oauth2TokeninfoURL string oauth2TokeninfoTimeout time.Duration oauth2TokenintrospectionTimeout time.Duration + webhookTimeout time.Duration // connections, timeouts: idleConnsPerHost int @@ -351,13 +355,14 @@ func init() { flag.DurationVar(&oauth2TokeninfoTimeout, \"oauth2-tokeninfo-timeout\", defaultOAuthTokeninfoTimeout, oauth2TokeninfoTimeoutUsage) flag.DurationVar(&oauth2TokenintrospectionTimeout, \"oauth2-tokenintrospect-timeout\", defaultOAuthTokenintrospectionTimeout, oauth2TokenintrospectionTimeoutUsage) + flag.DurationVar(&webhookTimeout, \"webhook-timeout\", defaultWebhookTimeout, webhookTimeoutUsage) // connections, timeouts: flag.IntVar(&idleConnsPerHost, \"idle-conns-num\", proxy.DefaultIdleConnsPerHost, idleConnsPerHostUsage) @@ -536,13 +541,14 @@ func main() { OAuthTokeninfoURL: oauth2TokeninfoURL, OAuthTokeninfoTimeout: oauth2TokeninfoTimeout, OAuthTokenintrospectionTimeout: oauth2TokenintrospectionTimeout, + WebhookTimeout: webhookTimeout, // connections, timeouts: IdleConnectionsPerHost: idleConnsPerHost, diff --git a/skipper.go b/skipper.go index 10d5769..da46fe0 100644 --- a/skipper.go +++ b/skipper.go @@ -443,6 +443,9 @@ type Options struct { // OAuthTokenintrospectionTimeout sets timeout duration while calling oauth tokenintrospection service OAuthTokenintrospectionTimeout time.Duration + // WebhookTimeout sets timeout duration while calling a custom webhook auth service + WebhookTimeout time.Duration + // MaxAuditBody sets the maximum read size of the body read by the audit log filter MaxAuditBody int } @@ -677,7 +680,8 @@ func Run(o Options) error { auth.NewOAuthTokenintrospectionAnyClaims(o.OAuthTokenintrospectionTimeout), auth.NewOAuthTokenintrospectionAllClaims(o.OAuthTokenintrospectionTimeout), auth.NewOAuthTokenintrospectionAnyKV(o.OAuthTokenintrospectionTimeout), - auth.NewOAuthTokenintrospectionAllKV(o.OAuthTokenintrospectionTimeout)) + auth.NewOAuthTokenintrospectionAllKV(o.OAuthTokenintrospectionTimeout), + auth.NewWebhook(o.WebhookTimeout)) // create a filter registry with the available filter specs registered, // and register the custom filters User documentation Documentation for users should be done in docs/ . diff --git a/docs/filters.md b/docs/filters.md index d3bb872..a877062 100644 --- a/docs/filters.md +++ b/docs/filters.md @@ -382,6 +382,24 @@ basicAuth(\"/path/to/htpasswd\") basicAuth(\"/path/to/htpasswd\", \"My Website\") ``` +## webhook + +The `webhook` filter makes it possible to have your own authentication and +authorization endpoint as a filter. + +Headers from the incoming request will be copied into the request that +is being done to the webhook endpoint. Responses from the webhook with +status code less than 300 will be authorized, rest unauthorized. + +Examples: + +``` +webhook(\"https://custom-webhook.example.org/auth\") +``` + +The webhook timeout has a default of 2 seconds and can be globally +changed, if skipper is started with `-webhook-timeout=2s` flag. + ## oauthTokeninfoAnyScope If skipper is started with `-oauth2-tokeninfo-url` flag, you can use Add godoc Godoc is meant for developers using skipper as library, use doc.go of the package to document generic functionality, usage and library usage. diff --git a/filters/auth/doc.go b/filters/auth/doc.go index 696d3fd..1d6e3a8 100644 --- a/filters/auth/doc.go +++ b/filters/auth/doc.go @@ -318,5 +318,12 @@ filter after the auth filter. a: Path(\"/only-allowed-audit-log\") -> oauthTokeninfoAnyScope(\"bar-w\") -> auditLog() -> \"https://internal.example.org/\"; b: Path(\"/all-access-requests-audit-log\") -> auditLog() -> oauthTokeninfoAnyScope(\"foo-r\") -> \"https://internal.example.org/\"; +Webhook - webhook() filter + +The filter webhook allows you to have a custom authentication and +authorization endpoint for a route. + + a: Path(\"/only-allowed-by-webhook\") -> webhook(\"https://custom-webhook.example.org/auth\") -> \"https://protected-backend.example.org/\"; + */ package auth Filter implementation A filter can modify the incoming http.Request before calling the backend and the outgoing http.Response from the backend to the client. A filter consists of at least two types a spec and a filter . Spec consists of everything that is needed and known before a user will instantiate a filter. A spec will be created in the bootstrap procedure of a skipper process. A spec has to satisfy the Spec interface Name() string and CreateFilter([]interface{}) (filters.Filter, error) . The actual filter implementation has to satisfy the Filter interface Request(filters.FilterContext) and Response(filters.FilterContext) . If you need to clean up for example a goroutine you can do it in Close() , which will be called on filter shutdown. diff --git a/filters/auth/webhook.go b/filters/auth/webhook.go new file mode 100644 index 0000000..f0632a6 --- /dev/null +++ b/filters/auth/webhook.go @@ -0,0 +1,84 @@ +package auth + +import ( + \"net/http\" + \"time\" + + \"github.com/zalando/skipper/filters\" +) + +const ( + WebhookName = \"webhook\" +) + +type ( + webhookSpec struct { + Timeout time.Duration + } + webhookFilter struct { + authClient *authClient + } +) + +// NewWebhook creates a new auth filter specification +// to validate authorization for requests. +func NewWebhook(d time.Duration) filters.Spec { + return &webhookSpec{Timeout: d} +} + +func (*webhookSpec) Name() string { + return WebhookName +} + +// CreateFilter creates an auth filter. The first argument is an URL +// string. +// +// s.CreateFilter(\"https://my-auth-service.example.org/auth\") +// +func (ws *webhookSpec) CreateFilter(args []interface{}) (filters.Filter, error) { + if l := len(args); l == 0 || l > 2 { + return nil, filters.ErrInvalidFilterParameters + } + + s, ok := args[0].(string) + if !ok { + return nil, filters.ErrInvalidFilterParameters + } + + ac, err := newAuthClient(s, ws.Timeout) + if err != nil { + return nil, filters.ErrInvalidFilterParameters + } + + return &webhookFilter{authClient: ac}, nil +} + +func copyHeader(to, from http.Header) { + for k, v := range from { + to[http.CanonicalHeaderKey(k)] = v + } +} + +func (f *webhookFilter) Request(ctx filters.FilterContext) { + statusCode, err := f.authClient.getWebhook(ctx.Request()) + if err != nil { + unauthorized(ctx, WebhookName, authServiceAccess, f.authClient.url.Hostname()) + } + // redirects, auth errors, webhook errors + if statusCode >= 300 { + unauthorized(ctx, WebhookName, invalidAccess, f.authClient.url.Hostname()) + } + authorized(ctx, WebhookName) +} + +func (*webhookFilter) Response(filters.FilterContext) {} + +// Close cleans-up the quit channel used for this filter +func (f *webhookFilter) Close() { + f.authClient.mu.Lock() + if f.authClient.quit != nil { + close(f.authClient.quit) + f.authClient.quit = nil + } + f.authClient.mu.Unlock() +} Writing tests Skipper uses normal table driven Go tests without frameworks. This example filter test creates a backend, an auth service to be called by our filter, and a filter configured by our table driven test. In general we use real backends with dynamic port allocations. We call these and inspect the http.Response to check, if we get expected results for invalid and valid data. Skipper has some helpers to create the test proxy in the proxytest package. Backends can be created with httptest.NewServer as in the example below. diff --git a/filters/auth/webhook_test.go b/filters/auth/webhook_test.go new file mode 100644 index 0000000..d43c4ea --- /dev/null +++ b/filters/auth/webhook_test.go @@ -0,0 +1,128 @@ +package auth + +import ( + \"fmt\" + \"io\" + \"net/http\" + \"net/http/httptest\" + \"net/url\" + \"testing\" + \"time\" + + \"github.com/zalando/skipper/eskip\" + \"github.com/zalando/skipper/filters\" + \"github.com/zalando/skipper/proxy/proxytest\" +) + +func TestWebhook(t *testing.T) { + for _, ti := range []struct { + msg string + token string + expected int + authorized bool + timeout bool + }{{ + msg: \"invalid-token-should-be-unauthorized\", + token: \"invalid-token\", + expected: http.StatusUnauthorized, + authorized: false, + }, { + msg: \"valid-token-should-be-authorized\", + token: testToken, + expected: http.StatusOK, + authorized: true, + }, { + msg: \"webhook-timeout-should-be-unauthorized\", + token: testToken, + expected: http.StatusUnauthorized, + authorized: false, + timeout: true, + }} { + t.Run(ti.msg, func(t *testing.T) { + backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) { + w.WriteHeader(http.StatusOK) + io.WriteString(w, \"Hello from backend\") + return + })) + defer backend.Close() + + authServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { + if ti.timeout { + time.Sleep(time.Second + time.Millisecond) + } + + if r.Method != \"GET\" { + w.WriteHeader(489) + io.WriteString(w, \"FAIL - not a GET request\") + return + } + + tok := r.Header.Get(authHeaderName) + tok = tok[len(authHeaderPrefix):len(tok)] + switch tok { + case testToken: + w.WriteHeader(200) + fmt.Fprintln(w, \"OK - Got token: \"+tok) + return + } + w.WriteHeader(402) //http.StatusUnauthorized) + fmt.Fprintln(w, \"Unauthorized - Got token: \") //+tok) + })) + defer authServer.Close() + + spec := NewWebhook(time.Second) + + args := []interface{}{ + \"http://\" + authServer.Listener.Addr().String(), + } + f, err := spec.CreateFilter(args) + if err != nil { + t.Errorf(\"error in creating filter for %s: %v\", ti.msg, err) + return + } + + f2 := f.(*webhookFilter) + defer f2.Close() + + fr := make(filters.Registry) + fr.Register(spec) + r := &eskip.Route{Filters: []*eskip.Filter{{Name: spec.Name(), Args: args}}, Backend: backend.URL} + + proxy := proxytest.New(fr, r) + defer proxy.Close() + + reqURL, err := url.Parse(proxy.URL) + if err != nil { + t.Errorf(\"Failed to parse url %s: %v\", proxy.URL, err) + return + } + + req, err := http.NewRequest(\"GET\", reqURL.String(), nil) + if err != nil { + t.Errorf(\"failed to create request %v\", err) + return + } + req.Header.Set(authHeaderName, authHeaderPrefix+ti.token) + + rsp, err := http.DefaultClient.Do(req) + if err != nil { + t.Errorf(\"failed to get response: %v\", err) + return + } + defer rsp.Body.Close() + + buf := make([]byte, 128) + var n int + if n, err = rsp.Body.Read(buf); err != nil && err != io.EOF { + t.Errorf(\"Could not read response body: %v\", err) + return + } + + t.Logf(\"%d %d\", rsp.StatusCode, ti.expected) + if rsp.StatusCode != ti.expected { + t.Errorf(\"unexpected status code: %v != %v %d %s\", rsp.StatusCode, ti.expected, n, buf) + return + } + }) + } +}","title":"Development"},{"location":"development/#how-to-develop-a-filter","text":"A filter is part of a route and can change arbitary http data in the http.Request and http.Response path of a proxy. The filter example shows a non trivial diff of a filter implementation, that implements an authnz webhook. It shows global settings passed via flags, user documentation, developer documentation for library users, the filter implementation and some test cases. Tests should test the actual filter implementation in a proxy setup.","title":"How to develop a Filter"},{"location":"development/#how-to-pass-options-to-your-filter","text":"Set a default and a Usage string as const. Add a var to hold the value and put the flag to the category, that makes the most sense. If a filter, predicate or dataclient need Options passed from flags, then you should register the filter in skipper.go , the main library entrypoint. In case you do not need options from flags, use MakeRegistry() in ./filters/builtin/builtin.go to register your filter. diff --git a/cmd/skipper/main.go b/cmd/skipper/main.go index 28f18f9..4530b85 100644 --- a/cmd/skipper/main.go +++ b/cmd/skipper/main.go @@ -59,9 +59,10 @@ const ( defaultOAuthTokeninfoTimeout = 2 * time.Second defaultOAuthTokenintrospectionTimeout = 2 * time.Second + defaultWebhookTimeout = 2 * time.Second // generic: addressUsage = \"network address that skipper should listen on\" @@ -141,6 +142,8 @@ const ( oauth2TokeninfoURLUsage = \"sets the default tokeninfo URL to query information about an incoming OAuth2 token in oauth2Tokeninfo filters\" oauth2TokeninfoTimeoutUsage = \"sets the default tokeninfo request timeout duration to 2000ms\" oauth2TokenintrospectionTimeoutUsage = \"sets the default tokenintrospection request timeout duration to 2000ms\" + webhookTimeoutUsage = \"sets the webhook request timeout duration, defaults to 2s\" + // connections, timeouts: idleConnsPerHostUsage = \"maximum idle connections per backend host\" closeIdleConnsPeriodUsage = \"period of closing all idle connections in seconds or as a duration string. Not closing when less than 0\" @@ -243,13 +246,14 @@ var ( oauth2TokeninfoURL string oauth2TokeninfoTimeout time.Duration oauth2TokenintrospectionTimeout time.Duration + webhookTimeout time.Duration // connections, timeouts: idleConnsPerHost int @@ -351,13 +355,14 @@ func init() { flag.DurationVar(&oauth2TokeninfoTimeout, \"oauth2-tokeninfo-timeout\", defaultOAuthTokeninfoTimeout, oauth2TokeninfoTimeoutUsage) flag.DurationVar(&oauth2TokenintrospectionTimeout, \"oauth2-tokenintrospect-timeout\", defaultOAuthTokenintrospectionTimeout, oauth2TokenintrospectionTimeoutUsage) + flag.DurationVar(&webhookTimeout, \"webhook-timeout\", defaultWebhookTimeout, webhookTimeoutUsage) // connections, timeouts: flag.IntVar(&idleConnsPerHost, \"idle-conns-num\", proxy.DefaultIdleConnsPerHost, idleConnsPerHostUsage) @@ -536,13 +541,14 @@ func main() { OAuthTokeninfoURL: oauth2TokeninfoURL, OAuthTokeninfoTimeout: oauth2TokeninfoTimeout, OAuthTokenintrospectionTimeout: oauth2TokenintrospectionTimeout, + WebhookTimeout: webhookTimeout, // connections, timeouts: IdleConnectionsPerHost: idleConnsPerHost, diff --git a/skipper.go b/skipper.go index 10d5769..da46fe0 100644 --- a/skipper.go +++ b/skipper.go @@ -443,6 +443,9 @@ type Options struct { // OAuthTokenintrospectionTimeout sets timeout duration while calling oauth tokenintrospection service OAuthTokenintrospectionTimeout time.Duration + // WebhookTimeout sets timeout duration while calling a custom webhook auth service + WebhookTimeout time.Duration + // MaxAuditBody sets the maximum read size of the body read by the audit log filter MaxAuditBody int } @@ -677,7 +680,8 @@ func Run(o Options) error { auth.NewOAuthTokenintrospectionAnyClaims(o.OAuthTokenintrospectionTimeout), auth.NewOAuthTokenintrospectionAllClaims(o.OAuthTokenintrospectionTimeout), auth.NewOAuthTokenintrospectionAnyKV(o.OAuthTokenintrospectionTimeout), - auth.NewOAuthTokenintrospectionAllKV(o.OAuthTokenintrospectionTimeout)) + auth.NewOAuthTokenintrospectionAllKV(o.OAuthTokenintrospectionTimeout), + auth.NewWebhook(o.WebhookTimeout)) // create a filter registry with the available filter specs registered, // and register the custom filters","title":"How to pass options to your filter"},{"location":"development/#user-documentation","text":"Documentation for users should be done in docs/ . diff --git a/docs/filters.md b/docs/filters.md index d3bb872..a877062 100644 --- a/docs/filters.md +++ b/docs/filters.md @@ -382,6 +382,24 @@ basicAuth(\"/path/to/htpasswd\") basicAuth(\"/path/to/htpasswd\", \"My Website\") ``` +## webhook + +The `webhook` filter makes it possible to have your own authentication and +authorization endpoint as a filter. + +Headers from the incoming request will be copied into the request that +is being done to the webhook endpoint. Responses from the webhook with +status code less than 300 will be authorized, rest unauthorized. + +Examples: + +``` +webhook(\"https://custom-webhook.example.org/auth\") +``` + +The webhook timeout has a default of 2 seconds and can be globally +changed, if skipper is started with `-webhook-timeout=2s` flag. + ## oauthTokeninfoAnyScope If skipper is started with `-oauth2-tokeninfo-url` flag, you can use","title":"User documentation"},{"location":"development/#add-godoc","text":"Godoc is meant for developers using skipper as library, use doc.go of the package to document generic functionality, usage and library usage. diff --git a/filters/auth/doc.go b/filters/auth/doc.go index 696d3fd..1d6e3a8 100644 --- a/filters/auth/doc.go +++ b/filters/auth/doc.go @@ -318,5 +318,12 @@ filter after the auth filter. a: Path(\"/only-allowed-audit-log\") -> oauthTokeninfoAnyScope(\"bar-w\") -> auditLog() -> \"https://internal.example.org/\"; b: Path(\"/all-access-requests-audit-log\") -> auditLog() -> oauthTokeninfoAnyScope(\"foo-r\") -> \"https://internal.example.org/\"; +Webhook - webhook() filter + +The filter webhook allows you to have a custom authentication and +authorization endpoint for a route. + + a: Path(\"/only-allowed-by-webhook\") -> webhook(\"https://custom-webhook.example.org/auth\") -> \"https://protected-backend.example.org/\"; + */ package auth","title":"Add godoc"},{"location":"development/#filter-implementation","text":"A filter can modify the incoming http.Request before calling the backend and the outgoing http.Response from the backend to the client. A filter consists of at least two types a spec and a filter . Spec consists of everything that is needed and known before a user will instantiate a filter. A spec will be created in the bootstrap procedure of a skipper process. A spec has to satisfy the Spec interface Name() string and CreateFilter([]interface{}) (filters.Filter, error) . The actual filter implementation has to satisfy the Filter interface Request(filters.FilterContext) and Response(filters.FilterContext) . If you need to clean up for example a goroutine you can do it in Close() , which will be called on filter shutdown. diff --git a/filters/auth/webhook.go b/filters/auth/webhook.go new file mode 100644 index 0000000..f0632a6 --- /dev/null +++ b/filters/auth/webhook.go @@ -0,0 +1,84 @@ +package auth + +import ( + \"net/http\" + \"time\" + + \"github.com/zalando/skipper/filters\" +) + +const ( + WebhookName = \"webhook\" +) + +type ( + webhookSpec struct { + Timeout time.Duration + } + webhookFilter struct { + authClient *authClient + } +) + +// NewWebhook creates a new auth filter specification +// to validate authorization for requests. +func NewWebhook(d time.Duration) filters.Spec { + return &webhookSpec{Timeout: d} +} + +func (*webhookSpec) Name() string { + return WebhookName +} + +// CreateFilter creates an auth filter. The first argument is an URL +// string. +// +// s.CreateFilter(\"https://my-auth-service.example.org/auth\") +// +func (ws *webhookSpec) CreateFilter(args []interface{}) (filters.Filter, error) { + if l := len(args); l == 0 || l > 2 { + return nil, filters.ErrInvalidFilterParameters + } + + s, ok := args[0].(string) + if !ok { + return nil, filters.ErrInvalidFilterParameters + } + + ac, err := newAuthClient(s, ws.Timeout) + if err != nil { + return nil, filters.ErrInvalidFilterParameters + } + + return &webhookFilter{authClient: ac}, nil +} + +func copyHeader(to, from http.Header) { + for k, v := range from { + to[http.CanonicalHeaderKey(k)] = v + } +} + +func (f *webhookFilter) Request(ctx filters.FilterContext) { + statusCode, err := f.authClient.getWebhook(ctx.Request()) + if err != nil { + unauthorized(ctx, WebhookName, authServiceAccess, f.authClient.url.Hostname()) + } + // redirects, auth errors, webhook errors + if statusCode >= 300 { + unauthorized(ctx, WebhookName, invalidAccess, f.authClient.url.Hostname()) + } + authorized(ctx, WebhookName) +} + +func (*webhookFilter) Response(filters.FilterContext) {} + +// Close cleans-up the quit channel used for this filter +func (f *webhookFilter) Close() { + f.authClient.mu.Lock() + if f.authClient.quit != nil { + close(f.authClient.quit) + f.authClient.quit = nil + } + f.authClient.mu.Unlock() +}","title":"Filter implementation"},{"location":"development/#writing-tests","text":"Skipper uses normal table driven Go tests without frameworks. This example filter test creates a backend, an auth service to be called by our filter, and a filter configured by our table driven test. In general we use real backends with dynamic port allocations. We call these and inspect the http.Response to check, if we get expected results for invalid and valid data. Skipper has some helpers to create the test proxy in the proxytest package. Backends can be created with httptest.NewServer as in the example below. diff --git a/filters/auth/webhook_test.go b/filters/auth/webhook_test.go new file mode 100644 index 0000000..d43c4ea --- /dev/null +++ b/filters/auth/webhook_test.go @@ -0,0 +1,128 @@ +package auth + +import ( + \"fmt\" + \"io\" + \"net/http\" + \"net/http/httptest\" + \"net/url\" + \"testing\" + \"time\" + + \"github.com/zalando/skipper/eskip\" + \"github.com/zalando/skipper/filters\" + \"github.com/zalando/skipper/proxy/proxytest\" +) + +func TestWebhook(t *testing.T) { + for _, ti := range []struct { + msg string + token string + expected int + authorized bool + timeout bool + }{{ + msg: \"invalid-token-should-be-unauthorized\", + token: \"invalid-token\", + expected: http.StatusUnauthorized, + authorized: false, + }, { + msg: \"valid-token-should-be-authorized\", + token: testToken, + expected: http.StatusOK, + authorized: true, + }, { + msg: \"webhook-timeout-should-be-unauthorized\", + token: testToken, + expected: http.StatusUnauthorized, + authorized: false, + timeout: true, + }} { + t.Run(ti.msg, func(t *testing.T) { + backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) { + w.WriteHeader(http.StatusOK) + io.WriteString(w, \"Hello from backend\") + return + })) + defer backend.Close() + + authServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { + if ti.timeout { + time.Sleep(time.Second + time.Millisecond) + } + + if r.Method != \"GET\" { + w.WriteHeader(489) + io.WriteString(w, \"FAIL - not a GET request\") + return + } + + tok := r.Header.Get(authHeaderName) + tok = tok[len(authHeaderPrefix):len(tok)] + switch tok { + case testToken: + w.WriteHeader(200) + fmt.Fprintln(w, \"OK - Got token: \"+tok) + return + } + w.WriteHeader(402) //http.StatusUnauthorized) + fmt.Fprintln(w, \"Unauthorized - Got token: \") //+tok) + })) + defer authServer.Close() + + spec := NewWebhook(time.Second) + + args := []interface{}{ + \"http://\" + authServer.Listener.Addr().String(), + } + f, err := spec.CreateFilter(args) + if err != nil { + t.Errorf(\"error in creating filter for %s: %v\", ti.msg, err) + return + } + + f2 := f.(*webhookFilter) + defer f2.Close() + + fr := make(filters.Registry) + fr.Register(spec) + r := &eskip.Route{Filters: []*eskip.Filter{{Name: spec.Name(), Args: args}}, Backend: backend.URL} + + proxy := proxytest.New(fr, r) + defer proxy.Close() + + reqURL, err := url.Parse(proxy.URL) + if err != nil { + t.Errorf(\"Failed to parse url %s: %v\", proxy.URL, err) + return + } + + req, err := http.NewRequest(\"GET\", reqURL.String(), nil) + if err != nil { + t.Errorf(\"failed to create request %v\", err) + return + } + req.Header.Set(authHeaderName, authHeaderPrefix+ti.token) + + rsp, err := http.DefaultClient.Do(req) + if err != nil { + t.Errorf(\"failed to get response: %v\", err) + return + } + defer rsp.Body.Close() + + buf := make([]byte, 128) + var n int + if n, err = rsp.Body.Read(buf); err != nil && err != io.EOF { + t.Errorf(\"Could not read response body: %v\", err) + return + } + + t.Logf(\"%d %d\", rsp.StatusCode, ti.expected) + if rsp.StatusCode != ti.expected { + t.Errorf(\"unexpected status code: %v != %v %d %s\", rsp.StatusCode, ti.expected, n, buf) + return + } + }) + } +}","title":"Writing tests"},{"location":"filters/","text":"Skipper Filters The parameters can be strings, regex or float64 / int string is a string surrounded by double quotes ( \" ) regex is a regular expression, surrounded by / , e.g. /^www\\.example\\.org(:\\d+)?$/ int / float64 are usual (decimal) numbers like 401 or 1.23456 time is a string in double quotes, parseable by time.Duration ) Filters are a generic tool and can change HTTP header and body in the request and response path. Filter can be chained using the arrow operator -> . Example route with a match all, 2 filters and a backend: all: * -> filter1 -> filter2 -> \"http://127.0.0.1:1234/\"; setRequestHeader Set headers for requests. Parameters: header name (string) header value (string) Example: foo: * -> setRequestHeader(\"X-Passed-Skipper\", \"true\") -> \"https://backend.example.org\"; setResponseHeader Same as setRequestHeader , only for responses appendRequestHeader Same as setRequestHeader , does not remove a possibly existing value, but adds a new header value appendResponseHeader Same as appendRequestHeader , only for responses dropRequestHeader Removes a header from the request Parameters: * header name (string) Example: foo: * -> dropRequestHeader(\"User-Agent\") -> \"https://backend.example.org\"; dropResponseHeader Same as dropRequestHeader but for responses from the backend modPath Replace all matched regex expressions in the path. Parameters: the expression to match (regex) the replacement (string) setPath Replace the path of the original request to the replacement. Parameters: * the replacement (string) redirectTo Creates an HTTP redirect response. Parameters: redirect status code (int) location (string) Example: redir: PathRegex(/^\\/foo\\/bar/) -> redirectTo(302, \"/foo/newBar\") -> <shunt>; redirectToLower Same as redirectTo , but replaces all strings to lower case. static Serves static content from the filesystem. Parameters: Request path to strip (string) Target base path in the filesystem (string) Example: This serves files from /srv/www/dehydrated when requested via /.well-known/acme-challenge/ , e.g. the request GET /.well-known/acme-challenge/foo will serve the file /srv/www/dehydrated/foo . acme: Host(/./) && Method(\"GET\") && Path(\"/.well-known/acme-challenge/*\") -> static(\"/.well-known/acme-challenge/\", \"/srv/www/dehydrated\") -> <shunt>; Notes: redirects to the directory when a file index.html exists and it is requested, i.e. GET /foo/index.html redirects to /foo/ which serves then the /foo/index.html serves the content of the index.html when a directory is requested does a simple directory listing of files / directories when no index.html is present stripQuery preserveHost Sets the incoming Host: header on the outgoing backend connection. It can be used to override the proxyPreserveHost behavior for individual routes. Parameters: \"true\" or \"false\" \"true\" - use the Host header from the incoming request \"false\" - use the host from the backend address Example: route1: * -> preserveHost(\"true\") -> \"http://backend.example.org\"; status Sets the response status code to the given value, with no regards to the backend response. Parameters: status code (int) Example: route1: Host(/^all401\\.example\\.org$/) -> status(401) -> <shunt>; compress The filter, when executed on the response path, checks if the response entity can be compressed. To decide, it checks the Content-Encoding, the Cache-Control and the Content-Type headers. It doesn't compress the content if the Content-Encoding is set to other than identity, or the Cache-Control applies the no-transform pragma, or the Content-Type is set to an unsupported value. The default supported content types are: text/plain , text/html , application/json , application/javascript , application/x-javascript , text/javascript , text/css , image/svg+xml , application/octet-stream . The default set of MIME types can be reset or extended by passing in the desired types as filter arguments. When extending the defaults, the first argument needs to be \"...\" . E.g. to compress tiff in addition to the defaults: * -> compress(\"...\", \"image/tiff\") -> \"https://www.example.org\" To reset the supported types, e.g. to compress only HTML, the \"...\" argument needs to be omitted: * -> compress(\"text/html\") -> \"https://www.example.org\" It is possible to control the compression level, by setting it as the first filter argument, in front of the MIME types. The default compression level is best-speed. The possible values are integers between 0 and 9 (inclusive), where 0 means no-compression, 1 means best-speed and 9 means best-compression. Example: * -> compress(9, \"image/tiff\") -> \"https://www.example.org\" The filter also checks the incoming request, if it accepts the supported encodings, explicitly stated in the Accept-Encoding header. The filter currently supports gzip and deflate . It does not assume that the client accepts any encoding if the Accept-Encoding header is not set. It ignores * in the Accept-Encoding header. When compressing the response, it updates the response header. It deletes the Content-Length value triggering the proxy to always return the response with chunked transfer encoding, sets the Content-Encoding to the selected encoding and sets the Vary: Accept-Encoding header, if missing. The compression happens in a streaming way, using only a small internal buffer. setQuery Set the query string ?k=v in the request to the backend to a given value. Parameters: key (string) value (string) Example: setQuery(\"k\", \"v\") dropQuery Delete the query string ?k=v in the request to the backend for a given key. Parameters: key (string) Example: dropQuery(\"k\") inlineContent Returns arbitrary content in the HTTP body. Parameters: arbitrary (string) Example: * -> inlineContent(\"<h1>Hello</h1>\") -> <shunt> flowId Sets an X-Flow-Id header, if it's not already in the request. This allows you to have a trace in your logs, that traces from the incoming request on the edge to all backend services. Paramters: no parameter: resets always the X-Flow-Id header to a new value \"reuse\": only create X-Flow-Id header if not set in the request Example: * -> flowId() -> \"https://some-backend.example.org\"; * -> flowId(\"reuse\") -> \"https://some-backend.example.org\"; randomContent Generate response with random text of specified length. Parameters: length of data (int) Example: * -> randomContent(42) -> <shunt>; latency Enable adding artificial latency Parameters: latency in milliseconds (int) Example: * -> latency(120) -> \"https://www.example.org\"; bandwidth Enable bandwidth throttling. Parameters: bandwidth in kb/s (int) Example: * -> bandwidth(30) -> \"https://www.example.org\"; chunks Enables adding chunking responses with custom chunk size with artificial delays in between response chunks. To disable delays, set the second parameter to \"0\". Parameters: byte length (int) time duration (time.Duration) Example: * -> chunks(1024, \"120ms\") -> \"https://www.example.org\"; * -> chunks(1024, \"0\") -> \"https://www.example.org\"; backendLatency Same as latency filter , but on the request path and not on the response path. backendBandwidth Same as bandwidth filter , but on the request path and not on the response path. backendChunks Same as chunks filter , but on the request path and not on the response path. tee Provides a unix-like tee feature for routing. Using this filter, the request will be sent to a \"shadow\" backend in addition to the main backend of the route. Example: * -> tee(\"https://audit-logging.example.org\") -> \"https://foo.example.org\"; This will send an identical request for foo.example.org to audit-logging.example.org. Another use case could be using it for benchmarking a new backend with some real traffic. This we call \"shadow traffic\". The above route will forward the request to https://foo.example.org as it normally would do, but in addition to that, it will send an identical request to https://audit-logging.example.org . The request sent to https://audit-logging.example.org will receive the same method and headers, and a copy of the body stream. The tee response is ignored for this shadow backend. It is possible to change the path of the tee request, in a similar way to the modPath filter: Path(\"/api/v1\") -> tee(\"https://api.example.org\", \"^/v1\", \"/v2\" ) -> \"http://api.example.org\"; In the above example, one can test how a new version of an API would behave on incoming requests. teenf The same as tee filter , but does not follow redirects from the backend. basicAuth Enable Basic Authentication The filter accepts two parameters, the first mandatory one is the path to the htpasswd file usually used with Apache or nginx. The second one is the optional realm name that will be displayed in the browser. MD5, SHA1 and BCrypt are supported for Basic authentication password storage, see also the http-auth module page . Examples: basicAuth(\"/path/to/htpasswd\") basicAuth(\"/path/to/htpasswd\", \"My Website\") webhook The webhook filter makes it possible to have your own authentication and authorization endpoint as a filter. Headers from the incoming request will be copied into the request that is being done to the webhook endpoint. Responses from the webhook with status code less than 300 will be authorized, rest unauthorized. Examples: webhook(\"https://custom-webhook.example.org/auth\") The webhook timeout has a default of 2 seconds and can be globally changed, if skipper is started with -webhook-timeout=2s flag. oauthTokeninfoAnyScope If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. If any of the configured scopes from the filter is found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAnyScope(\"s1\", \"s2\", \"s3\") oauthTokeninfoAllScope If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. If all of the configured scopes from the filter are found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAllScope(\"s1\", \"s2\", \"s3\") oauthTokeninfoAnyKV If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. If any of the configured key value pairs from the filter is found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAnyKV(\"k1\", \"v1\", \"k2\", \"v2\") oauthTokeninfoAllKV If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. If all of the configured key value pairs from the filter are found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAllKV(\"k1\", \"v1\", \"k2\", \"v2\") oauthTokenintrospectionAnyClaims The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If one of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAnyClaims(\"c1\", \"c2\", \"c3\") oauthTokenintrospectionAllClaims The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If all of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAllClaims(\"c1\", \"c2\", \"c3\") oauthTokenintrospectionAnyKV The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If one of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAnyKV(\"k1\", \"v1\", \"k2\", \"v2\") oauthTokenintrospectionAllKV The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If all of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAllKV(\"k1\", \"v1\", \"k2\", \"v2\") requestCookie Append a cookie to the request header. Parameters: cookie name (string) cookie value (string) Example: requestCookie(\"test-session\", \"abc\") responseCookie Appends cookies to responses in the \"Set-Cookie\" header. The response cookie accepts an optional argument to control the max-age property of the cookie, of type int , in seconds. The response cookie accepts an optional fourth argument, \"change-only\", to control if the cookie should be set on every response, or only if the request does not contain a cookie with the provided name and value. Example: responseCookie(\"test-session\", \"abc\") responseCookie(\"test-session\", \"abc\", 31536000), responseCookie(\"test-session\", \"abc\", 31536000, \"change-only\") jsCookie The JS cookie behaves exactly as the response cookie, but it does not set the HttpOnly directive, so these cookies will be accessible from JS code running in web browsers. Example: jsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\") consecutiveBreaker This breaker opens when the proxy could not connect to a backend or received a >=500 status code at least N times in a row. When open, the proxy returns 503 - Service Unavailable response during the breaker timeout. After this timeout, the breaker goes into half-open state, in which it expects that M number of requests succeed. The requests in the half-open state are accepted concurrently. If any of the requests during the half-open state fails, the breaker goes back to open state. If all succeed, it goes to closed state again. Parameters: number of consecutive failures to open (int) timeout (time string, parseable by time.Duration ) - optional half-open requests (int) - optional idle-ttl (time string, parseable by time.Duration ) - optional See also the circuit breaker docs . rateBreaker The \"rate breaker\" works similar to the consecutiveBreaker , but instead of considering N consecutive failures for going open, it maintains a sliding window of the last M events, both successes and failures, and opens only when the number of failures reaches N within the window. This way the sliding window is not time based and allows the same breaker characteristics for low and high rate traffic. Parameters: number of consecutive failures to open (int) sliding window (time string, parseable by time.Duration ) half-open requests (int) - optional idle-ttl (time string, parseable by time.Duration ) - optional See also the circuit breaker docs . disableBreaker Change (or set) the breaker configurations for an individual route and disable for another, in eskip: updates: Method(\"POST\") && Host(\"foo.example.org\") -> consecutiveBreaker(9) -> \"https://foo.backend.net\"; backendHealthcheck: Path(\"/healthcheck\") -> disableBreaker() -> \"https://foo.backend.net\"; See also the circuit breaker docs . localRatelimit Per skipper instance calculated ratelimit, that allows number of requests by client. The definition of the same client is based on data of the http header and can be changed with an optional third parameter. If the third parameter is set skipper will use the Authorization header to put the request in the same client bucket, else the X-Forwarded-For Header will be used. Parameters: number of allowed requests per time period (int) time period for requests being counted (time.Duration) optional parameter can be set to: \"auth\" (string) localRatelimit(3, \"1m\") localRatelimit(3, \"1m\", \"auth\") See also the ratelimit docs . ratelimit Per skipper instance calculated ratelimit, that allows number of requests to a backend. Parameters: number of allowed requests per time period (int) time period for requests being counted (time.Duration) ratelimit(20, \"1m\") ratelimit(300, \"1h\") See also the ratelimit docs . lua See the scripts page corsOrigin The filter accepts an optional variadic list of acceptable origin parameters. If the input argument list is empty, the header will always be set to * which means any origin is acceptable. Otherwise the header is only set if the request contains an Origin header and its value matches one of the elements in the input list. The header is only set on the response. Parameters: url (variadic string) Examples: corsOrigin() corsOrigin(\"https://www.example.org\") corsOrigin(\"https://www.example.org\", \"http://localhost:9001\") headerToQuery Filter which assigns the value of a given header from the incoming Request to a given query param Parameters: The name of the header to pick from request The name of the query param key to add to request Examples: headerToQuery(\"X-Foo-Header\", \"foo-query-param\") The above filter will set foo-query-param query param respectively to the X-Foo-Header header and will override the value if the queryparam exists already","title":"Filters"},{"location":"filters/#skipper-filters","text":"The parameters can be strings, regex or float64 / int string is a string surrounded by double quotes ( \" ) regex is a regular expression, surrounded by / , e.g. /^www\\.example\\.org(:\\d+)?$/ int / float64 are usual (decimal) numbers like 401 or 1.23456 time is a string in double quotes, parseable by time.Duration ) Filters are a generic tool and can change HTTP header and body in the request and response path. Filter can be chained using the arrow operator -> . Example route with a match all, 2 filters and a backend: all: * -> filter1 -> filter2 -> \"http://127.0.0.1:1234/\";","title":"Skipper Filters"},{"location":"filters/#setrequestheader","text":"Set headers for requests. Parameters: header name (string) header value (string) Example: foo: * -> setRequestHeader(\"X-Passed-Skipper\", \"true\") -> \"https://backend.example.org\";","title":"setRequestHeader"},{"location":"filters/#setresponseheader","text":"Same as setRequestHeader , only for responses","title":"setResponseHeader"},{"location":"filters/#appendrequestheader","text":"Same as setRequestHeader , does not remove a possibly existing value, but adds a new header value","title":"appendRequestHeader"},{"location":"filters/#appendresponseheader","text":"Same as appendRequestHeader , only for responses","title":"appendResponseHeader"},{"location":"filters/#droprequestheader","text":"Removes a header from the request Parameters: * header name (string) Example: foo: * -> dropRequestHeader(\"User-Agent\") -> \"https://backend.example.org\";","title":"dropRequestHeader"},{"location":"filters/#dropresponseheader","text":"Same as dropRequestHeader but for responses from the backend","title":"dropResponseHeader"},{"location":"filters/#modpath","text":"Replace all matched regex expressions in the path. Parameters: the expression to match (regex) the replacement (string)","title":"modPath"},{"location":"filters/#setpath","text":"Replace the path of the original request to the replacement. Parameters: * the replacement (string)","title":"setPath"},{"location":"filters/#redirectto","text":"Creates an HTTP redirect response. Parameters: redirect status code (int) location (string) Example: redir: PathRegex(/^\\/foo\\/bar/) -> redirectTo(302, \"/foo/newBar\") -> <shunt>;","title":"redirectTo"},{"location":"filters/#redirecttolower","text":"Same as redirectTo , but replaces all strings to lower case.","title":"redirectToLower"},{"location":"filters/#static","text":"Serves static content from the filesystem. Parameters: Request path to strip (string) Target base path in the filesystem (string) Example: This serves files from /srv/www/dehydrated when requested via /.well-known/acme-challenge/ , e.g. the request GET /.well-known/acme-challenge/foo will serve the file /srv/www/dehydrated/foo . acme: Host(/./) && Method(\"GET\") && Path(\"/.well-known/acme-challenge/*\") -> static(\"/.well-known/acme-challenge/\", \"/srv/www/dehydrated\") -> <shunt>; Notes: redirects to the directory when a file index.html exists and it is requested, i.e. GET /foo/index.html redirects to /foo/ which serves then the /foo/index.html serves the content of the index.html when a directory is requested does a simple directory listing of files / directories when no index.html is present","title":"static"},{"location":"filters/#stripquery","text":"","title":"stripQuery"},{"location":"filters/#preservehost","text":"Sets the incoming Host: header on the outgoing backend connection. It can be used to override the proxyPreserveHost behavior for individual routes. Parameters: \"true\" or \"false\" \"true\" - use the Host header from the incoming request \"false\" - use the host from the backend address Example: route1: * -> preserveHost(\"true\") -> \"http://backend.example.org\";","title":"preserveHost"},{"location":"filters/#status","text":"Sets the response status code to the given value, with no regards to the backend response. Parameters: status code (int) Example: route1: Host(/^all401\\.example\\.org$/) -> status(401) -> <shunt>;","title":"status"},{"location":"filters/#compress","text":"The filter, when executed on the response path, checks if the response entity can be compressed. To decide, it checks the Content-Encoding, the Cache-Control and the Content-Type headers. It doesn't compress the content if the Content-Encoding is set to other than identity, or the Cache-Control applies the no-transform pragma, or the Content-Type is set to an unsupported value. The default supported content types are: text/plain , text/html , application/json , application/javascript , application/x-javascript , text/javascript , text/css , image/svg+xml , application/octet-stream . The default set of MIME types can be reset or extended by passing in the desired types as filter arguments. When extending the defaults, the first argument needs to be \"...\" . E.g. to compress tiff in addition to the defaults: * -> compress(\"...\", \"image/tiff\") -> \"https://www.example.org\" To reset the supported types, e.g. to compress only HTML, the \"...\" argument needs to be omitted: * -> compress(\"text/html\") -> \"https://www.example.org\" It is possible to control the compression level, by setting it as the first filter argument, in front of the MIME types. The default compression level is best-speed. The possible values are integers between 0 and 9 (inclusive), where 0 means no-compression, 1 means best-speed and 9 means best-compression. Example: * -> compress(9, \"image/tiff\") -> \"https://www.example.org\" The filter also checks the incoming request, if it accepts the supported encodings, explicitly stated in the Accept-Encoding header. The filter currently supports gzip and deflate . It does not assume that the client accepts any encoding if the Accept-Encoding header is not set. It ignores * in the Accept-Encoding header. When compressing the response, it updates the response header. It deletes the Content-Length value triggering the proxy to always return the response with chunked transfer encoding, sets the Content-Encoding to the selected encoding and sets the Vary: Accept-Encoding header, if missing. The compression happens in a streaming way, using only a small internal buffer.","title":"compress"},{"location":"filters/#setquery","text":"Set the query string ?k=v in the request to the backend to a given value. Parameters: key (string) value (string) Example: setQuery(\"k\", \"v\")","title":"setQuery"},{"location":"filters/#dropquery","text":"Delete the query string ?k=v in the request to the backend for a given key. Parameters: key (string) Example: dropQuery(\"k\")","title":"dropQuery"},{"location":"filters/#inlinecontent","text":"Returns arbitrary content in the HTTP body. Parameters: arbitrary (string) Example: * -> inlineContent(\"<h1>Hello</h1>\") -> <shunt>","title":"inlineContent"},{"location":"filters/#flowid","text":"Sets an X-Flow-Id header, if it's not already in the request. This allows you to have a trace in your logs, that traces from the incoming request on the edge to all backend services. Paramters: no parameter: resets always the X-Flow-Id header to a new value \"reuse\": only create X-Flow-Id header if not set in the request Example: * -> flowId() -> \"https://some-backend.example.org\"; * -> flowId(\"reuse\") -> \"https://some-backend.example.org\";","title":"flowId"},{"location":"filters/#randomcontent","text":"Generate response with random text of specified length. Parameters: length of data (int) Example: * -> randomContent(42) -> <shunt>;","title":"randomContent"},{"location":"filters/#latency","text":"Enable adding artificial latency Parameters: latency in milliseconds (int) Example: * -> latency(120) -> \"https://www.example.org\";","title":"latency"},{"location":"filters/#bandwidth","text":"Enable bandwidth throttling. Parameters: bandwidth in kb/s (int) Example: * -> bandwidth(30) -> \"https://www.example.org\";","title":"bandwidth"},{"location":"filters/#chunks","text":"Enables adding chunking responses with custom chunk size with artificial delays in between response chunks. To disable delays, set the second parameter to \"0\". Parameters: byte length (int) time duration (time.Duration) Example: * -> chunks(1024, \"120ms\") -> \"https://www.example.org\"; * -> chunks(1024, \"0\") -> \"https://www.example.org\";","title":"chunks"},{"location":"filters/#backendlatency","text":"Same as latency filter , but on the request path and not on the response path.","title":"backendLatency"},{"location":"filters/#backendbandwidth","text":"Same as bandwidth filter , but on the request path and not on the response path.","title":"backendBandwidth"},{"location":"filters/#backendchunks","text":"Same as chunks filter , but on the request path and not on the response path.","title":"backendChunks"},{"location":"filters/#tee","text":"Provides a unix-like tee feature for routing. Using this filter, the request will be sent to a \"shadow\" backend in addition to the main backend of the route. Example: * -> tee(\"https://audit-logging.example.org\") -> \"https://foo.example.org\"; This will send an identical request for foo.example.org to audit-logging.example.org. Another use case could be using it for benchmarking a new backend with some real traffic. This we call \"shadow traffic\". The above route will forward the request to https://foo.example.org as it normally would do, but in addition to that, it will send an identical request to https://audit-logging.example.org . The request sent to https://audit-logging.example.org will receive the same method and headers, and a copy of the body stream. The tee response is ignored for this shadow backend. It is possible to change the path of the tee request, in a similar way to the modPath filter: Path(\"/api/v1\") -> tee(\"https://api.example.org\", \"^/v1\", \"/v2\" ) -> \"http://api.example.org\"; In the above example, one can test how a new version of an API would behave on incoming requests.","title":"tee"},{"location":"filters/#teenf","text":"The same as tee filter , but does not follow redirects from the backend.","title":"teenf"},{"location":"filters/#basicauth","text":"Enable Basic Authentication The filter accepts two parameters, the first mandatory one is the path to the htpasswd file usually used with Apache or nginx. The second one is the optional realm name that will be displayed in the browser. MD5, SHA1 and BCrypt are supported for Basic authentication password storage, see also the http-auth module page . Examples: basicAuth(\"/path/to/htpasswd\") basicAuth(\"/path/to/htpasswd\", \"My Website\")","title":"basicAuth"},{"location":"filters/#webhook","text":"The webhook filter makes it possible to have your own authentication and authorization endpoint as a filter. Headers from the incoming request will be copied into the request that is being done to the webhook endpoint. Responses from the webhook with status code less than 300 will be authorized, rest unauthorized. Examples: webhook(\"https://custom-webhook.example.org/auth\") The webhook timeout has a default of 2 seconds and can be globally changed, if skipper is started with -webhook-timeout=2s flag.","title":"webhook"},{"location":"filters/#oauthtokeninfoanyscope","text":"If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. If any of the configured scopes from the filter is found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAnyScope(\"s1\", \"s2\", \"s3\")","title":"oauthTokeninfoAnyScope"},{"location":"filters/#oauthtokeninfoallscope","text":"If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. If all of the configured scopes from the filter are found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAllScope(\"s1\", \"s2\", \"s3\")","title":"oauthTokeninfoAllScope"},{"location":"filters/#oauthtokeninfoanykv","text":"If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. If any of the configured key value pairs from the filter is found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAnyKV(\"k1\", \"v1\", \"k2\", \"v2\")","title":"oauthTokeninfoAnyKV"},{"location":"filters/#oauthtokeninfoallkv","text":"If skipper is started with -oauth2-tokeninfo-url flag, you can use this filter. The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. If all of the configured key value pairs from the filter are found inside the tokeninfo result for the incoming token, it will allow the request to pass. Examples: oauthTokeninfoAllKV(\"k1\", \"v1\", \"k2\", \"v2\")","title":"oauthTokeninfoAllKV"},{"location":"filters/#oauthtokenintrospectionanyclaims","text":"The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If one of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAnyClaims(\"c1\", \"c2\", \"c3\")","title":"oauthTokenintrospectionAnyClaims"},{"location":"filters/#oauthtokenintrospectionallclaims","text":"The filter accepts variable number of string arguments, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If all of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAllClaims(\"c1\", \"c2\", \"c3\")","title":"oauthTokenintrospectionAllClaims"},{"location":"filters/#oauthtokenintrospectionanykv","text":"The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If one of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAnyKV(\"k1\", \"v1\", \"k2\", \"v2\")","title":"oauthTokenintrospectionAnyKV"},{"location":"filters/#oauthtokenintrospectionallkv","text":"The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the Authorization: Bearer <token> header. The first argument to the filter is the issuer URL, for example https://accounts.google.com , that will be used as described in RFC Draft to find the configuration and for example supported claims. If all of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass. Examples: oauthTokenintrospectionAllKV(\"k1\", \"v1\", \"k2\", \"v2\")","title":"oauthTokenintrospectionAllKV"},{"location":"filters/#requestcookie","text":"Append a cookie to the request header. Parameters: cookie name (string) cookie value (string) Example: requestCookie(\"test-session\", \"abc\")","title":"requestCookie"},{"location":"filters/#responsecookie","text":"Appends cookies to responses in the \"Set-Cookie\" header. The response cookie accepts an optional argument to control the max-age property of the cookie, of type int , in seconds. The response cookie accepts an optional fourth argument, \"change-only\", to control if the cookie should be set on every response, or only if the request does not contain a cookie with the provided name and value. Example: responseCookie(\"test-session\", \"abc\") responseCookie(\"test-session\", \"abc\", 31536000), responseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")","title":"responseCookie"},{"location":"filters/#jscookie","text":"The JS cookie behaves exactly as the response cookie, but it does not set the HttpOnly directive, so these cookies will be accessible from JS code running in web browsers. Example: jsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")","title":"jsCookie"},{"location":"filters/#consecutivebreaker","text":"This breaker opens when the proxy could not connect to a backend or received a >=500 status code at least N times in a row. When open, the proxy returns 503 - Service Unavailable response during the breaker timeout. After this timeout, the breaker goes into half-open state, in which it expects that M number of requests succeed. The requests in the half-open state are accepted concurrently. If any of the requests during the half-open state fails, the breaker goes back to open state. If all succeed, it goes to closed state again. Parameters: number of consecutive failures to open (int) timeout (time string, parseable by time.Duration ) - optional half-open requests (int) - optional idle-ttl (time string, parseable by time.Duration ) - optional See also the circuit breaker docs .","title":"consecutiveBreaker"},{"location":"filters/#ratebreaker","text":"The \"rate breaker\" works similar to the consecutiveBreaker , but instead of considering N consecutive failures for going open, it maintains a sliding window of the last M events, both successes and failures, and opens only when the number of failures reaches N within the window. This way the sliding window is not time based and allows the same breaker characteristics for low and high rate traffic. Parameters: number of consecutive failures to open (int) sliding window (time string, parseable by time.Duration ) half-open requests (int) - optional idle-ttl (time string, parseable by time.Duration ) - optional See also the circuit breaker docs .","title":"rateBreaker"},{"location":"filters/#disablebreaker","text":"Change (or set) the breaker configurations for an individual route and disable for another, in eskip: updates: Method(\"POST\") && Host(\"foo.example.org\") -> consecutiveBreaker(9) -> \"https://foo.backend.net\"; backendHealthcheck: Path(\"/healthcheck\") -> disableBreaker() -> \"https://foo.backend.net\"; See also the circuit breaker docs .","title":"disableBreaker"},{"location":"filters/#localratelimit","text":"Per skipper instance calculated ratelimit, that allows number of requests by client. The definition of the same client is based on data of the http header and can be changed with an optional third parameter. If the third parameter is set skipper will use the Authorization header to put the request in the same client bucket, else the X-Forwarded-For Header will be used. Parameters: number of allowed requests per time period (int) time period for requests being counted (time.Duration) optional parameter can be set to: \"auth\" (string) localRatelimit(3, \"1m\") localRatelimit(3, \"1m\", \"auth\") See also the ratelimit docs .","title":"localRatelimit"},{"location":"filters/#ratelimit","text":"Per skipper instance calculated ratelimit, that allows number of requests to a backend. Parameters: number of allowed requests per time period (int) time period for requests being counted (time.Duration) ratelimit(20, \"1m\") ratelimit(300, \"1h\") See also the ratelimit docs .","title":"ratelimit"},{"location":"filters/#lua","text":"See the scripts page","title":"lua"},{"location":"filters/#corsorigin","text":"The filter accepts an optional variadic list of acceptable origin parameters. If the input argument list is empty, the header will always be set to * which means any origin is acceptable. Otherwise the header is only set if the request contains an Origin header and its value matches one of the elements in the input list. The header is only set on the response. Parameters: url (variadic string) Examples: corsOrigin() corsOrigin(\"https://www.example.org\") corsOrigin(\"https://www.example.org\", \"http://localhost:9001\")","title":"corsOrigin"},{"location":"filters/#headertoquery","text":"Filter which assigns the value of a given header from the incoming Request to a given query param Parameters: The name of the header to pick from request The name of the query param key to add to request Examples: headerToQuery(\"X-Foo-Header\", \"foo-query-param\") The above filter will set foo-query-param query param respectively to the X-Foo-Header header and will override the value if the queryparam exists already","title":"headerToQuery"},{"location":"operations/","text":"Operations This is the work in progress operations guide for showing information, which are relevant for production use. Skipper is proven to scale with number of routes beyond 200.000 routes per instance. Skipper is running with peaks to 45.000 http requests per second using multiple instances. Connection Options Skipper's connection options are allowing you to set Go's http.Server Options on the client side and http.Transport on the backend side. \"It is recommended to read this blog post about net http timeouts in order to better understand the impact of these settings. Backend Backend is the side skipper opens a client connection to. Closing idle connections is required for DNS failover, because Go's http.Transport caches DNS lookups and needs to create new connections for doing so. Skipper will start a goroutine and use the specified time.Duration to call CloseIdleConnections() on that http.Transport . -close-idle-conns-period string period of closing all idle connections in seconds or as a duration string. Not closing when less than 0 (default \"20\") This will set MaxIdleConnsPerHost on the http.Transport to limit the number of idle connections per backend such that we do not run out of sockets. -idle-conns-num int maximum idle connections per backend host (default 64) This will set MaxIdleConns on the http.Transport to limit the number for all backends such that we do not run out of sockets. -max-idle-connection-backend int sets the maximum idle connections for all backend connections This will set TLSHandshakeTimeout on the http.Transport to have timeouts based on TLS connections. -tls-timeout-backend duration sets the TLS handshake timeout for backend connections (default 1m0s) This will set Timeout on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport . -timeout-backend duration sets the TCP client connection timeout for backend connections (default 1m0s) This will set KeepAlive on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport . -keepalive-backend duration sets the keepalive for backend connections (default 30s) This will set DualStack (IPv4 and IPv6) on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport . -enable-dualstack-backend enables DualStack for backend connections (default true) Client Client is the side skipper gets incoming calls from. Here we can set timeouts in different parts of the http connection. This will set ReadTimeout in http.Server handling incoming calls from your clients. -read-timeout-server duration set ReadTimeout for http server connections (default 5m0s) This will set ReadHeaderTimeout in http.Server handling incoming calls from your clients. -read-header-timeout-server duration set ReadHeaderTimeout for http server connections (default 1m0s) This will set WriteTimeout in http.Server handling incoming calls from your clients. -write-timeout-server duration set WriteTimeout for http server connections (default 1m0s) This will set IdleTimeout in http.Server handling incoming calls from your clients. -idle-timeout-server duration maximum idle connections per backend host (default 1m0s) This will set MaxHeaderBytes in http.Server to limit the size of the http header from your clients. -max-header-bytes int set MaxHeaderBytes for http server connections (default 1048576) OAuth2 Tokeninfo OAuth2 filters integrate with external services and have their own connection handling. Outgoing calls to these services have a default timeout of 2s, which can be changed by the flag -oauth2-tokeninfo-timeout=<OAuthTokeninfoTimeout> . OAuth2 Tokenintrospection RFC7662 OAuth2 filters integrate with external services and have their own connection handling. Outgoing calls to these services have a default timeout of 2s, which can be changed by the flag -oauth2-tokenintrospect-timeout=<OAuthTokenintrospectionTimeout> . Monitoring Monitoring is one of the most important things you need to run in production and skipper has a godoc page for the metrics package , describing options and most keys you will find in the metrics handler endpoint. The default is listening on :9911/metrics . You can modify the listen port with the -support-listener flag. Prometheus In case you want to get metrics in Prometheus format exposed, use this option to enable it: -enable-prometheus-metrics It will return Prometheus metrics on the common metrics endpoint :9911/metrics. Connection metrics This option will enable known loadbalancer connections metrics, like counters for active and new connections. This feature sets a metrics callback on http.Server and uses a counter to collect http.ConnState . -enable-connection-metrics enables connection metrics for http server connections It will expose them in /metrics, for example json structure looks like this example: { \"counters\": { \"skipper.lb-conn-active\": { \"count\": 6 }, \"skipper.lb-conn-closed\": { \"count\": 6 }, \"skipper.lb-conn-idle\": { \"count\": 6 }, \"skipper.lb-conn-new\": { \"count\": 6 } }, /* stripped a lot of metrics here */ } Application metrics Application metrics for your proxied applications you can enable with the option: -serve-host-metrics enables reporting total serve time metrics for each host This will make sure you will get stats for each \"Host\" header as \"timers\": \"timers\": { \"skipper.servehost.app1_example_com.GET.200\": { \"15m.rate\": 0.06830666203045982, \"1m.rate\": 2.162612637718806e-06, \"5m.rate\": 0.008312609284452856, \"75%\": 236603815, \"95%\": 236603815, \"99%\": 236603815, \"99.9%\": 236603815, \"count\": 3, \"max\": 236603815, \"mean\": 116515451.66666667, \"mean.rate\": 0.0030589345776699827, \"median\": 91273391, \"min\": 21669149, \"stddev\": 89543653.71950394 }, \"skipper.servehost.app1_example_com.GET.304\": { \"15m.rate\": 0.3503336738177459, \"1m.rate\": 0.07923086447313292, \"5m.rate\": 0.27019839341602214, \"75%\": 99351895.25, \"95%\": 105381847, \"99%\": 105381847, \"99.9%\": 105381847, \"count\": 4, \"max\": 105381847, \"mean\": 47621612, \"mean.rate\": 0.03087161486272533, \"median\": 41676170.5, \"min\": 1752260, \"stddev\": 46489302.203724876 }, \"skipper.servehost.app1_example_com.GET.401\": { \"15m.rate\": 0.16838468990057648, \"1m.rate\": 0.01572861413072501, \"5m.rate\": 0.1194724817779537, \"75%\": 91094832, \"95%\": 91094832, \"99%\": 91094832, \"99.9%\": 91094832, \"count\": 2, \"max\": 91094832, \"mean\": 58090623, \"mean.rate\": 0.012304914018033056, \"median\": 58090623, \"min\": 25086414, \"stddev\": 33004209 } }, To change the sampling type of how metrics are handled from uniform to exponential decay , you can use the following option, which is better for not so huge utilized applications (less than 100 requests per second): -metrics-exp-decay-sample use exponentially decaying sample in metrics Go metrics Metrics from the go runtime memstats are exposed from skipper to the metrics endpoint, default listener :9911, on path /metrics : \"gauges\": { \"skipper.runtime.MemStats.Alloc\": { \"value\": 3083680 }, \"skipper.runtime.MemStats.BuckHashSys\": { \"value\": 1452675 }, \"skipper.runtime.MemStats.DebugGC\": { \"value\": 0 }, \"skipper.runtime.MemStats.EnableGC\": { \"value\": 1 }, \"skipper.runtime.MemStats.Frees\": { \"value\": 121 }, \"skipper.runtime.MemStats.HeapAlloc\": { \"value\": 3083680 }, \"skipper.runtime.MemStats.HeapIdle\": { \"value\": 778240 }, \"skipper.runtime.MemStats.HeapInuse\": { \"value\": 4988928 }, \"skipper.runtime.MemStats.HeapObjects\": { \"value\": 24005 }, \"skipper.runtime.MemStats.HeapReleased\": { \"value\": 0 }, \"skipper.runtime.MemStats.HeapSys\": { \"value\": 5767168 }, \"skipper.runtime.MemStats.LastGC\": { \"value\": 1516098381155094500 }, \"skipper.runtime.MemStats.Lookups\": { \"value\": 2 }, \"skipper.runtime.MemStats.MCacheInuse\": { \"value\": 6944 }, \"skipper.runtime.MemStats.MCacheSys\": { \"value\": 16384 }, \"skipper.runtime.MemStats.MSpanInuse\": { \"value\": 77368 }, \"skipper.runtime.MemStats.MSpanSys\": { \"value\": 81920 }, \"skipper.runtime.MemStats.Mallocs\": { \"value\": 1459 }, \"skipper.runtime.MemStats.NextGC\": { \"value\": 4194304 }, \"skipper.runtime.MemStats.NumGC\": { \"value\": 0 }, \"skipper.runtime.MemStats.PauseTotalNs\": { \"value\": 683352 }, \"skipper.runtime.MemStats.StackInuse\": { \"value\": 524288 }, \"skipper.runtime.MemStats.StackSys\": { \"value\": 524288 }, \"skipper.runtime.MemStats.Sys\": { \"value\": 9246968 }, \"skipper.runtime.MemStats.TotalAlloc\": { \"value\": 35127624 }, \"skipper.runtime.NumCgoCall\": { \"value\": 0 }, \"skipper.runtime.NumGoroutine\": { \"value\": 11 }, \"skipper.runtime.NumThread\": { \"value\": 9 } }, \"histograms\": { \"skipper.runtime.MemStats.PauseNs\": { \"75%\": 82509.25, \"95%\": 132609, \"99%\": 132609, \"99.9%\": 132609, \"count\": 12, \"max\": 132609, \"mean\": 56946, \"median\": 39302.5, \"min\": 28749, \"stddev\": 31567.015005117817 } } Dataclient Dataclients poll some kind of data source for routes. To change the timeout for calls that polls a dataclient, which could be the Kubernetes API, use the following option: -source-poll-timeout int polling timeout of the routing data sources, in milliseconds (default 3000) Routing table information Skipper allows you to get some runtime insights. You can get the current routing table from skipper with in the eskip file format : % curl localhost:9911/routes * -> \"http://localhost:12345/\" You also can get the number of routes X-Count and the UNIX timestamp of the last route table update X-Timestamp , using a HEAD request: % curl -I localhost:9911/routes HTTP/1.1 200 OK Content-Type: text/plain X-Count: 1 X-Timestamp: 1517777628 Date: Sun, 04 Feb 2018 20:54:31 GMT The number of routes given is limited (1024 routes by default). In order to control this limits, there are two parameters: limit and offset . The limit defines the number of routes to get and offset where to start the list. Thanks to this, it's possible to get the results paginated or getting all of them at the same time. % curl localhost:9911/routes?offset=200&limit=100","title":"Operations"},{"location":"operations/#operations","text":"This is the work in progress operations guide for showing information, which are relevant for production use. Skipper is proven to scale with number of routes beyond 200.000 routes per instance. Skipper is running with peaks to 45.000 http requests per second using multiple instances.","title":"Operations"},{"location":"operations/#connection-options","text":"Skipper's connection options are allowing you to set Go's http.Server Options on the client side and http.Transport on the backend side. \"It is recommended to read this blog post about net http timeouts in order to better understand the impact of these settings.","title":"Connection Options"},{"location":"operations/#backend","text":"Backend is the side skipper opens a client connection to. Closing idle connections is required for DNS failover, because Go's http.Transport caches DNS lookups and needs to create new connections for doing so. Skipper will start a goroutine and use the specified time.Duration to call CloseIdleConnections() on that http.Transport . -close-idle-conns-period string period of closing all idle connections in seconds or as a duration string. Not closing when less than 0 (default \"20\") This will set MaxIdleConnsPerHost on the http.Transport to limit the number of idle connections per backend such that we do not run out of sockets. -idle-conns-num int maximum idle connections per backend host (default 64) This will set MaxIdleConns on the http.Transport to limit the number for all backends such that we do not run out of sockets. -max-idle-connection-backend int sets the maximum idle connections for all backend connections This will set TLSHandshakeTimeout on the http.Transport to have timeouts based on TLS connections. -tls-timeout-backend duration sets the TLS handshake timeout for backend connections (default 1m0s) This will set Timeout on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport . -timeout-backend duration sets the TCP client connection timeout for backend connections (default 1m0s) This will set KeepAlive on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport . -keepalive-backend duration sets the keepalive for backend connections (default 30s) This will set DualStack (IPv4 and IPv6) on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport . -enable-dualstack-backend enables DualStack for backend connections (default true)","title":"Backend"},{"location":"operations/#client","text":"Client is the side skipper gets incoming calls from. Here we can set timeouts in different parts of the http connection. This will set ReadTimeout in http.Server handling incoming calls from your clients. -read-timeout-server duration set ReadTimeout for http server connections (default 5m0s) This will set ReadHeaderTimeout in http.Server handling incoming calls from your clients. -read-header-timeout-server duration set ReadHeaderTimeout for http server connections (default 1m0s) This will set WriteTimeout in http.Server handling incoming calls from your clients. -write-timeout-server duration set WriteTimeout for http server connections (default 1m0s) This will set IdleTimeout in http.Server handling incoming calls from your clients. -idle-timeout-server duration maximum idle connections per backend host (default 1m0s) This will set MaxHeaderBytes in http.Server to limit the size of the http header from your clients. -max-header-bytes int set MaxHeaderBytes for http server connections (default 1048576)","title":"Client"},{"location":"operations/#oauth2-tokeninfo","text":"OAuth2 filters integrate with external services and have their own connection handling. Outgoing calls to these services have a default timeout of 2s, which can be changed by the flag -oauth2-tokeninfo-timeout=<OAuthTokeninfoTimeout> .","title":"OAuth2 Tokeninfo"},{"location":"operations/#oauth2-tokenintrospection-rfc7662","text":"OAuth2 filters integrate with external services and have their own connection handling. Outgoing calls to these services have a default timeout of 2s, which can be changed by the flag -oauth2-tokenintrospect-timeout=<OAuthTokenintrospectionTimeout> .","title":"OAuth2 Tokenintrospection RFC7662"},{"location":"operations/#monitoring","text":"Monitoring is one of the most important things you need to run in production and skipper has a godoc page for the metrics package , describing options and most keys you will find in the metrics handler endpoint. The default is listening on :9911/metrics . You can modify the listen port with the -support-listener flag.","title":"Monitoring"},{"location":"operations/#prometheus","text":"In case you want to get metrics in Prometheus format exposed, use this option to enable it: -enable-prometheus-metrics It will return Prometheus metrics on the common metrics endpoint :9911/metrics.","title":"Prometheus"},{"location":"operations/#connection-metrics","text":"This option will enable known loadbalancer connections metrics, like counters for active and new connections. This feature sets a metrics callback on http.Server and uses a counter to collect http.ConnState . -enable-connection-metrics enables connection metrics for http server connections It will expose them in /metrics, for example json structure looks like this example: { \"counters\": { \"skipper.lb-conn-active\": { \"count\": 6 }, \"skipper.lb-conn-closed\": { \"count\": 6 }, \"skipper.lb-conn-idle\": { \"count\": 6 }, \"skipper.lb-conn-new\": { \"count\": 6 } }, /* stripped a lot of metrics here */ }","title":"Connection metrics"},{"location":"operations/#application-metrics","text":"Application metrics for your proxied applications you can enable with the option: -serve-host-metrics enables reporting total serve time metrics for each host This will make sure you will get stats for each \"Host\" header as \"timers\": \"timers\": { \"skipper.servehost.app1_example_com.GET.200\": { \"15m.rate\": 0.06830666203045982, \"1m.rate\": 2.162612637718806e-06, \"5m.rate\": 0.008312609284452856, \"75%\": 236603815, \"95%\": 236603815, \"99%\": 236603815, \"99.9%\": 236603815, \"count\": 3, \"max\": 236603815, \"mean\": 116515451.66666667, \"mean.rate\": 0.0030589345776699827, \"median\": 91273391, \"min\": 21669149, \"stddev\": 89543653.71950394 }, \"skipper.servehost.app1_example_com.GET.304\": { \"15m.rate\": 0.3503336738177459, \"1m.rate\": 0.07923086447313292, \"5m.rate\": 0.27019839341602214, \"75%\": 99351895.25, \"95%\": 105381847, \"99%\": 105381847, \"99.9%\": 105381847, \"count\": 4, \"max\": 105381847, \"mean\": 47621612, \"mean.rate\": 0.03087161486272533, \"median\": 41676170.5, \"min\": 1752260, \"stddev\": 46489302.203724876 }, \"skipper.servehost.app1_example_com.GET.401\": { \"15m.rate\": 0.16838468990057648, \"1m.rate\": 0.01572861413072501, \"5m.rate\": 0.1194724817779537, \"75%\": 91094832, \"95%\": 91094832, \"99%\": 91094832, \"99.9%\": 91094832, \"count\": 2, \"max\": 91094832, \"mean\": 58090623, \"mean.rate\": 0.012304914018033056, \"median\": 58090623, \"min\": 25086414, \"stddev\": 33004209 } }, To change the sampling type of how metrics are handled from uniform to exponential decay , you can use the following option, which is better for not so huge utilized applications (less than 100 requests per second): -metrics-exp-decay-sample use exponentially decaying sample in metrics","title":"Application metrics"},{"location":"operations/#go-metrics","text":"Metrics from the go runtime memstats are exposed from skipper to the metrics endpoint, default listener :9911, on path /metrics : \"gauges\": { \"skipper.runtime.MemStats.Alloc\": { \"value\": 3083680 }, \"skipper.runtime.MemStats.BuckHashSys\": { \"value\": 1452675 }, \"skipper.runtime.MemStats.DebugGC\": { \"value\": 0 }, \"skipper.runtime.MemStats.EnableGC\": { \"value\": 1 }, \"skipper.runtime.MemStats.Frees\": { \"value\": 121 }, \"skipper.runtime.MemStats.HeapAlloc\": { \"value\": 3083680 }, \"skipper.runtime.MemStats.HeapIdle\": { \"value\": 778240 }, \"skipper.runtime.MemStats.HeapInuse\": { \"value\": 4988928 }, \"skipper.runtime.MemStats.HeapObjects\": { \"value\": 24005 }, \"skipper.runtime.MemStats.HeapReleased\": { \"value\": 0 }, \"skipper.runtime.MemStats.HeapSys\": { \"value\": 5767168 }, \"skipper.runtime.MemStats.LastGC\": { \"value\": 1516098381155094500 }, \"skipper.runtime.MemStats.Lookups\": { \"value\": 2 }, \"skipper.runtime.MemStats.MCacheInuse\": { \"value\": 6944 }, \"skipper.runtime.MemStats.MCacheSys\": { \"value\": 16384 }, \"skipper.runtime.MemStats.MSpanInuse\": { \"value\": 77368 }, \"skipper.runtime.MemStats.MSpanSys\": { \"value\": 81920 }, \"skipper.runtime.MemStats.Mallocs\": { \"value\": 1459 }, \"skipper.runtime.MemStats.NextGC\": { \"value\": 4194304 }, \"skipper.runtime.MemStats.NumGC\": { \"value\": 0 }, \"skipper.runtime.MemStats.PauseTotalNs\": { \"value\": 683352 }, \"skipper.runtime.MemStats.StackInuse\": { \"value\": 524288 }, \"skipper.runtime.MemStats.StackSys\": { \"value\": 524288 }, \"skipper.runtime.MemStats.Sys\": { \"value\": 9246968 }, \"skipper.runtime.MemStats.TotalAlloc\": { \"value\": 35127624 }, \"skipper.runtime.NumCgoCall\": { \"value\": 0 }, \"skipper.runtime.NumGoroutine\": { \"value\": 11 }, \"skipper.runtime.NumThread\": { \"value\": 9 } }, \"histograms\": { \"skipper.runtime.MemStats.PauseNs\": { \"75%\": 82509.25, \"95%\": 132609, \"99%\": 132609, \"99.9%\": 132609, \"count\": 12, \"max\": 132609, \"mean\": 56946, \"median\": 39302.5, \"min\": 28749, \"stddev\": 31567.015005117817 } }","title":"Go metrics"},{"location":"operations/#dataclient","text":"Dataclients poll some kind of data source for routes. To change the timeout for calls that polls a dataclient, which could be the Kubernetes API, use the following option: -source-poll-timeout int polling timeout of the routing data sources, in milliseconds (default 3000)","title":"Dataclient"},{"location":"operations/#routing-table-information","text":"Skipper allows you to get some runtime insights. You can get the current routing table from skipper with in the eskip file format : % curl localhost:9911/routes * -> \"http://localhost:12345/\" You also can get the number of routes X-Count and the UNIX timestamp of the last route table update X-Timestamp , using a HEAD request: % curl -I localhost:9911/routes HTTP/1.1 200 OK Content-Type: text/plain X-Count: 1 X-Timestamp: 1517777628 Date: Sun, 04 Feb 2018 20:54:31 GMT The number of routes given is limited (1024 routes by default). In order to control this limits, there are two parameters: limit and offset . The limit defines the number of routes to get and offset where to start the list. Thanks to this, it's possible to get the results paginated or getting all of them at the same time. % curl localhost:9911/routes?offset=200&limit=100","title":"Routing table information"},{"location":"plugins/","text":"Skipper plugins Skipper may be extended with functionality not present in the core. These additions can be built as go plugin, so they do not have to be present in the main skipper repository. Note the warning from Go's plugin.go: // The plugin support is currently incomplete, only supports Linux, // and has known bugs. Please report any issues. Note the known problem of using plugins together with vendoring, best described here: https://github.com/golang/go/issues/20481 Plugin directories Plugins are loaded from sub directories of the plugin directories. By default the plugin directory is set to ./plugins (i.e. relative to skipper's working directory). An additional directory may be given with the -plugindir=/path/to/dir option to skipper. Any file with the suffix .so found below the plugin directories (also in sub directories) is attempted to load without any arguments. When a plugin needs an argument, this must be explicitly loaded and the arguments passed, e.g. with -filter-plugin geoip,db=/path/to/db . Building a plugin Each plugin should be built with go build -buildmode=plugin -o example.so example.go There are some pitfalls: packages which are shared between skipper and the plugin must not be in a vendor/ directory, otherwise the plugin will fail to load or in some cases give wrong results (e.g. an opentracing span cannot be found in the context even if it is present). This also means: Do not vendor skipper in a plugin repo... plugins must be rebuilt when skipper is rebuilt do not attempt to rebuild a module and copy it over a loaded plugin, that will crash skipper immediately... Filter plugins All plugins must have a function named InitFilter with the following signature func([]string) (filters.Spec, error) The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper's -filter-plugin parameter. E.g. when the -filter-plugin parameter is myfilter,datafile=/path/to/file,foo=bar the myfilter plugin will receive []string{\"datafile=/path/to/file\", \"foo=bar\"} as arguments. The filter plugin implementation is responsible to parse the received arguments. Filter plugins can be found in the filter repo Example filter plugin An example noop plugin looks like package main import ( \"github.com/zalando/skipper/filters\" ) type noopSpec struct{} func InitFilter(opts []string) (filters.Spec, error) { return noopSpec{}, nil } func (s noopSpec) Name() string { return \"noop\" } func (s noopSpec) CreateFilter(config []interface{}) (filters.Filter, error) { return noopFilter{}, nil } type noopFilter struct{} func (f noopFilter) Request(filters.FilterContext) {} func (f noopFilter) Response(filters.FilterContext) {} Predicate plugins All plugins must have a function named InitPredicate with the following signature func([]string) (routing.PredicateSpec, error) The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper's -predicate-plugin parameter. E.g. when the -predicate-plugin parameter is mypred,datafile=/path/to/file,foo=bar the mypred plugin will receive []string{\"datafile=/path/to/file\", \"foo=bar\"} as arguments. The predicate plugin implementation is responsible to parse the received arguments. Predicate plugins can be found in the predicate repo Example predicate plugin An example MatchAll plugin looks like package main import ( \"github.com/zalando/skipper/routing\" \"net/http\" ) type noopSpec struct{} func InitPredicate(opts []string) (routing.PredicateSpec, error) { return noopSpec{}, nil } func (s noopSpec) Name() string { return \"MatchAll\" } func (s noopSpec) Create(config []interface{}) (routing.Predicate, error) { return noopPredicate{}, nil } type noopPredicate struct{} func (p noopPredicate) Match(*http.Request) bool { return true } DataClient plugins Similar to the above predicate and filter plugins. The command line option for data client plugins is -dataclient-plugin . The module must have a InitDataClient function with the signature func([]string) (routing.DataClient, error) A noop data client looks like package main import ( \"github.com/zalando/skipper/eskip\" \"github.com/zalando/skipper/routing\" ) func InitDataClient([]string) (routing.DataClient, error) { var dc DataClient = \"\" return dc, nil } type DataClient string func (dc DataClient) LoadAll() ([]*eskip.Route, error) { return eskip.Parse(string(dc)) } func (dc DataClient) LoadUpdate() ([]*eskip.Route, []string, error) { return nil, nil, nil } MultiType plugins Sometimes it is necessary to combine multiple plugin types into one module. This can be done with this kind of plugin. Note that these modules are not auto loaded, these need an explicit -multi-plugin name,arg1,arg2 command line switch for skipper. The module must have a InitPlugin function with the signature func([]string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error) Any of the returned types may be nil, so you can have e.g. a combined filter / data client plugin or share a filter and a predicate, e.g. like package main import ( \"fmt\" \"net\" \"net/http\" \"strconv\" \"strings\" ot \"github.com/opentracing/opentracing-go\" maxminddb \"github.com/oschwald/maxminddb-golang\" \"github.com/zalando/skipper/filters\" snet \"github.com/zalando/skipper/net\" \"github.com/zalando/skipper/predicates\" \"github.com/zalando/skipper/routing\" ) type geoipSpec struct { db *maxminddb.Reader name string } func InitPlugin(opts []string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error) { var db string for _, o := range opts { switch { case strings.HasPrefix(o, \"db=\"): db = o[3:] } } if db == \"\" { return nil, nil, nil, fmt.Errorf(\"missing db= parameter for geoip plugin\") } reader, err := maxminddb.Open(db) if err != nil { return nil, nil, nil, fmt.Errorf(\"failed to open db %s: %s\", db, err) } return []filters.Spec{&geoipSpec{db: reader, name: \"geoip\"}}, []routing.PredicateSpec{&geoipSpec{db: reader, name: \"GeoIP\"}}, nil, nil } func (s *geoipSpec) Name() string { return s.name } func (s *geoipSpec) CreateFilter(config []interface{}) (filters.Filter, error) { var fromLast bool header := \"X-GeoIP-Country\" var err error for _, c := range config { if s, ok := c.(string); ok { switch { case strings.HasPrefix(s, \"from_last=\"): fromLast, err = strconv.ParseBool(s[10:]) if err != nil { return nil, filters.ErrInvalidFilterParameters } case strings.HasPrefix(s, \"header=\"): header = s[7:] } } } return &geoip{db: s.db, fromLast: fromLast, header: header}, nil } func (s *geoipSpec) Create(config []interface{}) (routing.Predicate, error) { var fromLast bool var err error countries := make(map[string]struct{}) for _, c := range config { if s, ok := c.(string); ok { switch { case strings.HasPrefix(s, \"from_last=\"): fromLast, err = strconv.ParseBool(s[10:]) if err != nil { return nil, predicates.ErrInvalidPredicateParameters } default: countries[strings.ToUpper(s)] = struct{}{} } } } return &geoip{db: s.db, fromLast: fromLast, countries: countries}, nil } type geoip struct { db *maxminddb.Reader fromLast bool header string countries map[string]struct{} } type countryRecord struct { Country struct { ISOCode string `maxminddb:\"iso_code\"` } `maxminddb:\"country\"` } func (g *geoip) lookup(r *http.Request) string { var src net.IP if g.fromLast { src = snet.RemoteHostFromLast(r) } else { src = snet.RemoteHost(r) } record := countryRecord{} err := g.db.Lookup(src, &record) if err != nil { fmt.Printf(\"geoip(): failed to lookup %s: %s\", src, err) } if record.Country.ISOCode == \"\" { return \"UNKNOWN\" } return record.Country.ISOCode } func (g *geoip) Request(c filters.FilterContext) { c.Request().Header.Set(g.header, g.lookup(c.Request())) } func (g *geoip) Response(c filters.FilterContext) {} func (g *geoip) Match(r *http.Request) bool { span := ot.SpanFromContext(r.Context()) if span != nil { span.LogKV(\"GeoIP\", \"start\") } code := g.lookup(r) _, ok := g.countries[code] if span != nil { span.LogKV(\"GeoIP\", code) } return ok } OpenTracing plugins The tracers, except for noop , are built as Go Plugins. A tracing plugin can be loaded with -opentracing NAME as parameter to skipper. Implementations of OpenTracing API can be found in the https://github.com/skipper-plugins/opentracing repository. All plugins must have a function named InitTracer with the following signature func([]string) (opentracing.Tracer, error) The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper's -opentracing parameter. E.g. when the -opentracing parameter is mytracer foo=bar token=xxx somename=bla:3 the \"mytracer\" plugin will receive []string{\"foo=bar\", \"token=xxx\", \"somename=bla:3\"} as arguments. The tracer plugin implementation is responsible to parse the received arguments. An example plugin looks like package main import ( basic \"github.com/opentracing/basictracer-go\" opentracing \"github.com/opentracing/opentracing-go\" ) func InitTracer(opts []string) (opentracing.Tracer, error) { return basic.NewTracerWithOptions(basic.Options{ Recorder: basic.NewInMemoryRecorder(), ShouldSample: func(traceID uint64) bool { return traceID%64 == 0 }, MaxLogsPerSpan: 25, }), nil }","title":"Plugins"},{"location":"plugins/#skipper-plugins","text":"Skipper may be extended with functionality not present in the core. These additions can be built as go plugin, so they do not have to be present in the main skipper repository. Note the warning from Go's plugin.go: // The plugin support is currently incomplete, only supports Linux, // and has known bugs. Please report any issues. Note the known problem of using plugins together with vendoring, best described here: https://github.com/golang/go/issues/20481","title":"Skipper plugins"},{"location":"plugins/#plugin-directories","text":"Plugins are loaded from sub directories of the plugin directories. By default the plugin directory is set to ./plugins (i.e. relative to skipper's working directory). An additional directory may be given with the -plugindir=/path/to/dir option to skipper. Any file with the suffix .so found below the plugin directories (also in sub directories) is attempted to load without any arguments. When a plugin needs an argument, this must be explicitly loaded and the arguments passed, e.g. with -filter-plugin geoip,db=/path/to/db .","title":"Plugin directories"},{"location":"plugins/#building-a-plugin","text":"Each plugin should be built with go build -buildmode=plugin -o example.so example.go There are some pitfalls: packages which are shared between skipper and the plugin must not be in a vendor/ directory, otherwise the plugin will fail to load or in some cases give wrong results (e.g. an opentracing span cannot be found in the context even if it is present). This also means: Do not vendor skipper in a plugin repo... plugins must be rebuilt when skipper is rebuilt do not attempt to rebuild a module and copy it over a loaded plugin, that will crash skipper immediately...","title":"Building a plugin"},{"location":"plugins/#filter-plugins","text":"All plugins must have a function named InitFilter with the following signature func([]string) (filters.Spec, error) The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper's -filter-plugin parameter. E.g. when the -filter-plugin parameter is myfilter,datafile=/path/to/file,foo=bar the myfilter plugin will receive []string{\"datafile=/path/to/file\", \"foo=bar\"} as arguments. The filter plugin implementation is responsible to parse the received arguments. Filter plugins can be found in the filter repo","title":"Filter plugins"},{"location":"plugins/#example-filter-plugin","text":"An example noop plugin looks like package main import ( \"github.com/zalando/skipper/filters\" ) type noopSpec struct{} func InitFilter(opts []string) (filters.Spec, error) { return noopSpec{}, nil } func (s noopSpec) Name() string { return \"noop\" } func (s noopSpec) CreateFilter(config []interface{}) (filters.Filter, error) { return noopFilter{}, nil } type noopFilter struct{} func (f noopFilter) Request(filters.FilterContext) {} func (f noopFilter) Response(filters.FilterContext) {}","title":"Example filter plugin"},{"location":"plugins/#predicate-plugins","text":"All plugins must have a function named InitPredicate with the following signature func([]string) (routing.PredicateSpec, error) The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper's -predicate-plugin parameter. E.g. when the -predicate-plugin parameter is mypred,datafile=/path/to/file,foo=bar the mypred plugin will receive []string{\"datafile=/path/to/file\", \"foo=bar\"} as arguments. The predicate plugin implementation is responsible to parse the received arguments. Predicate plugins can be found in the predicate repo","title":"Predicate plugins"},{"location":"plugins/#example-predicate-plugin","text":"An example MatchAll plugin looks like package main import ( \"github.com/zalando/skipper/routing\" \"net/http\" ) type noopSpec struct{} func InitPredicate(opts []string) (routing.PredicateSpec, error) { return noopSpec{}, nil } func (s noopSpec) Name() string { return \"MatchAll\" } func (s noopSpec) Create(config []interface{}) (routing.Predicate, error) { return noopPredicate{}, nil } type noopPredicate struct{} func (p noopPredicate) Match(*http.Request) bool { return true }","title":"Example predicate plugin"},{"location":"plugins/#dataclient-plugins","text":"Similar to the above predicate and filter plugins. The command line option for data client plugins is -dataclient-plugin . The module must have a InitDataClient function with the signature func([]string) (routing.DataClient, error) A noop data client looks like package main import ( \"github.com/zalando/skipper/eskip\" \"github.com/zalando/skipper/routing\" ) func InitDataClient([]string) (routing.DataClient, error) { var dc DataClient = \"\" return dc, nil } type DataClient string func (dc DataClient) LoadAll() ([]*eskip.Route, error) { return eskip.Parse(string(dc)) } func (dc DataClient) LoadUpdate() ([]*eskip.Route, []string, error) { return nil, nil, nil }","title":"DataClient plugins"},{"location":"plugins/#multitype-plugins","text":"Sometimes it is necessary to combine multiple plugin types into one module. This can be done with this kind of plugin. Note that these modules are not auto loaded, these need an explicit -multi-plugin name,arg1,arg2 command line switch for skipper. The module must have a InitPlugin function with the signature func([]string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error) Any of the returned types may be nil, so you can have e.g. a combined filter / data client plugin or share a filter and a predicate, e.g. like package main import ( \"fmt\" \"net\" \"net/http\" \"strconv\" \"strings\" ot \"github.com/opentracing/opentracing-go\" maxminddb \"github.com/oschwald/maxminddb-golang\" \"github.com/zalando/skipper/filters\" snet \"github.com/zalando/skipper/net\" \"github.com/zalando/skipper/predicates\" \"github.com/zalando/skipper/routing\" ) type geoipSpec struct { db *maxminddb.Reader name string } func InitPlugin(opts []string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error) { var db string for _, o := range opts { switch { case strings.HasPrefix(o, \"db=\"): db = o[3:] } } if db == \"\" { return nil, nil, nil, fmt.Errorf(\"missing db= parameter for geoip plugin\") } reader, err := maxminddb.Open(db) if err != nil { return nil, nil, nil, fmt.Errorf(\"failed to open db %s: %s\", db, err) } return []filters.Spec{&geoipSpec{db: reader, name: \"geoip\"}}, []routing.PredicateSpec{&geoipSpec{db: reader, name: \"GeoIP\"}}, nil, nil } func (s *geoipSpec) Name() string { return s.name } func (s *geoipSpec) CreateFilter(config []interface{}) (filters.Filter, error) { var fromLast bool header := \"X-GeoIP-Country\" var err error for _, c := range config { if s, ok := c.(string); ok { switch { case strings.HasPrefix(s, \"from_last=\"): fromLast, err = strconv.ParseBool(s[10:]) if err != nil { return nil, filters.ErrInvalidFilterParameters } case strings.HasPrefix(s, \"header=\"): header = s[7:] } } } return &geoip{db: s.db, fromLast: fromLast, header: header}, nil } func (s *geoipSpec) Create(config []interface{}) (routing.Predicate, error) { var fromLast bool var err error countries := make(map[string]struct{}) for _, c := range config { if s, ok := c.(string); ok { switch { case strings.HasPrefix(s, \"from_last=\"): fromLast, err = strconv.ParseBool(s[10:]) if err != nil { return nil, predicates.ErrInvalidPredicateParameters } default: countries[strings.ToUpper(s)] = struct{}{} } } } return &geoip{db: s.db, fromLast: fromLast, countries: countries}, nil } type geoip struct { db *maxminddb.Reader fromLast bool header string countries map[string]struct{} } type countryRecord struct { Country struct { ISOCode string `maxminddb:\"iso_code\"` } `maxminddb:\"country\"` } func (g *geoip) lookup(r *http.Request) string { var src net.IP if g.fromLast { src = snet.RemoteHostFromLast(r) } else { src = snet.RemoteHost(r) } record := countryRecord{} err := g.db.Lookup(src, &record) if err != nil { fmt.Printf(\"geoip(): failed to lookup %s: %s\", src, err) } if record.Country.ISOCode == \"\" { return \"UNKNOWN\" } return record.Country.ISOCode } func (g *geoip) Request(c filters.FilterContext) { c.Request().Header.Set(g.header, g.lookup(c.Request())) } func (g *geoip) Response(c filters.FilterContext) {} func (g *geoip) Match(r *http.Request) bool { span := ot.SpanFromContext(r.Context()) if span != nil { span.LogKV(\"GeoIP\", \"start\") } code := g.lookup(r) _, ok := g.countries[code] if span != nil { span.LogKV(\"GeoIP\", code) } return ok }","title":"MultiType plugins"},{"location":"plugins/#opentracing-plugins","text":"The tracers, except for noop , are built as Go Plugins. A tracing plugin can be loaded with -opentracing NAME as parameter to skipper. Implementations of OpenTracing API can be found in the https://github.com/skipper-plugins/opentracing repository. All plugins must have a function named InitTracer with the following signature func([]string) (opentracing.Tracer, error) The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper's -opentracing parameter. E.g. when the -opentracing parameter is mytracer foo=bar token=xxx somename=bla:3 the \"mytracer\" plugin will receive []string{\"foo=bar\", \"token=xxx\", \"somename=bla:3\"} as arguments. The tracer plugin implementation is responsible to parse the received arguments. An example plugin looks like package main import ( basic \"github.com/opentracing/basictracer-go\" opentracing \"github.com/opentracing/opentracing-go\" ) func InitTracer(opts []string) (opentracing.Tracer, error) { return basic.NewTracerWithOptions(basic.Options{ Recorder: basic.NewInMemoryRecorder(), ShouldSample: func(traceID uint64) bool { return traceID%64 == 0 }, MaxLogsPerSpan: 25, }), nil }","title":"OpenTracing plugins"},{"location":"predicates/","text":"Skipper Predicates The parameters can be strings, regex or float64 / int string is a string surrounded by double quotes ( \" ) regex is a re2 regular expression , surrounded by / , e.g. /^www\\.example\\.org(:\\d+)?$/ int / float64 are usual (decimal) numbers like 401 or 1.23456 time is a string in double quotes, parseable by time.Duration ) Predicates are a generic tool and can change the route matching behavior. Predicates can be chained using the double ampersand operator && . Example route with a Host, Method and Path match predicates and a backend: all: Host(\"^my-host-header\\.example\\.org$\") && Method(\"GET\") && Path(\"/hello\") -> \"http://127.0.0.1:1234/\"; Path The route definitions may contain a single path condition, optionally with wildcards, used for looking up routes in the lookup tree. Parameters: Path (string) can contain a wildcard * or a named :wildcard Examples: Path(\"/foo/bar\") Path(\"/foo/:bar\") Path(\"/foo*\") Path(\"/foo/*\") Path(\"/foo/**\") PathSubtree Similar to Path, but used to match full subtrees including the path of the definition. PathSubtree(\"/foo\") predicate is equivalent to having routes with Path(\"/foo\"), Path(\"/foo/\") and Path(\"/foo/**\") predicates. Parameters: PathSubtree (string) Examples: PathSubtree(\"/foo/bar\") PathSubtree(\"/\") PathSubtree(\"/foo*\") PathRegexp Regular expressions to match the path. It uses Go's standard library regexp package to match, which is based on re2 regular expression syntax . Parameters: PathRegexp (regex) Examples: PathRegexp(\"^/foo/bar\") PathRegexp(\"/foo/bar$\") PathRegexp(\"/foo/bar/\") PathRegexp(\"^/foo/(bar|qux)\") Host Regular expressions that the host header in the request must match. Parameters: Host (regex) Examples: Host(\"/^my-host-header\\.example\\.org$/\") Host(\"/header\\.example\\.org$/\") Method The HTTP method that the request must match. HTTP methods are one of GET, HEAD, POST, PUT, DELETE, OPTIONS, CONNECT. Parameters: Method (string) Examples: Method(\"GET\") Method(\"OPTIONS\") Header A header key and exact value that must be present in the request. Note that Header(\"Key\", \"Value\") is equivalent to HeaderRegexp(\"Key\", \"^Value$\"). Parameters: Header (string, string) Examples: Header(\"X-Forwarded-For\", \"192.168.0.2\") Header(\"Accept\", \"application/json\") HeaderRegexp A header key and a regular expression, where the key must be present in the request and one of the associated values must match the expression. Parameters: HeaderRegexp (string, regex) Examples: HeaderRegexp(\"X-Forwarded-For\", \"^192\\.168\\.0\\.[0-2]?[0-9]?[0-9] \") HeaderRegexp(\"Accept\", \"application/(json|xml)\") Cookie Matches if the specified cookie is set in the request. Parameters: Cookie (string, regex) name and value match Examples: Cookie(\"alpha\", /^enabled$/) Auth Authorization header based match. JWTPayloadAnyKV Match the route if at least one of the base64 decoded JWT content matches the key value configuration. Parameters: Key-Value pairs (...string), odd index is the key of the JWT content and even index is the value of the JWT content Examples: JWTPayloadAnyKV(\"iss\", \"https://accounts.google.com\") JWTPayloadAnyKV(\"iss\", \"https://accounts.google.com\", \"email\", \"skipper-router@googlegroups.com\") JWTPayloadAllKV Match the route if all of the base64 decoded JWT content matches the key value configuration. Parameters: Key-Value pairs (...string), odd index is the key of the JWT content and even index is the value of the JWT content Examples: JWTPayloadAllKV(\"iss\", \"https://accounts.google.com\") JWTPayloadAllKV(\"iss\", \"https://accounts.google.com\", \"email\", \"skipper-router@googlegroups.com\") Interval An interval implements custom predicates to match routes only during some period of time. There are three predicates: Between, Before and After. All predicates can be created using the date represented as a string in RFC3339 format (see https://golang.org/pkg/time/#pkg-constants), int64 or float64 number. float64 number will be converted into int64 number. After Matches if the request is after the specified time Parameters: After (string) date string After (int) unixtime Examples: After(\"2016-01-01T12:00:00+02:00\") After(1451642400) Before Matches if the request is before the specified time Parameters: Before (string) date string Before (int) unixtime Examples: Before(\"2016-01-01T12:00:00+02:00\") Before(1451642400) Between Matches if the request is between the specified timeframe Parameters: Between (string, string) date string, from - till Between (int, int) unixtime, from - till Examples: Between(\"2016-01-01T12:00:00+02:00\", \"2016-02-01T12:00:00+02:00\") Between(1451642400, 1454320800) QueryParam Match request based on the Query Params in URL Parameters: QueryParam (string) name QueryParam (string, regex) name and value match Examples: // matches http://example.org?bb=a&query=withvalue QueryParam(\"query\") // Even a query param without a value // matches http://example.org?bb=a&query= QueryParam(\"query\") // matches with regexp // matches http://example.org?bb=a&query=example QueryParam(\"query\", \"^example$\") // matches with regexp and multiple values of query param // matches http://example.org?bb=a&query=testing&query=example QueryParam(\"query\", \"^example$\") Source Source implements a custom predicate to match routes based on the source IP or X-Forwarded-For header of a request. Parameters: Source (string, ..) varargs with IPs or CIDR Examples: // only match requests from 1.2.3.4 Source(\"1.2.3.4\") // only match requests from 1.2.3.0 - 1.2.3.255 Source(\"1.2.3.0/24\") // only match requests from 1.2.3.4 and the 2.2.2.0/24 network Source(\"1.2.3.4\", \"2.2.2.0/24\") SourceFromLast The same as Source , but use the last part of the X-Forwarded-For header to match the network. This seems to be only used in the popular loadbalancers from AWS, ELB and ALB, because they put the client-IP as last part of the X-Forwarded-For headers. Parameters: SourceFromLast (string, ..) varargs with IPs or CIDR Examples: SourceFromLast(\"1.2.3.4\", \"2.2.2.0/24\") Traffic Traffic implements a predicate to control the matching probability for a given route by setting its weight. The probability for matching a route is defined by the mandatory first parameter, that must be a decimal number between 0.0 and 1.0 (both exclusive). The optional second argument is used to specify the cookie name for the traffic group, in case you want to use stickiness. Stickiness allows all subsequent requests from the same client to match the same route. Stickiness of traffic is supported by the optional third parameter, indicating whether the request being matched belongs to the traffic group of the current route. If yes, the predicate matches ignoring the chance argument. Parameters: Traffic (decimal) valid values [0.0, 1.0] Traffic (decimal, string, string) session stickyness Examples: non-sticky: // hit by 10% percent chance v2: Traffic(.1) -> \"https://api-test-green\"; // hit by remaining chance v1: \"https://api-test-blue\"; stickyness: // hit by 5% percent chance cartTest: Traffic(.05, \"cart-test\", \"test\") && Path(\"/cart\") -> responseCookie(\"cart-test\", \"test\") -> \"https://cart-test\"; // hit by remaining chance cart: Path(\"/cart\") -> responseCookie(\"cart-test\", \"default\") -> \"https://cart\"; // hit by 15% percent chance catalogTestA: Traffic(.15, \"catalog-test\", \"A\") -> responseCookie(\"catalog-test\", \"A\") -> \"https://catalog-test-a\"; // hit by 30% percent chance catalogTestB: Traffic(.3, \"catalog-test\", \"B\") -> responseCookie(\"catalog-test\", \"B\") -> \"https://catalog-test-b\"; // hit by remaining chance catalog: * -> responseCookie(\"catalog-test\", \"default\") -> \"https://catalog\";","title":"Predicates"},{"location":"predicates/#skipper-predicates","text":"The parameters can be strings, regex or float64 / int string is a string surrounded by double quotes ( \" ) regex is a re2 regular expression , surrounded by / , e.g. /^www\\.example\\.org(:\\d+)?$/ int / float64 are usual (decimal) numbers like 401 or 1.23456 time is a string in double quotes, parseable by time.Duration ) Predicates are a generic tool and can change the route matching behavior. Predicates can be chained using the double ampersand operator && . Example route with a Host, Method and Path match predicates and a backend: all: Host(\"^my-host-header\\.example\\.org$\") && Method(\"GET\") && Path(\"/hello\") -> \"http://127.0.0.1:1234/\";","title":"Skipper Predicates"},{"location":"predicates/#path","text":"The route definitions may contain a single path condition, optionally with wildcards, used for looking up routes in the lookup tree. Parameters: Path (string) can contain a wildcard * or a named :wildcard Examples: Path(\"/foo/bar\") Path(\"/foo/:bar\") Path(\"/foo*\") Path(\"/foo/*\") Path(\"/foo/**\")","title":"Path"},{"location":"predicates/#pathsubtree","text":"Similar to Path, but used to match full subtrees including the path of the definition. PathSubtree(\"/foo\") predicate is equivalent to having routes with Path(\"/foo\"), Path(\"/foo/\") and Path(\"/foo/**\") predicates. Parameters: PathSubtree (string) Examples: PathSubtree(\"/foo/bar\") PathSubtree(\"/\") PathSubtree(\"/foo*\")","title":"PathSubtree"},{"location":"predicates/#pathregexp","text":"Regular expressions to match the path. It uses Go's standard library regexp package to match, which is based on re2 regular expression syntax . Parameters: PathRegexp (regex) Examples: PathRegexp(\"^/foo/bar\") PathRegexp(\"/foo/bar$\") PathRegexp(\"/foo/bar/\") PathRegexp(\"^/foo/(bar|qux)\")","title":"PathRegexp"},{"location":"predicates/#host","text":"Regular expressions that the host header in the request must match. Parameters: Host (regex) Examples: Host(\"/^my-host-header\\.example\\.org$/\") Host(\"/header\\.example\\.org$/\")","title":"Host"},{"location":"predicates/#method","text":"The HTTP method that the request must match. HTTP methods are one of GET, HEAD, POST, PUT, DELETE, OPTIONS, CONNECT. Parameters: Method (string) Examples: Method(\"GET\") Method(\"OPTIONS\")","title":"Method"},{"location":"predicates/#header","text":"A header key and exact value that must be present in the request. Note that Header(\"Key\", \"Value\") is equivalent to HeaderRegexp(\"Key\", \"^Value$\"). Parameters: Header (string, string) Examples: Header(\"X-Forwarded-For\", \"192.168.0.2\") Header(\"Accept\", \"application/json\")","title":"Header"},{"location":"predicates/#headerregexp","text":"A header key and a regular expression, where the key must be present in the request and one of the associated values must match the expression. Parameters: HeaderRegexp (string, regex) Examples: HeaderRegexp(\"X-Forwarded-For\", \"^192\\.168\\.0\\.[0-2]?[0-9]?[0-9] \") HeaderRegexp(\"Accept\", \"application/(json|xml)\")","title":"HeaderRegexp"},{"location":"predicates/#cookie","text":"Matches if the specified cookie is set in the request. Parameters: Cookie (string, regex) name and value match Examples: Cookie(\"alpha\", /^enabled$/)","title":"Cookie"},{"location":"predicates/#auth","text":"Authorization header based match.","title":"Auth"},{"location":"predicates/#jwtpayloadanykv","text":"Match the route if at least one of the base64 decoded JWT content matches the key value configuration. Parameters: Key-Value pairs (...string), odd index is the key of the JWT content and even index is the value of the JWT content Examples: JWTPayloadAnyKV(\"iss\", \"https://accounts.google.com\") JWTPayloadAnyKV(\"iss\", \"https://accounts.google.com\", \"email\", \"skipper-router@googlegroups.com\")","title":"JWTPayloadAnyKV"},{"location":"predicates/#jwtpayloadallkv","text":"Match the route if all of the base64 decoded JWT content matches the key value configuration. Parameters: Key-Value pairs (...string), odd index is the key of the JWT content and even index is the value of the JWT content Examples: JWTPayloadAllKV(\"iss\", \"https://accounts.google.com\") JWTPayloadAllKV(\"iss\", \"https://accounts.google.com\", \"email\", \"skipper-router@googlegroups.com\")","title":"JWTPayloadAllKV"},{"location":"predicates/#interval","text":"An interval implements custom predicates to match routes only during some period of time. There are three predicates: Between, Before and After. All predicates can be created using the date represented as a string in RFC3339 format (see https://golang.org/pkg/time/#pkg-constants), int64 or float64 number. float64 number will be converted into int64 number.","title":"Interval"},{"location":"predicates/#after","text":"Matches if the request is after the specified time Parameters: After (string) date string After (int) unixtime Examples: After(\"2016-01-01T12:00:00+02:00\") After(1451642400)","title":"After"},{"location":"predicates/#before","text":"Matches if the request is before the specified time Parameters: Before (string) date string Before (int) unixtime Examples: Before(\"2016-01-01T12:00:00+02:00\") Before(1451642400)","title":"Before"},{"location":"predicates/#between","text":"Matches if the request is between the specified timeframe Parameters: Between (string, string) date string, from - till Between (int, int) unixtime, from - till Examples: Between(\"2016-01-01T12:00:00+02:00\", \"2016-02-01T12:00:00+02:00\") Between(1451642400, 1454320800)","title":"Between"},{"location":"predicates/#queryparam","text":"Match request based on the Query Params in URL Parameters: QueryParam (string) name QueryParam (string, regex) name and value match Examples: // matches http://example.org?bb=a&query=withvalue QueryParam(\"query\") // Even a query param without a value // matches http://example.org?bb=a&query= QueryParam(\"query\") // matches with regexp // matches http://example.org?bb=a&query=example QueryParam(\"query\", \"^example$\") // matches with regexp and multiple values of query param // matches http://example.org?bb=a&query=testing&query=example QueryParam(\"query\", \"^example$\")","title":"QueryParam"},{"location":"predicates/#source","text":"Source implements a custom predicate to match routes based on the source IP or X-Forwarded-For header of a request. Parameters: Source (string, ..) varargs with IPs or CIDR Examples: // only match requests from 1.2.3.4 Source(\"1.2.3.4\") // only match requests from 1.2.3.0 - 1.2.3.255 Source(\"1.2.3.0/24\") // only match requests from 1.2.3.4 and the 2.2.2.0/24 network Source(\"1.2.3.4\", \"2.2.2.0/24\")","title":"Source"},{"location":"predicates/#sourcefromlast","text":"The same as Source , but use the last part of the X-Forwarded-For header to match the network. This seems to be only used in the popular loadbalancers from AWS, ELB and ALB, because they put the client-IP as last part of the X-Forwarded-For headers. Parameters: SourceFromLast (string, ..) varargs with IPs or CIDR Examples: SourceFromLast(\"1.2.3.4\", \"2.2.2.0/24\")","title":"SourceFromLast"},{"location":"predicates/#traffic","text":"Traffic implements a predicate to control the matching probability for a given route by setting its weight. The probability for matching a route is defined by the mandatory first parameter, that must be a decimal number between 0.0 and 1.0 (both exclusive). The optional second argument is used to specify the cookie name for the traffic group, in case you want to use stickiness. Stickiness allows all subsequent requests from the same client to match the same route. Stickiness of traffic is supported by the optional third parameter, indicating whether the request being matched belongs to the traffic group of the current route. If yes, the predicate matches ignoring the chance argument. Parameters: Traffic (decimal) valid values [0.0, 1.0] Traffic (decimal, string, string) session stickyness Examples: non-sticky: // hit by 10% percent chance v2: Traffic(.1) -> \"https://api-test-green\"; // hit by remaining chance v1: \"https://api-test-blue\"; stickyness: // hit by 5% percent chance cartTest: Traffic(.05, \"cart-test\", \"test\") && Path(\"/cart\") -> responseCookie(\"cart-test\", \"test\") -> \"https://cart-test\"; // hit by remaining chance cart: Path(\"/cart\") -> responseCookie(\"cart-test\", \"default\") -> \"https://cart\"; // hit by 15% percent chance catalogTestA: Traffic(.15, \"catalog-test\", \"A\") -> responseCookie(\"catalog-test\", \"A\") -> \"https://catalog-test-a\"; // hit by 30% percent chance catalogTestB: Traffic(.3, \"catalog-test\", \"B\") -> responseCookie(\"catalog-test\", \"B\") -> \"https://catalog-test-b\"; // hit by remaining chance catalog: * -> responseCookie(\"catalog-test\", \"default\") -> \"https://catalog\";","title":"Traffic"},{"location":"scripts/","text":"Lua filter scripts LUA scripts can be used as filters in skipper. The current implementation supports Lua 5.1 . Route filters The lua scripts can be added to a route description with the lua() filter, the first parameter for the filter is the script. This can be either a file name (ending with .lua ) or inline code, e.g. as file lua(\"/path/to/file.lua\") - if a file path is not absolute, the path is relative to skipper's working directory. inline lua(\"function request(c, p); print(c.request.url); end\") Any other additional parameters for the filter must be key=value strings. These will be passed as table to the called functions as second parameter. NOTE : Any parameter starting with \"lua-\" should not be used to pass values for the script - those will be used for configuring the filter. Script requirements A filter script needs at least one global function: request or response . If present, they are called with a skipper filter context and the params passed in the route as table like -- route looks like -- -- any: * -> lua(\"./test.lua\", \"myparam=foo\", \"other=bar\") -> <shunt> -- function request(ctx, params) print(ctx.request.method .. \" \" .. ctx.request.url .. \" -> \" .. params.myparam) end Available lua modules Besides the standard modules - except for debug - the following modules have been preloaded and can be used with e.g. local http = require(\"http\") , see also the examples below http gluahttp - TODO: configurable with something different than &http.Client{} url gluaurl json gopher-json base64 lua base64 For differences between the standard modules and the gopher-lua implementation check the gopher-lua documentation . Any other module can be loaded in non-byte code form from the lua path (by default for require(\"mod\") this is ./mod.lua , /usr/local/share/lua/5.1/mod.lua and /usr/local/share/lua/5.1/mod/init.lua ). Lua states There is no guarantee that the request() and response() functions of a lua script run in the same lua state during one request. Setting a variable in the request and accessing it in the response will most likely fail and lead to hard debuggable errors. Use the ctx.state_bag to propagate values from request to response - and any other filter in the chain. Request The request() function is run for an incoming request. Headers Request headers can be accessed by accessing the ctx.request.header map like ua = ctx.request.header[\"user-agent\"] Header names are normalized by the net/http go module like usual . Setting a header is done by assigning to the headers map. Setting a header to nil or an empty string deletes the header - setting to nil is preferred. ctx.request.header[\"user-agent\"] = \"skipper.lua/0.0.1\" ctx.request.header[\"Authorization\"] = nil -- delete authorization header Response headers work the same way by accessing / assigning to ctx.response.header - this is of course only valid in the response() phase. Other request fields backend_url - (read only) returns the backend url specified in the route or an empty value in case it's a shunt or loopback outgoing_host - (read/write) the host that will be set for the outgoing proxy request as the 'Host' header. remote_addr - (read only) the remote host, usually IP:port content_length - (read only) content length proto - (read only) something like \"HTTP/1.1\" method - (read only) request method, e.g. \"GET\" or \"POST\" url - (read/write) request URL as string Serving requests from lua Requests can be served with ctx.serve(table) , you must return after this call. Possible keys for the table: status_code (number) - required (but currently not enforced) header (table) body (string) See also redirect and internal server error examples below StateBag The state bag can be used to pass values from one filter to another in the same chain. It is shared by all filters in one request. function request(ctx, params) -- the value of \"mykey\" will be available to all filters in the chain now: ctx.state_bag[\"mykey\"] = \"foo\" end function response(ctx, params) print(ctx.state_bag[\"mykey\"]) end Examples Note: the examples serve as examples. If there is a go based plugin available, use that instead. The overhead of calling lua is 4-5 times slower than pure go. OAuth2 token as basic auth password local base64 = require(\"base64\") function request(ctx, params) token = string.gsub(ctx.request.header[\"Authorization\"], \"^%s*[Bb]earer%s+\", \"\", 1) user = ctx.request.header[\"x-username\"] if user == \"\" then user = params.username end ctx.request.header[\"Authorization\"] = \"Basic \" .. base64.encode(user .. \":\" .. token) -- print(ctx.request.header[\"Authorization\"]) end validate token local http = require(\"http\") function request(ctx, params) token = string.gsub(ctx.request.header[\"Authorization\"], \"^%s*[Bb]earer%s+\", \"\", 1) if token == \"\" then ctx.serve({status_code=401, body=\"Missing Token\"}) return end res, err = http.get(\"https://auth.example.com/oauth2/tokeninfo?access_token=\"..token) if err ~= nil then print(\"Failed to get tokeninfo: \" .. err) ctx.serve({status_code=401, body=\"Failed to validate token: \"..err}) return end if res.status_code ~= 200 then ctx.serve({status_code=401, body=\"Invalid token\"}) return end end strip query function request(ctx, params) ctx.request.url = string.gsub(ctx.request.url, \"%?.*$\", \"\") -- print(\"URL=\"..ctx.request.url) end redirect function request(ctx, params) ctx.serve({ status_code=302, header={ location=\"http://www.example.org/\", }, }) end internal server error function request(ctx, params) -- let 10% of all requests fail with 500 if math.random() < 0.1 then ctx.serve({ status_code=500, body=\"Internal Server Error.\\n\", }) end end Benchmark redirectTo vs lua redirect See skptesting/benchmark-lua.sh Route for \"skipper\" is * -> redirectTo(\"http://localhost:9980\") -> <shunt> , route for \"lua\" is * -> lua(\"function request(c,p); c.serve({status_code=302, header={location='http://localhost:9980'}});end\") -> <shunt> [benchmarking skipper] Running 12s test @ http://127.0.0.1:9990/lorem.html 2 threads and 128 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.75ms 14.22ms 260.28ms 92.19% Req/Sec 23.87k 2.93k 32.22k 70.42% 572695 requests in 12.06s, 100.49MB read Non-2xx or 3xx responses: 572695 Requests/sec: 47474.31 Transfer/sec: 8.33MB [benchmarking skipper done] [benchmarking lua] Running 12s test @ http://127.0.0.1:9991/lorem.html 2 threads and 128 connections Thread Stats Avg Stdev Max +/- Stdev Latency 38.31ms 53.48ms 580.80ms 83.69% Req/Sec 5.44k 1.03k 8.23k 71.25% 130123 requests in 12.01s, 20.97MB read Requests/sec: 10831.94 Transfer/sec: 1.75MB [benchmarking lua done] The benchmark was run with the default pool size of script.InitialPoolSize = 3; script.MaxPoolSize = 10 . With script.InitialPoolSize = 128; script.MaxPoolSize = 128 (tweaked for this benchmark) you get about 12k req/s in lua. Similar results are achieved when testing stripQuery() vs the lua version from above.","title":"Scripts"},{"location":"scripts/#lua-filter-scripts","text":"LUA scripts can be used as filters in skipper. The current implementation supports Lua 5.1 .","title":"Lua filter scripts"},{"location":"scripts/#route-filters","text":"The lua scripts can be added to a route description with the lua() filter, the first parameter for the filter is the script. This can be either a file name (ending with .lua ) or inline code, e.g. as file lua(\"/path/to/file.lua\") - if a file path is not absolute, the path is relative to skipper's working directory. inline lua(\"function request(c, p); print(c.request.url); end\") Any other additional parameters for the filter must be key=value strings. These will be passed as table to the called functions as second parameter. NOTE : Any parameter starting with \"lua-\" should not be used to pass values for the script - those will be used for configuring the filter.","title":"Route filters"},{"location":"scripts/#script-requirements","text":"A filter script needs at least one global function: request or response . If present, they are called with a skipper filter context and the params passed in the route as table like -- route looks like -- -- any: * -> lua(\"./test.lua\", \"myparam=foo\", \"other=bar\") -> <shunt> -- function request(ctx, params) print(ctx.request.method .. \" \" .. ctx.request.url .. \" -> \" .. params.myparam) end","title":"Script requirements"},{"location":"scripts/#available-lua-modules","text":"Besides the standard modules - except for debug - the following modules have been preloaded and can be used with e.g. local http = require(\"http\") , see also the examples below http gluahttp - TODO: configurable with something different than &http.Client{} url gluaurl json gopher-json base64 lua base64 For differences between the standard modules and the gopher-lua implementation check the gopher-lua documentation . Any other module can be loaded in non-byte code form from the lua path (by default for require(\"mod\") this is ./mod.lua , /usr/local/share/lua/5.1/mod.lua and /usr/local/share/lua/5.1/mod/init.lua ).","title":"Available lua modules"},{"location":"scripts/#lua-states","text":"There is no guarantee that the request() and response() functions of a lua script run in the same lua state during one request. Setting a variable in the request and accessing it in the response will most likely fail and lead to hard debuggable errors. Use the ctx.state_bag to propagate values from request to response - and any other filter in the chain.","title":"Lua states"},{"location":"scripts/#request","text":"The request() function is run for an incoming request.","title":"Request"},{"location":"scripts/#headers","text":"Request headers can be accessed by accessing the ctx.request.header map like ua = ctx.request.header[\"user-agent\"] Header names are normalized by the net/http go module like usual . Setting a header is done by assigning to the headers map. Setting a header to nil or an empty string deletes the header - setting to nil is preferred. ctx.request.header[\"user-agent\"] = \"skipper.lua/0.0.1\" ctx.request.header[\"Authorization\"] = nil -- delete authorization header Response headers work the same way by accessing / assigning to ctx.response.header - this is of course only valid in the response() phase.","title":"Headers"},{"location":"scripts/#other-request-fields","text":"backend_url - (read only) returns the backend url specified in the route or an empty value in case it's a shunt or loopback outgoing_host - (read/write) the host that will be set for the outgoing proxy request as the 'Host' header. remote_addr - (read only) the remote host, usually IP:port content_length - (read only) content length proto - (read only) something like \"HTTP/1.1\" method - (read only) request method, e.g. \"GET\" or \"POST\" url - (read/write) request URL as string","title":"Other request fields"},{"location":"scripts/#serving-requests-from-lua","text":"Requests can be served with ctx.serve(table) , you must return after this call. Possible keys for the table: status_code (number) - required (but currently not enforced) header (table) body (string) See also redirect and internal server error examples below","title":"Serving requests from lua"},{"location":"scripts/#statebag","text":"The state bag can be used to pass values from one filter to another in the same chain. It is shared by all filters in one request. function request(ctx, params) -- the value of \"mykey\" will be available to all filters in the chain now: ctx.state_bag[\"mykey\"] = \"foo\" end function response(ctx, params) print(ctx.state_bag[\"mykey\"]) end","title":"StateBag"},{"location":"scripts/#examples","text":"Note: the examples serve as examples. If there is a go based plugin available, use that instead. The overhead of calling lua is 4-5 times slower than pure go.","title":"Examples"},{"location":"scripts/#oauth2-token-as-basic-auth-password","text":"local base64 = require(\"base64\") function request(ctx, params) token = string.gsub(ctx.request.header[\"Authorization\"], \"^%s*[Bb]earer%s+\", \"\", 1) user = ctx.request.header[\"x-username\"] if user == \"\" then user = params.username end ctx.request.header[\"Authorization\"] = \"Basic \" .. base64.encode(user .. \":\" .. token) -- print(ctx.request.header[\"Authorization\"]) end","title":"OAuth2 token as basic auth password"},{"location":"scripts/#validate-token","text":"local http = require(\"http\") function request(ctx, params) token = string.gsub(ctx.request.header[\"Authorization\"], \"^%s*[Bb]earer%s+\", \"\", 1) if token == \"\" then ctx.serve({status_code=401, body=\"Missing Token\"}) return end res, err = http.get(\"https://auth.example.com/oauth2/tokeninfo?access_token=\"..token) if err ~= nil then print(\"Failed to get tokeninfo: \" .. err) ctx.serve({status_code=401, body=\"Failed to validate token: \"..err}) return end if res.status_code ~= 200 then ctx.serve({status_code=401, body=\"Invalid token\"}) return end end","title":"validate token"},{"location":"scripts/#strip-query","text":"function request(ctx, params) ctx.request.url = string.gsub(ctx.request.url, \"%?.*$\", \"\") -- print(\"URL=\"..ctx.request.url) end","title":"strip query"},{"location":"scripts/#redirect","text":"function request(ctx, params) ctx.serve({ status_code=302, header={ location=\"http://www.example.org/\", }, }) end","title":"redirect"},{"location":"scripts/#internal-server-error","text":"function request(ctx, params) -- let 10% of all requests fail with 500 if math.random() < 0.1 then ctx.serve({ status_code=500, body=\"Internal Server Error.\\n\", }) end end","title":"internal server error"},{"location":"scripts/#benchmark","text":"","title":"Benchmark"},{"location":"scripts/#redirectto-vs-lua-redirect","text":"See skptesting/benchmark-lua.sh Route for \"skipper\" is * -> redirectTo(\"http://localhost:9980\") -> <shunt> , route for \"lua\" is * -> lua(\"function request(c,p); c.serve({status_code=302, header={location='http://localhost:9980'}});end\") -> <shunt> [benchmarking skipper] Running 12s test @ http://127.0.0.1:9990/lorem.html 2 threads and 128 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.75ms 14.22ms 260.28ms 92.19% Req/Sec 23.87k 2.93k 32.22k 70.42% 572695 requests in 12.06s, 100.49MB read Non-2xx or 3xx responses: 572695 Requests/sec: 47474.31 Transfer/sec: 8.33MB [benchmarking skipper done] [benchmarking lua] Running 12s test @ http://127.0.0.1:9991/lorem.html 2 threads and 128 connections Thread Stats Avg Stdev Max +/- Stdev Latency 38.31ms 53.48ms 580.80ms 83.69% Req/Sec 5.44k 1.03k 8.23k 71.25% 130123 requests in 12.01s, 20.97MB read Requests/sec: 10831.94 Transfer/sec: 1.75MB [benchmarking lua done] The benchmark was run with the default pool size of script.InitialPoolSize = 3; script.MaxPoolSize = 10 . With script.InitialPoolSize = 128; script.MaxPoolSize = 128 (tweaked for this benchmark) you get about 12k req/s in lua. Similar results are achieved when testing stripQuery() vs the lua version from above.","title":"redirectTo vs lua redirect"},{"location":"videos/","text":"How to build Skipper We expect you to have Go and glide installed. How to build Skipper without plugins How to build Skipper with plugins TODO How to run Skipper We expect you to have already built Skipper. TODO","title":"Videos"},{"location":"videos/#how-to-build-skipper","text":"We expect you to have Go and glide installed.","title":"How to build Skipper"},{"location":"videos/#how-to-build-skipper-without-plugins","text":"","title":"How to build Skipper without plugins"},{"location":"videos/#how-to-build-skipper-with-plugins","text":"TODO","title":"How to build Skipper with plugins"},{"location":"videos/#how-to-run-skipper","text":"We expect you to have already built Skipper. TODO","title":"How to run Skipper"},{"location":"dataclients/eskip-file/","text":"Eskip File Eskip file dataclient can be used to serve static defined routes, read from an eskip file. The file format eskip shows your route definitions in a clear way: % cat example.eskip hello: Path(\"/hello\") -> \"https://www.example.org\"' The Skipper project has two binaries, one is skipper , the other is eskip . Eskip can be used to validate the syntax of your routes file before reloading a production server: % eskip check example.eskip To run Skipper serving routes from an eskip file you have to use -routes-file <file> parameter: % skipper -routes-file example.eskip A more complicated example with different routes, matches, predicates and filters shows that you can name your route and use preconditions and create, change, delete HTTP headers as you like: % cat complicated_example.eskip hostHeaderMatch: Host(\"^skipper.teapot.org$\") -> setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\") -> \"https://target-to.auth-with.basic-auth.enterprise.com\"; baiduPathMatch: Path(\"/baidu\") -> setRequestHeader(\"Host\", \"www.baidu.com\") -> setPath(\"/s\") -> setQuery(\"wd\", \"godoc skipper\") -> \"http://www.baidu.com\"; googleWildcardMatch: * -> setPath(\"/search\") -> setQuery(\"q\", \"godoc skipper\") -> \"https://www.google.com\"; yandexWildacardIfCookie: * && Cookie(\"yandex\", \"true\") -> setPath(\"/search/\") -> setQuery(\"text\", \"godoc skipper\") -> tee(\"http://127.0.0.1:12345/\") -> \"https://yandex.ru\"; The former example shows 4 routes: hostHeaderMatch, baiduPathMatch, googleWildcardMatch and yandexWildcardIfCookie. hostHeaderMatch: used if HTTP host header is exactly: \"skipper.teapot.org\", sets a Basic Authorization header and sends the modified request to https://target-to.auth-with.basic-auth.enterprise.com baiduPathMatch: used in case the request patch matches /baidu it will set the Host header to the proxy request it will set the path from /baidu to /s it will set the querystring to \"ws=godoc skipper\" and sends the modified request to http://baidu.com googleWildcardMatch: used as default if no other route matches it will set the path to /search it will set the querystring to \"q=godoc skipper\" and sends the modified request to https://www.google.com yandexWildcardIfCookie: used as default if a Cookie named \"yandex\" has the value \"true\" it will set the path to /search/ it will set the querystring to \"text=godoc skipper\" it will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix tee ) and drop the response and sends the modified request to https://yandex.ru More examples you find in eskip file format description, in filters and in predicates . Eskip file format is also used if you print your current routes in skipper, for example (metrics listener required): % curl localhost:9911/routes * -> setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -> inlineContent(\"{\\\"foo\\\": 3}\") -> <shunt>","title":"Eskip"},{"location":"dataclients/eskip-file/#eskip-file","text":"Eskip file dataclient can be used to serve static defined routes, read from an eskip file. The file format eskip shows your route definitions in a clear way: % cat example.eskip hello: Path(\"/hello\") -> \"https://www.example.org\"' The Skipper project has two binaries, one is skipper , the other is eskip . Eskip can be used to validate the syntax of your routes file before reloading a production server: % eskip check example.eskip To run Skipper serving routes from an eskip file you have to use -routes-file <file> parameter: % skipper -routes-file example.eskip A more complicated example with different routes, matches, predicates and filters shows that you can name your route and use preconditions and create, change, delete HTTP headers as you like: % cat complicated_example.eskip hostHeaderMatch: Host(\"^skipper.teapot.org$\") -> setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\") -> \"https://target-to.auth-with.basic-auth.enterprise.com\"; baiduPathMatch: Path(\"/baidu\") -> setRequestHeader(\"Host\", \"www.baidu.com\") -> setPath(\"/s\") -> setQuery(\"wd\", \"godoc skipper\") -> \"http://www.baidu.com\"; googleWildcardMatch: * -> setPath(\"/search\") -> setQuery(\"q\", \"godoc skipper\") -> \"https://www.google.com\"; yandexWildacardIfCookie: * && Cookie(\"yandex\", \"true\") -> setPath(\"/search/\") -> setQuery(\"text\", \"godoc skipper\") -> tee(\"http://127.0.0.1:12345/\") -> \"https://yandex.ru\"; The former example shows 4 routes: hostHeaderMatch, baiduPathMatch, googleWildcardMatch and yandexWildcardIfCookie. hostHeaderMatch: used if HTTP host header is exactly: \"skipper.teapot.org\", sets a Basic Authorization header and sends the modified request to https://target-to.auth-with.basic-auth.enterprise.com baiduPathMatch: used in case the request patch matches /baidu it will set the Host header to the proxy request it will set the path from /baidu to /s it will set the querystring to \"ws=godoc skipper\" and sends the modified request to http://baidu.com googleWildcardMatch: used as default if no other route matches it will set the path to /search it will set the querystring to \"q=godoc skipper\" and sends the modified request to https://www.google.com yandexWildcardIfCookie: used as default if a Cookie named \"yandex\" has the value \"true\" it will set the path to /search/ it will set the querystring to \"text=godoc skipper\" it will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix tee ) and drop the response and sends the modified request to https://yandex.ru More examples you find in eskip file format description, in filters and in predicates . Eskip file format is also used if you print your current routes in skipper, for example (metrics listener required): % curl localhost:9911/routes * -> setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -> inlineContent(\"{\\\"foo\\\": 3}\") -> <shunt>","title":"Eskip File"},{"location":"dataclients/etcd/","text":"ETCD TODO","title":"Etcd"},{"location":"dataclients/etcd/#etcd","text":"TODO","title":"ETCD"},{"location":"dataclients/innkeeper-api/","text":"Innkeeper API TODO","title":"Innkeeper API"},{"location":"dataclients/innkeeper-api/#innkeeper-api","text":"TODO","title":"Innkeeper API"},{"location":"dataclients/kubernetes/","text":"Kubernetes Skipper's Kubernetes dataclient can be used, if you want to run Skipper as kubernetes-ingress-controller . It will get it's route information from provisioned Ingress Objects . Detailed information you find in our godoc for dataclient kubernetes . Kubernetes Ingress Controller deployment How to install Skipper ingress-controller for cluster operators. Kubernetes Ingress Usage Find out more how to use Skipper ingress features for deployers. Why to choose Skipper? Kubernetes is a fast changing environment and traditional http routers are not made for frequently changing routing tables. Skipper is a http proxy made to apply updates very often. Skipper is used in production with more than 200.000 routing table entries. Skipper has Filters to change http data and Predicates to change the matching rules, both can combined and chained. You can set these in ingress.yaml files to build resiliency patterns like ratelimit or circuitbreaker. You can also use them to build more highlevel deployment patterns, for example feature toggles, shadow traffic or blue-green deployments. Skipper's main features: Filters - create, update, delete all kind of HTTP data collection of base http manipulations : for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling cookie handling circuitbreakers : consecutiveBreaker or rateBreaker ratelimit : based on client or backend data Shadow traffic: tee() Predicates - advanced matching capability URL Path match: Path(\"/foo\") Host header match: Host(\"^www.example.org$\") Querystring : QueryParam(\"featureX\") Cookie based : Cookie(\"alpha\", /^enabled$/) source whitelist : Source(\"1.2.3.4/24\") time based interval traffic by percentage supports also sticky sessions Kubernetes integration All Filters and Predicates can be used with 2 annotations Predicates: zalando.org/skipper-predicate Filters: zalando.org/skipper-filter Custom routes can be defined with the annotation zalando.org/skipper-routes metrics access logs Blue-Green deployments, with another Ingress annotation zalando.org/backend-weights","title":"Kubernetes"},{"location":"dataclients/kubernetes/#kubernetes","text":"Skipper's Kubernetes dataclient can be used, if you want to run Skipper as kubernetes-ingress-controller . It will get it's route information from provisioned Ingress Objects . Detailed information you find in our godoc for dataclient kubernetes .","title":"Kubernetes"},{"location":"dataclients/kubernetes/#kubernetes-ingress-controller-deployment","text":"How to install Skipper ingress-controller for cluster operators.","title":"Kubernetes Ingress Controller deployment"},{"location":"dataclients/kubernetes/#kubernetes-ingress-usage","text":"Find out more how to use Skipper ingress features for deployers.","title":"Kubernetes Ingress Usage"},{"location":"dataclients/kubernetes/#why-to-choose-skipper","text":"Kubernetes is a fast changing environment and traditional http routers are not made for frequently changing routing tables. Skipper is a http proxy made to apply updates very often. Skipper is used in production with more than 200.000 routing table entries. Skipper has Filters to change http data and Predicates to change the matching rules, both can combined and chained. You can set these in ingress.yaml files to build resiliency patterns like ratelimit or circuitbreaker. You can also use them to build more highlevel deployment patterns, for example feature toggles, shadow traffic or blue-green deployments. Skipper's main features: Filters - create, update, delete all kind of HTTP data collection of base http manipulations : for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling cookie handling circuitbreakers : consecutiveBreaker or rateBreaker ratelimit : based on client or backend data Shadow traffic: tee() Predicates - advanced matching capability URL Path match: Path(\"/foo\") Host header match: Host(\"^www.example.org$\") Querystring : QueryParam(\"featureX\") Cookie based : Cookie(\"alpha\", /^enabled$/) source whitelist : Source(\"1.2.3.4/24\") time based interval traffic by percentage supports also sticky sessions Kubernetes integration All Filters and Predicates can be used with 2 annotations Predicates: zalando.org/skipper-predicate Filters: zalando.org/skipper-filter Custom routes can be defined with the annotation zalando.org/skipper-routes metrics access logs Blue-Green deployments, with another Ingress annotation zalando.org/backend-weights","title":"Why to choose Skipper?"},{"location":"dataclients/route-string/","text":"Route String Route string dataclient can be used to create simple demo applications, for example if you want to show traffic switching or ratelimiting or just need to serve some json in your demo. Serve text Serve with Content-Type: text/plain; charset=utf-8 Example (Open your browser http://localhost:9090/): $ skipper -inline-routes '* -> inlineContent(\"Hello, world!\") -> <shunt>' Docker Example (Open your browser http://localhost:9090/): $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -> inlineContent(\"Hello, world!\") -> <shunt>' Serve HTML with CSS Serve with Content-Type: text/html; charset=utf-8 Example (Open your browser http://localhost:9090/): $ skipper -inline-routes '* -> inlineContent(\"<html><body style=\\\"background-color: orange;\\\"></body></html>\") -> <shunt>' Docker Example (Open your browser http://localhost:9090/): $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -> inlineContent(\"<html><body style=\\\"background-color: orange;\\\"></body></html>\") -> <shunt>' Serve JSON Serve with Content-Type: application/json; charset=utf-8 Example (Open your browser http://localhost:9090/): % skipper -inline-routes '* -> setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -> inlineContent(\"{\\\"foo\\\": 3}\") -> <shunt>' Docker Example (Open your browser http://localhost:9090/): $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -> setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -> inlineContent(\"{\\\"foo\\\": 3}\") -> <shunt>' Proxy to a given URL If you just have to build a workaround and you do not want to use socat to do a tcp proxy, but proxy http, you can do: % skipper -inline-routes '* -> \"https://my-new-backend.example.org/\"'","title":"Route String"},{"location":"dataclients/route-string/#route-string","text":"Route string dataclient can be used to create simple demo applications, for example if you want to show traffic switching or ratelimiting or just need to serve some json in your demo.","title":"Route String"},{"location":"dataclients/route-string/#serve-text","text":"Serve with Content-Type: text/plain; charset=utf-8 Example (Open your browser http://localhost:9090/): $ skipper -inline-routes '* -> inlineContent(\"Hello, world!\") -> <shunt>' Docker Example (Open your browser http://localhost:9090/): $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -> inlineContent(\"Hello, world!\") -> <shunt>'","title":"Serve text"},{"location":"dataclients/route-string/#serve-html-with-css","text":"Serve with Content-Type: text/html; charset=utf-8 Example (Open your browser http://localhost:9090/): $ skipper -inline-routes '* -> inlineContent(\"<html><body style=\\\"background-color: orange;\\\"></body></html>\") -> <shunt>' Docker Example (Open your browser http://localhost:9090/): $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -> inlineContent(\"<html><body style=\\\"background-color: orange;\\\"></body></html>\") -> <shunt>'","title":"Serve HTML with CSS"},{"location":"dataclients/route-string/#serve-json","text":"Serve with Content-Type: application/json; charset=utf-8 Example (Open your browser http://localhost:9090/): % skipper -inline-routes '* -> setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -> inlineContent(\"{\\\"foo\\\": 3}\") -> <shunt>' Docker Example (Open your browser http://localhost:9090/): $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -> setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -> inlineContent(\"{\\\"foo\\\": 3}\") -> <shunt>'","title":"Serve JSON"},{"location":"dataclients/route-string/#proxy-to-a-given-url","text":"If you just have to build a workaround and you do not want to use socat to do a tcp proxy, but proxy http, you can do: % skipper -inline-routes '* -> \"https://my-new-backend.example.org/\"'","title":"Proxy to a given URL"},{"location":"kubernetes/ingress-backends/","text":"Kubernetes Backend Deployments Kubernetes Race Condition problem As described in #652 , there is a problem that exists in Kubernetes, while terminating Pods. Terminating Pods could be graceful, but the nature of distributed environments will show failures, because not all components in the distributed system changed already their state. When a Pod terminates, the controller-manager has to update the endpoints of the Kubernetes service . Additionally Skipper has to get this endpoints list. Skipper polls the kube-apiserver every -source-poll-timeout=<ms> , which defaults to 3000. Reducing this interval or implementing watch will only reduce the timeframe, but not fix the underlying race condition. Mitigation strategies can be different and the next section document strategies for application developers to mitigate the problem. Teardown strategies An application that is target of an ingress can circumvent HTTP code 504s Gateway Timeouts with these strategies: use Pod lifecycle hooks use a SIGTERM handler to switch readinessProbe to unhealthy and exit later, or just wait for SIGKILL terminating the process. Pod Lifecycle Hooks Kubernetes Pod Lifecycle Hooks in the Pod spec can have a preStop command which executes for example a binary. The following will execute the binary sleep with argument 20 to wait 20 seconds before terminating the containers within the Pod: lifecycle: preStop: exec: command: [\"sleep\",\"20\"] 20 seconds should be enough to fade your Pod out of the endpoints list and Skipper's routing table. SIGTERM handling in Containers An application can implement a SIGTERM handler, that changes the readinessProbe target to unhealthy for the application instance. This will make sure it will be deleted from the endpoints list and from Skipper's routing table. Similar to Pod Lifecycle Hooks you could sleep 20 seconds and after that terminate your application or you just wait until SIGKILL will cleanup the instance after 60s. go func() { var sigs chan os.Signal sigs = make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGTERM) for { select { case <-sigs: healthCheck = unhealthy time.Sleep(20*time.Second) os.Exit(0) } } }()","title":"Ingress Backends"},{"location":"kubernetes/ingress-backends/#kubernetes-backend-deployments","text":"","title":"Kubernetes Backend Deployments"},{"location":"kubernetes/ingress-backends/#kubernetes-race-condition-problem","text":"As described in #652 , there is a problem that exists in Kubernetes, while terminating Pods. Terminating Pods could be graceful, but the nature of distributed environments will show failures, because not all components in the distributed system changed already their state. When a Pod terminates, the controller-manager has to update the endpoints of the Kubernetes service . Additionally Skipper has to get this endpoints list. Skipper polls the kube-apiserver every -source-poll-timeout=<ms> , which defaults to 3000. Reducing this interval or implementing watch will only reduce the timeframe, but not fix the underlying race condition. Mitigation strategies can be different and the next section document strategies for application developers to mitigate the problem.","title":"Kubernetes Race Condition problem"},{"location":"kubernetes/ingress-backends/#teardown-strategies","text":"An application that is target of an ingress can circumvent HTTP code 504s Gateway Timeouts with these strategies: use Pod lifecycle hooks use a SIGTERM handler to switch readinessProbe to unhealthy and exit later, or just wait for SIGKILL terminating the process.","title":"Teardown strategies"},{"location":"kubernetes/ingress-backends/#pod-lifecycle-hooks","text":"Kubernetes Pod Lifecycle Hooks in the Pod spec can have a preStop command which executes for example a binary. The following will execute the binary sleep with argument 20 to wait 20 seconds before terminating the containers within the Pod: lifecycle: preStop: exec: command: [\"sleep\",\"20\"] 20 seconds should be enough to fade your Pod out of the endpoints list and Skipper's routing table.","title":"Pod Lifecycle Hooks"},{"location":"kubernetes/ingress-backends/#sigterm-handling-in-containers","text":"An application can implement a SIGTERM handler, that changes the readinessProbe target to unhealthy for the application instance. This will make sure it will be deleted from the endpoints list and from Skipper's routing table. Similar to Pod Lifecycle Hooks you could sleep 20 seconds and after that terminate your application or you just wait until SIGKILL will cleanup the instance after 60s. go func() { var sigs chan os.Signal sigs = make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGTERM) for { select { case <-sigs: healthCheck = unhealthy time.Sleep(20*time.Second) os.Exit(0) } } }()","title":"SIGTERM handling in Containers"},{"location":"kubernetes/ingress-controller/","text":"Skipper Ingress Controller This documentation is meant for for cluster operators and describes how to install Skipper as Ingress-Controller into your Kubernetes Cluster. Why you should use skipper as ingress controller? Baremetal loadbalancer perform really well, but the configuration is not updated frequently and most of these installations are not meant to rapidly change. With introducing Kubernetes this will change and there is a need of rapid changing http routers. Skipper is designed for rapidly changing it's routing tree. Cloud loadbalancers are fine to scale and to change, but do not provide many features. Skipper has advanced resiliency and deployment features, that you can use to enhance your environment. For example ratelimits, circuitbreakers, blue-green deployments, shadow traffic and more . What is an Ingress-Controller? Ingress-controllers are serving http requests into a Kubernetes cluster. Most of the time traffic will pass ingress and go to a Kubernetes endpoints of the respective pods. For having a successful ingress, you need to have a DNS name pointing to some stable IP addresses that act as a loadbalancer. Skipper as ingress-controller: cloud: deploy behind the cloud loadbalancer baremetal: deploy behind your hardware/software loadbalancer and have all skipper as members in one pool. You would point your DNS entries to the loadbalancer in front of skipper, for example automated using external-dns . Why skipper uses endpoints and not services? Skipper does not use Kubernetes Services to route traffic to the pods. Instead it uses the Endpoints API to bypass kube-proxy created iptables to remove overhead like conntrack entries for iptables DNAT. Skipper can also reuse connections to Pods, such that you have no overhead in establishing connections all the time. To prevent errors on node failures, Skipper also does automatically retries to another endpoint in case it gets a connection refused or TLS handshake error to the endpoint. Other reasons are future support of features like session affinity, different loadbalancer algorithms or distributed loadbalancing also known as service mesh. AWS deployment In AWS, this could be an ALB with DNS pointing to the ALB. The ALB can then point to an ingress-controller running on an EC2 node and uses Kubernetes hostnetwork port specification in the Pod spec. A logical overview of the traffic flow in AWS is shown in this picture: We described that Skipper bypasses Kubernetes Service and use directly endpoints for good reasons , therefore the real traffic flow is shown in the next picture. Baremetal deployment In datacenter, baremetal environments, you probably have a hardware loadbalancer or some haproxy or nginx setup, that serves most of your production traffic and DNS points to these endpoints. For example *.ingress.example.com could point to your virtual server IPs in front of ingress. Skippers could be used as pool members, which do the http routing. Your loadbalancer of choice could have a wildcard certificate for *.ingress.example.com and DNS for this would point to your loadbalancer. You can also automate DNS records with external-dns , if you for example use PowerDNS as provider and have a loadbalancer controller that modifies the status field in ingress to your loadbalancer virtual IP. Requirements In general for one endpoint you need, a DNS A/AAAA record pointing to one or more loadbalancer IPs. Skipper is best used behind this layer 4 loadbalancer to route and manipulate HTTP data. minimal example: layer 4 loadbalancer has 1.2.3.4:80 as socket for a virtual server pointing to all skipper ingress *.ingress.example.com points to 1.2.3.4 ingress object with host entry for myapp.ingress.example.com targets a service type ClusterIP service type ClusterIP has a selector that targets your Pods of your myapp deployment TLS example: same as before, but you would terminate TLS on your layer 4 loadbalancer layer 4 loadbalancer has 1.2.3.4:443 as socket for a virtual server you can use an automated redirect for all port 80 requests to https with -kubernetes-https-redirect Install Skipper as ingress-controller You should have a base understanding of Kubernetes and Ingress . Prerequisites: First you have to install skipper-ingress as for example daemonset, create a deployment and a service. We start to deploy skipper-ingress as a daemonset, use hostNetwork and expose the TCP port 9999 on each Kubernetes worker node for incoming ingress traffic. % cat skipper-ingress-ds.yaml apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: skipper-ingress namespace: kube-system labels: application: skipper-ingress version: v0.10.5 component: ingress spec: selector: matchLabels: application: skipper-ingress updateStrategy: type: RollingUpdate template: metadata: name: skipper-ingress labels: application: skipper-ingress version: v0.10.5 component: ingress annotations: scheduler.alpha.kubernetes.io/critical-pod: '' spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: master operator: DoesNotExist tolerations: - key: CriticalAddonsOnly operator: Exists hostNetwork: true containers: - name: skipper-ingress image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5 ports: - name: ingress-port containerPort: 9999 hostPort: 9999 args: - \"skipper\" - \"-kubernetes\" - \"-kubernetes-in-cluster\" - \"-address=:9999\" - \"-proxy-preserve-host\" - \"-serve-host-metrics\" - \"-enable-ratelimits\" - \"-experimental-upgrade\" - \"-metrics-exp-decay-sample\" - \"-lb-healthcheck-interval=3s\" - \"-metrics-flavour=codahale,prometheus\" - \"-enable-connection-metrics\" resources: requests: cpu: 25m memory: 25Mi readinessProbe: httpGet: path: /kube-system/healthz port: 9999 initialDelaySeconds: 5 timeoutSeconds: 5 Please check, that you are using the latest release , we do not maintain the latest tag. We now deploy a simple demo application serving html: % cat demo-deployment.yaml apiVersion: apps/v1beta1 kind: Deployment metadata: name: skipper-demo spec: replicas: 2 template: metadata: labels: application: skipper-demo spec: containers: - name: skipper-demo image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5 args: - \"skipper\" - \"-inline-routes\" - \"* -> inlineContent(\\\"<body style='color: white; background-color: green;'><h1>Hello!</h1>\\\") -> <shunt>\" ports: - containerPort: 9090 We deploy a service type ClusterIP that we will select from ingress: % cat demo-svc.yaml apiVersion: v1 kind: Service metadata: name: skipper-demo labels: application: skipper-demo spec: type: ClusterIP ports: - port: 80 protocol: TCP targetPort: 9090 name: external selector: application: skipper-demo To deploy both, you have to run: % kubectl create -f demo-deployment.yaml % kubectl create -f demo-svc.yaml Now we have a skipper-ingress running as daemonset exposing the TCP port 9999 on each worker node, a backend application running with 2 replicas that serves some html on TCP port 9090, and we expose a cluster service on TCP port 80. Besides skipper-ingress, deployment and service can not be reached from outside the cluster. Now we expose the application with Ingress to the external network: % cat demo-ing.yaml apiVersion: extensions/v1beta1 kind: Ingress metadata: name: skipper-demo spec: rules: - host: skipper-demo.<mydomain.org> http: paths: - backend: serviceName: skipper-demo servicePort: 80 To deploy this ingress, you have to run: % kubectl create -f demo-ing.yaml Skipper will configure itself for the given ingress, such that you can test doing: % curl -v -H\"Host: skipper-demo.<mydomain.org>\" http://<nodeip>:9999/ The next question you may ask is: how to expose this to your customers? The answer depends on your setup and complexity requirements. In the simplest case you could add one A record in your DNS *.<mydomain.org> to your frontend loadbalancer IP that directs all traffic from *.<mydomain.org> to all Kubernetes worker nodes on TCP port 9999. A more complex setup we use in production and can be done with something that configures your frontend loadbalancer, for example kube-aws-ingress-controller , and your DNS, external-dns automatically. Multiple skipper deployments If you want to split for example internal and public traffic, it might be a good choice to split your ingress deployments. Skipper has the flag --kubernetes-ingress-class=<string> to only select ingress objects that have the annotation kubernetes.io/ingress.class set to <string> . Skipper will only create routes for ingress objects with it's annotation or ingress objects that do not have this annotation. The default ingress class is skipper , if not set. You have to create your ingress objects with the annotation kubernetes.io/ingress.class: skipper to make sure only skipper will serve the traffic. Example ingress: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: skipper name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Scoping Skipper Deployments to a Single Namespace In some instances you might want skipper to only watch for ingress objects created in a single namespace. This can be achieved by using kubernetes-namespace=<string> where <string> is the Kubernetes namespace. Specifying this option forces Skipper to look at the namespace ingresses endpoint rather than the cluster-wide ingresses endpoint. By default this value is an empty string ( \"\" ) and will scope the skipper instance to be cluster-wide, watching all Ingress objects across all namespaces. Install Skipper with enabled RBAC If Role-Based Access Control (\"RBAC\") is enabled you have to create some additional resources to enable Skipper to query the Kubernetes API. This guide describes all necessary resources to get Skipper up and running in a Kubernetes cluster with RBAC enabled but it's highly recommended to read the RBAC docs to get a better understanding which permissions are delegated to Skipper within your Kubernetes cluster. First create a new ServiceAccount which will be assigned to the Skipper pods: apiVersion: v1 kind: ServiceAccount metadata: name: skipper-ingress namespace: kube-system the required permissions are defined within a ClusterRole resource. Note: It's important to use a ClusterRole instead of normal Role because otherwise Skipper could only access resources in the namespace the Role was created! ClusterRole: apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: name: skipper-ingress rules: - apiGroups: [\"extensions\"] resources: [\"ingresses\", ] verbs: [\"get\", \"list\"] - apiGroups: [\"\"] resources: [\"namespaces\", \"services\", \"endpoints\"] verbs: [\"get\"] This ClusterRole defines access to get and list all created ingresses, namespaces, services and endpoints. To assign the defined ClusterRole to the previously created ServiceAccount a ClusterRoleBinding has to be created: ClusterRoleBinding: apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: skipper-ingress roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: skipper-ingress subjects: - kind: ServiceAccount name: skipper-ingress namespace: kube-system Last but not least the ServiceAccount has to be assigned to the Skipper daemonset. daemonset: apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: skipper-ingress namespace: kube-system labels: component: ingress spec: selector: matchLabels: component: ingress updateStrategy: type: RollingUpdate template: metadata: name: skipper-ingress labels: component: ingress application: skipper spec: hostNetwork: true serviceAccountName: skipper-ingress containers: - name: skipper-ingress image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5 ports: - name: ingress-port containerPort: 9999 hostPort: 9999 - name: metrics-port containerPort: 9911 args: - \"skipper\" - \"-kubernetes\" - \"-kubernetes-in-cluster\" - \"-address=:9999\" - \"-proxy-preserve-host\" - \"-serve-host-metrics\" - \"-enable-ratelimits\" - \"-experimental-upgrade\" - \"-metrics-exp-decay-sample\" - \"-lb-healthcheck-interval=3s\" - \"-metrics-flavour=codahale,prometheus\" - \"-enable-connection-metrics\" resources: requests: cpu: 200m memory: 200Mi readinessProbe: httpGet: path: /kube-system/healthz port: 9999 initialDelaySeconds: 5 timeoutSeconds: 5 Please check, that you are using the latest release , we do not maintain the latest tag. Helm-based deployment Helm calls itself the package manager for Kubernetes and therefore take cares of the deployment of whole applications including resources like services, configurations and so on. Skipper is also available as community contributed Helm chart in the public quay.io registry. The latest packaged release can be found here . The source code is available at GitHub . The chart includes resource definitions for the following use cases: RBAC CoreOS Prometheus-Operator As this chart is not maintained by the Skipper developers and is still under development only the basic deployment workflow is covered here. Check the GitHub repository for all details. To be able to deploy the chart you will need the following components: helm CLI (Install guide here ) Helm registry plugin (available here ) If your environment is setup correctly you should be able to run helm version --client and helm registry version quay.io and get some information about your tooling without any error. It is possible to deploy the chart without any further configuration like this: helm registry upgrade quay.io/baez/skipper -- \\ --install \\ --wait \\ \"<your release name e.g. skipper>\" The --wait switch can be omitted as it only takes care that Helm is waiting until the chart is completely deployed (meaning all resources are created). To update the deployment to a newer version the same command can be used. If you have RBAC enabled in your Kubernetes instance you don't have to create all the previously described resources on your own but you can let Helm create them by simply adding one more switch: helm registry upgrade quay.io/baez/skipper -- \\ --install \\ --wait \\ --set rbac.create=true \\ \"<your release name e.g. skipper>\" There are some more options available for customization of the chart. Check the repository if you need more configuration possibilities.","title":"Ingress Controller Deployment"},{"location":"kubernetes/ingress-controller/#skipper-ingress-controller","text":"This documentation is meant for for cluster operators and describes how to install Skipper as Ingress-Controller into your Kubernetes Cluster.","title":"Skipper Ingress Controller"},{"location":"kubernetes/ingress-controller/#why-you-should-use-skipper-as-ingress-controller","text":"Baremetal loadbalancer perform really well, but the configuration is not updated frequently and most of these installations are not meant to rapidly change. With introducing Kubernetes this will change and there is a need of rapid changing http routers. Skipper is designed for rapidly changing it's routing tree. Cloud loadbalancers are fine to scale and to change, but do not provide many features. Skipper has advanced resiliency and deployment features, that you can use to enhance your environment. For example ratelimits, circuitbreakers, blue-green deployments, shadow traffic and more .","title":"Why you should use skipper as ingress controller?"},{"location":"kubernetes/ingress-controller/#what-is-an-ingress-controller","text":"Ingress-controllers are serving http requests into a Kubernetes cluster. Most of the time traffic will pass ingress and go to a Kubernetes endpoints of the respective pods. For having a successful ingress, you need to have a DNS name pointing to some stable IP addresses that act as a loadbalancer. Skipper as ingress-controller: cloud: deploy behind the cloud loadbalancer baremetal: deploy behind your hardware/software loadbalancer and have all skipper as members in one pool. You would point your DNS entries to the loadbalancer in front of skipper, for example automated using external-dns .","title":"What is an Ingress-Controller?"},{"location":"kubernetes/ingress-controller/#why-skipper-uses-endpoints-and-not-services","text":"Skipper does not use Kubernetes Services to route traffic to the pods. Instead it uses the Endpoints API to bypass kube-proxy created iptables to remove overhead like conntrack entries for iptables DNAT. Skipper can also reuse connections to Pods, such that you have no overhead in establishing connections all the time. To prevent errors on node failures, Skipper also does automatically retries to another endpoint in case it gets a connection refused or TLS handshake error to the endpoint. Other reasons are future support of features like session affinity, different loadbalancer algorithms or distributed loadbalancing also known as service mesh.","title":"Why skipper uses endpoints and not services?"},{"location":"kubernetes/ingress-controller/#aws-deployment","text":"In AWS, this could be an ALB with DNS pointing to the ALB. The ALB can then point to an ingress-controller running on an EC2 node and uses Kubernetes hostnetwork port specification in the Pod spec. A logical overview of the traffic flow in AWS is shown in this picture: We described that Skipper bypasses Kubernetes Service and use directly endpoints for good reasons , therefore the real traffic flow is shown in the next picture.","title":"AWS deployment"},{"location":"kubernetes/ingress-controller/#baremetal-deployment","text":"In datacenter, baremetal environments, you probably have a hardware loadbalancer or some haproxy or nginx setup, that serves most of your production traffic and DNS points to these endpoints. For example *.ingress.example.com could point to your virtual server IPs in front of ingress. Skippers could be used as pool members, which do the http routing. Your loadbalancer of choice could have a wildcard certificate for *.ingress.example.com and DNS for this would point to your loadbalancer. You can also automate DNS records with external-dns , if you for example use PowerDNS as provider and have a loadbalancer controller that modifies the status field in ingress to your loadbalancer virtual IP.","title":"Baremetal deployment"},{"location":"kubernetes/ingress-controller/#requirements","text":"In general for one endpoint you need, a DNS A/AAAA record pointing to one or more loadbalancer IPs. Skipper is best used behind this layer 4 loadbalancer to route and manipulate HTTP data. minimal example: layer 4 loadbalancer has 1.2.3.4:80 as socket for a virtual server pointing to all skipper ingress *.ingress.example.com points to 1.2.3.4 ingress object with host entry for myapp.ingress.example.com targets a service type ClusterIP service type ClusterIP has a selector that targets your Pods of your myapp deployment TLS example: same as before, but you would terminate TLS on your layer 4 loadbalancer layer 4 loadbalancer has 1.2.3.4:443 as socket for a virtual server you can use an automated redirect for all port 80 requests to https with -kubernetes-https-redirect","title":"Requirements"},{"location":"kubernetes/ingress-controller/#install-skipper-as-ingress-controller","text":"You should have a base understanding of Kubernetes and Ingress . Prerequisites: First you have to install skipper-ingress as for example daemonset, create a deployment and a service. We start to deploy skipper-ingress as a daemonset, use hostNetwork and expose the TCP port 9999 on each Kubernetes worker node for incoming ingress traffic. % cat skipper-ingress-ds.yaml apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: skipper-ingress namespace: kube-system labels: application: skipper-ingress version: v0.10.5 component: ingress spec: selector: matchLabels: application: skipper-ingress updateStrategy: type: RollingUpdate template: metadata: name: skipper-ingress labels: application: skipper-ingress version: v0.10.5 component: ingress annotations: scheduler.alpha.kubernetes.io/critical-pod: '' spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: master operator: DoesNotExist tolerations: - key: CriticalAddonsOnly operator: Exists hostNetwork: true containers: - name: skipper-ingress image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5 ports: - name: ingress-port containerPort: 9999 hostPort: 9999 args: - \"skipper\" - \"-kubernetes\" - \"-kubernetes-in-cluster\" - \"-address=:9999\" - \"-proxy-preserve-host\" - \"-serve-host-metrics\" - \"-enable-ratelimits\" - \"-experimental-upgrade\" - \"-metrics-exp-decay-sample\" - \"-lb-healthcheck-interval=3s\" - \"-metrics-flavour=codahale,prometheus\" - \"-enable-connection-metrics\" resources: requests: cpu: 25m memory: 25Mi readinessProbe: httpGet: path: /kube-system/healthz port: 9999 initialDelaySeconds: 5 timeoutSeconds: 5 Please check, that you are using the latest release , we do not maintain the latest tag. We now deploy a simple demo application serving html: % cat demo-deployment.yaml apiVersion: apps/v1beta1 kind: Deployment metadata: name: skipper-demo spec: replicas: 2 template: metadata: labels: application: skipper-demo spec: containers: - name: skipper-demo image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5 args: - \"skipper\" - \"-inline-routes\" - \"* -> inlineContent(\\\"<body style='color: white; background-color: green;'><h1>Hello!</h1>\\\") -> <shunt>\" ports: - containerPort: 9090 We deploy a service type ClusterIP that we will select from ingress: % cat demo-svc.yaml apiVersion: v1 kind: Service metadata: name: skipper-demo labels: application: skipper-demo spec: type: ClusterIP ports: - port: 80 protocol: TCP targetPort: 9090 name: external selector: application: skipper-demo To deploy both, you have to run: % kubectl create -f demo-deployment.yaml % kubectl create -f demo-svc.yaml Now we have a skipper-ingress running as daemonset exposing the TCP port 9999 on each worker node, a backend application running with 2 replicas that serves some html on TCP port 9090, and we expose a cluster service on TCP port 80. Besides skipper-ingress, deployment and service can not be reached from outside the cluster. Now we expose the application with Ingress to the external network: % cat demo-ing.yaml apiVersion: extensions/v1beta1 kind: Ingress metadata: name: skipper-demo spec: rules: - host: skipper-demo.<mydomain.org> http: paths: - backend: serviceName: skipper-demo servicePort: 80 To deploy this ingress, you have to run: % kubectl create -f demo-ing.yaml Skipper will configure itself for the given ingress, such that you can test doing: % curl -v -H\"Host: skipper-demo.<mydomain.org>\" http://<nodeip>:9999/ The next question you may ask is: how to expose this to your customers? The answer depends on your setup and complexity requirements. In the simplest case you could add one A record in your DNS *.<mydomain.org> to your frontend loadbalancer IP that directs all traffic from *.<mydomain.org> to all Kubernetes worker nodes on TCP port 9999. A more complex setup we use in production and can be done with something that configures your frontend loadbalancer, for example kube-aws-ingress-controller , and your DNS, external-dns automatically.","title":"Install Skipper as ingress-controller"},{"location":"kubernetes/ingress-controller/#multiple-skipper-deployments","text":"If you want to split for example internal and public traffic, it might be a good choice to split your ingress deployments. Skipper has the flag --kubernetes-ingress-class=<string> to only select ingress objects that have the annotation kubernetes.io/ingress.class set to <string> . Skipper will only create routes for ingress objects with it's annotation or ingress objects that do not have this annotation. The default ingress class is skipper , if not set. You have to create your ingress objects with the annotation kubernetes.io/ingress.class: skipper to make sure only skipper will serve the traffic. Example ingress: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: skipper name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Multiple skipper deployments"},{"location":"kubernetes/ingress-controller/#scoping-skipper-deployments-to-a-single-namespace","text":"In some instances you might want skipper to only watch for ingress objects created in a single namespace. This can be achieved by using kubernetes-namespace=<string> where <string> is the Kubernetes namespace. Specifying this option forces Skipper to look at the namespace ingresses endpoint rather than the cluster-wide ingresses endpoint. By default this value is an empty string ( \"\" ) and will scope the skipper instance to be cluster-wide, watching all Ingress objects across all namespaces.","title":"Scoping Skipper Deployments to a Single Namespace"},{"location":"kubernetes/ingress-controller/#install-skipper-with-enabled-rbac","text":"If Role-Based Access Control (\"RBAC\") is enabled you have to create some additional resources to enable Skipper to query the Kubernetes API. This guide describes all necessary resources to get Skipper up and running in a Kubernetes cluster with RBAC enabled but it's highly recommended to read the RBAC docs to get a better understanding which permissions are delegated to Skipper within your Kubernetes cluster. First create a new ServiceAccount which will be assigned to the Skipper pods: apiVersion: v1 kind: ServiceAccount metadata: name: skipper-ingress namespace: kube-system the required permissions are defined within a ClusterRole resource. Note: It's important to use a ClusterRole instead of normal Role because otherwise Skipper could only access resources in the namespace the Role was created! ClusterRole: apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: name: skipper-ingress rules: - apiGroups: [\"extensions\"] resources: [\"ingresses\", ] verbs: [\"get\", \"list\"] - apiGroups: [\"\"] resources: [\"namespaces\", \"services\", \"endpoints\"] verbs: [\"get\"] This ClusterRole defines access to get and list all created ingresses, namespaces, services and endpoints. To assign the defined ClusterRole to the previously created ServiceAccount a ClusterRoleBinding has to be created: ClusterRoleBinding: apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: skipper-ingress roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: skipper-ingress subjects: - kind: ServiceAccount name: skipper-ingress namespace: kube-system Last but not least the ServiceAccount has to be assigned to the Skipper daemonset. daemonset: apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: skipper-ingress namespace: kube-system labels: component: ingress spec: selector: matchLabels: component: ingress updateStrategy: type: RollingUpdate template: metadata: name: skipper-ingress labels: component: ingress application: skipper spec: hostNetwork: true serviceAccountName: skipper-ingress containers: - name: skipper-ingress image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5 ports: - name: ingress-port containerPort: 9999 hostPort: 9999 - name: metrics-port containerPort: 9911 args: - \"skipper\" - \"-kubernetes\" - \"-kubernetes-in-cluster\" - \"-address=:9999\" - \"-proxy-preserve-host\" - \"-serve-host-metrics\" - \"-enable-ratelimits\" - \"-experimental-upgrade\" - \"-metrics-exp-decay-sample\" - \"-lb-healthcheck-interval=3s\" - \"-metrics-flavour=codahale,prometheus\" - \"-enable-connection-metrics\" resources: requests: cpu: 200m memory: 200Mi readinessProbe: httpGet: path: /kube-system/healthz port: 9999 initialDelaySeconds: 5 timeoutSeconds: 5 Please check, that you are using the latest release , we do not maintain the latest tag.","title":"Install Skipper with enabled RBAC"},{"location":"kubernetes/ingress-controller/#helm-based-deployment","text":"Helm calls itself the package manager for Kubernetes and therefore take cares of the deployment of whole applications including resources like services, configurations and so on. Skipper is also available as community contributed Helm chart in the public quay.io registry. The latest packaged release can be found here . The source code is available at GitHub . The chart includes resource definitions for the following use cases: RBAC CoreOS Prometheus-Operator As this chart is not maintained by the Skipper developers and is still under development only the basic deployment workflow is covered here. Check the GitHub repository for all details. To be able to deploy the chart you will need the following components: helm CLI (Install guide here ) Helm registry plugin (available here ) If your environment is setup correctly you should be able to run helm version --client and helm registry version quay.io and get some information about your tooling without any error. It is possible to deploy the chart without any further configuration like this: helm registry upgrade quay.io/baez/skipper -- \\ --install \\ --wait \\ \"<your release name e.g. skipper>\" The --wait switch can be omitted as it only takes care that Helm is waiting until the chart is completely deployed (meaning all resources are created). To update the deployment to a newer version the same command can be used. If you have RBAC enabled in your Kubernetes instance you don't have to create all the previously described resources on your own but you can let Helm create them by simply adding one more switch: helm registry upgrade quay.io/baez/skipper -- \\ --install \\ --wait \\ --set rbac.create=true \\ \"<your release name e.g. skipper>\" There are some more options available for customization of the chart. Check the repository if you need more configuration possibilities.","title":"Helm-based deployment"},{"location":"kubernetes/ingress-usage/","text":"Skipper Ingress Usage This documentation is meant for people deploying to Kubernetes Clusters and describes to use Ingress and low level and high level features Skipper provides Skipper Ingress Annotations Annotation example data usage zalando.org/backend-weights {\"my-app-1\": 80, \"my-app-2\": 20} blue-green deployments zalando.org/skipper-filter consecutiveBreaker(15) arbitrary filters zalando.org/skipper-predicate QueryParam(\"version\", \"^alpha$\") arbitrary predicates zalando.org/skipper-routes Method(\"OPTIONS\") -> status(200) -> <shunt> extra custom routes zalando.org/ratelimit ratelimit(50, \"1m\") deprecated, use zalando.org/skipper-filter instead Supported Service types Ingress backend definitions are services, which have different service types . Service type supported workaround ClusterIP yes --- NodePort yes --- ExternalName no, related issue use deployment with routestring LoadBalancer no it should not, because Kubernetes cloud-controller-manager will maintain it Basics HTTP Host header routing HTTP host header is defined within the rules host section and this route will match by http Host: app-default.example.org and route to endpoints selected by the Kubernetes service app-svc on port 80 . apiVersion: extensions/v1beta1 kind: Ingress metadata: name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 To have 2 routes with different Host headers serving the same backends, you have to specify 2 entries in the rules section, as Kubernetes defined the ingress spec. This is often used in cases of migrations from one domain to another one or migrations to or from bare metal datacenters to cloud providers or inter cloud or intra cloud providers migrations. Examples are AWS account migration, AWS to GCP migration, GCP to bare metal migration or bare metal to Alibaba Cloud migration. apiVersion: extensions/v1beta1 kind: Ingress metadata: name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 - host: foo.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Ingress path handling Ingress paths can be interpreted in four different modes: based on the kubernetes ingress specification as plain regular expression as a path prefix The default is the kubernetes ingress mode. It can be changed by a startup option to any of the other modes, and the individual ingress rules can also override the default behavior with the zalando.org/skipper-ingress-path-mode annotation. E.g.: zalando.org/skipper-ingress-path-mode: path-prefix Kubernetes ingress specification base path By default, the ingress path is interpreted as a regular expression with a mandatory leading \"/\", and is automatically prepended by a \"^\" control character, enforcing that the path has to be at the start of the incoming request path. Plain regular expression When the path mode is set to \"path-regexp\", the ingress path is interpreted similar to the default kubernetes ingress specification way, but is not prepended by the \"^\" control character. Path prefix When the path mode is set to \"path-prefix\", the ingress path is not a regular expression. As an example, \"/foo/bar\" will match \"/foo/bar\" or \"/foo/bar/baz\", but won't match \"/foo/barooz\". When PathPrefix is used, the path matching becomes deterministic when a request could match more than one ingress routes otherwise. In PathPrefix mode, when a Path or PathSubtree predicate is set in an annotation, the predicate in the annotation takes precedence over the normal ingress path. Filters and Predicates Filters can manipulate http data, which is not possible in the ingress spec. Predicates change the route matching, beyond normal ingress definitions This example shows how to add predicates and filters: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: predicate1 && predicate2 && .. && predicateN zalando.org/skipper-filter: filter1 -> filter2 -> .. -> filterN name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Custom Routes Custom routes is a way of extending the default routes configured for an ingress resource. Sometimes you just want to return a header, redirect or even static html content. You can return from skipper without doing a proxy call to a backend, if you end your filter chain with <shunt> . The use of <shunt> recommends the use in combination with status() filter, to not respond with the default http code, which defaults to 404. To match your custom route with higher priority than your ingress you also have to add another predicate, for example the Method(\"GET\") predicate to match the route with higher priority. Custom routes specified in ingress will always add the Host() predicate to match the host header specified in the ingress rules: . If there is a path: definition in your ingress, then it will be based on the skipper command line parameter -kubernetes-path-mode set one of theses predicates: Path() PathSubtree() PathRegexp() Return static content The following example sets a response header X: bar , a response body <html><body>hello</body></html> and respond from the ingress directly with a HTTP status code 200: zalando.org/skipper-routes: | Path(\"/\") -> setResponseHeader(\"X\", \"bar\") -> inlineContent(\"<html><body>hello</body></html>\") -> status(200) -> <shunt> Keep in mind that you need a valid backend definition to backends which are available, otherwise Skipper would not accept the entire route definition from the ingress object for safety reasons. CORS example This example shows how to add a custom route for handling OPTIONS requests. apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-routes: | Method(\"OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Origin\", \"*\") -> setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\") -> status(200) -> <shunt> name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 This will generate a custom route for the ingress which looks like this: Host(/^app-default[.]example[.]org$/) && Method(\"OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Origin\", \"*\") -> setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\") -> status(200) -> <shunt> Multiple routes You can also set multiple routes, but you have to set the names of the route as defined in eskip: zalando.org/skipper-routes: | routename1: Path(\"/\") -> localRatelimit(2, \"1h\") -> inlineContent(\"A\") -> status(200) -> <shunt>; routename2: Path(\"/foo\") -> localRatelimit(5, \"1h\") -> inlineContent(\"B\") -> status(200) -> <shunt>; Make sure the ; semicolon is used to terminate the routes, if you use multiple routes definitions. Filters - Basic HTTP manipulations HTTP manipulations are done by using skipper filters. Changes can be done in the request path, meaning request to your backend or in the response path to the client, which made the request. The following examples can be used within zalando.org/skipper-filter annotation. Add a request Header Add a HTTP header in the request path to your backend. setRequestHeader(\"X-Foo\", \"bar\") Add a response Header Add a HTTP header in the response path of your clients. setResponseHeader(\"X-Foo\", \"bar\") Enable gzip Compress responses with gzip. compress() // compress all valid MIME types compress(\"text/html\") // only compress HTML files compress(9, \"text/html\") // control the level of compression, 1 = fastest, 9 = best compression, 0 = no compression Set the Path Change the path in the request path to your backend to /newPath/ . setPath(\"/newPath/\") Modify Path Modify the path in the request path from /api/foo to your backend to /foo . modPath(\"^/api/\", \"/\") Set the Querystring Set the Querystring in the request path to your backend to ?text=godoc%20skipper . setQuery(\"text\", \"godoc skipper\") Redirect Create a redirect with HTTP code 301 to https://foo.example.org/. redirectTo(301, \"https://foo.example.org/\") Cookies Set a Cookie in the request path to your backend. requestCookie(\"test-session\", \"abc\") Set a Cookie in the response path of your clients. responseCookie(\"test-session\", \"abc\", 31536000) responseCookie(\"test-session\", \"abc\", 31536000, \"change-only\") // response cookie without HttpOnly: jsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\") Authorization Our filter auth godoc shows how to use filters for authorization. Basic Auth % htpasswd -nbm myName myPassword basicAuth(\"/path/to/htpasswd\") basicAuth(\"/path/to/htpasswd\", \"My Website\") Bearer Token (OAuth/JWT) OAuth2/JWT tokens can be validated and allowed based on different content of the token. Please check the filter documentation for that: oauthTokeninfoAnyScope oauthTokeninfoAllScope oauthTokeninfoAnyKV oauthTokeninfoAllKV There are also auth predicates , which will allow you to match a route based on the content of a token: JWTPayloadAnyKV() JWTPayloadAllKV() These are not validating the tokens, which should be done separately by the filters mentioned above. Diagnosis - Throttling Bandwidth - Latency For diagnosis purpose there are filters that enable you to throttle the bandwidth or add latency. For the full list of filters see our diag filter godoc page . bandwidth(30) // incoming in kb/s backendBandwidth(30) // outgoing in kb/s backendLatency(120) // in ms Flow Id to trace request flows To trace request flows skipper can generate a unique Flow Id for every HTTP request that it receives. You can then find the trace of the request in all your access logs. Skipper sets the X-Flow-Id header to a unique value. Read more about this in our flowid filter godoc . flowId(\"reuse\") Filters - reliability features Filters can modify http requests and responses. There are plenty of things you can do with them. Circuitbreaker Consecutive Breaker The consecutiveBreaker filter is a breaker for the ingress route that open if the backend failures for the route reach a value of N (in this example N=15), where N is a mandatory argument of the filter and there are some more optional arguments documented : consecutiveBreaker(15) The ingress spec would look like this: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: consecutiveBreaker(15) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Rate Breaker The rateBreaker filter is a breaker for the ingress route that open if the backend failures for the route reach a value of N within a window of the last M requests, where N (in this example 30) and M (in this example 300) are mandatory arguments of the filter and there are some more optional arguments documented . rateBreaker(30, 300) The ingress spec would look like this: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: rateBreaker(30, 300) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Ratelimits There are two kind of ratelimits: Client side ratelimits are used to slow down login enumeration attacks, that targets your login pages. This is a security protection for DDOS or login attacks. Service or backend side ratelimits are used to protect your services due too much traffic. This can be used in an emergency situation to make sure you calm down ingress traffic or in general if you know how much calls per duration your backend is able to handle. Ratelimits are enforced per route. More details you will find in ratelimit package and Kubernetes dataclient documentation. Client Ratelimits The example shows 20 calls per hour per client, based on X-Forwarded-For header or IP incase there is no X-Forwarded-For header set, are allowed to each skipper instance for the given ingress. apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: localRatelimit(20, \"1h\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 If you need to rate limit service to service communication and you use Authorization headers to protect your backend from your clients, then you can pass a 3 parameter to group clients by \"Authorization Header\": apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Service Ratelimits The example shows 50 calls per minute are allowed to each skipper instance for the given ingress. apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: ratelimit(50, \"1m\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Shadow Traffic If you want to test a new replacement of a production service with production load, you can copy incoming requests to your new endpoint and ignore the responses from your new backend. This can be done by the tee() and teenf() filters . apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: teenf(\"https://app-new.example.org\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 Predicates Predicates are influencing the route matching, which you might want to carefully test before using it in production. This enables you to do feature toggles or time based enabling endpoints. You can use all kinds of predicates with filters together. Feature Toggle Feature toggles are often implemented as query string to select a new feature. Normally you would have to implement this in your application, but Skipper can help you with that and you can select routes with an ingress definition. You create 2 ingresses that matches the same route, here host header match to app-default.example.org and one ingress has a defined query parameter to select the route to the alpha version deployment. If the query string in the URL has version=alpha set, for example https://app-default.example.org/mypath?version=alpha , the service alpha-svc will get the traffic, if not prod-svc . alpha-svc: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\") name: alpha-app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: alpha-svc servicePort: 80 prod-svc: apiVersion: extensions/v1beta1 kind: Ingress metadata: name: prod-app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: prod-svc servicePort: 80 IP Whitelisting This ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17 apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 A/B test Implementing A/B testing is heavy. Skipper can help you to do that. You need to have a traffic split somewhere and have your customers sticky to either A or B flavor of your application. Most likely people would implement using cookies. Skipper can set a cookie with responseCookie() in a response to the client and the cookie predicate can be used to match the route based on the cookie. Like this you can have sticky sessions to either A or B for your clients. This example shows to have 10% traffic using A and the rest using B. 10% choice of setting the Cookie \"flavor\" to \"A\": apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Traffic(.1) zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: a-app-svc servicePort: 80 Rest is setting Cookie \"flavor\" to \"B\": apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: b-app-svc servicePort: 80 To be sticky, you have to create 2 ingress with predicate to match routes with the cookie we set before. For \"A\" this would be: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: a-app-svc servicePort: 80 For \"B\" this would be: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: b-app-svc servicePort: 80 Blue-Green deployments To do blue-green deployments you have to have control over traffic switching. Skipper gives you the opportunity to set weights to backend services in your ingress specification. zalando.org/backend-weights is a hash map, which key relates to the serviceName of the backend and the value is the weight of traffic you want to send to the particular backend. It works for more than 2 backends, but for simplicity this example shows 2 backends, which should be the default case for supporting blue-green deployments. In the following example my-app-1 service will get 80% of the traffic and my-app-2 will get 20% of the traffic: apiVersion: extensions/v1beta1 kind: Ingress metadata: name: my-app labels: application: my-app annotations: zalando.org/backend-weights: | {\"my-app-1\": 80, \"my-app-2\": 20} spec: rules: - host: my-app.example.org http: paths: - backend: serviceName: my-app-1 servicePort: http path: / - backend: serviceName: my-app-2 servicePort: http path: / Chaining Filters and Predicates You can set multiple filters in a chain similar to the eskip format . apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) && Source(\"1.2.3.0/24\", \"195.168.0.0/17\") zalando.org/skipper-filter: localRatelimit(50, \"10m\") -> requestCookie(\"test-session\", \"abc\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Ingress Usage"},{"location":"kubernetes/ingress-usage/#skipper-ingress-usage","text":"This documentation is meant for people deploying to Kubernetes Clusters and describes to use Ingress and low level and high level features Skipper provides","title":"Skipper Ingress Usage"},{"location":"kubernetes/ingress-usage/#skipper-ingress-annotations","text":"Annotation example data usage zalando.org/backend-weights {\"my-app-1\": 80, \"my-app-2\": 20} blue-green deployments zalando.org/skipper-filter consecutiveBreaker(15) arbitrary filters zalando.org/skipper-predicate QueryParam(\"version\", \"^alpha$\") arbitrary predicates zalando.org/skipper-routes Method(\"OPTIONS\") -> status(200) -> <shunt> extra custom routes zalando.org/ratelimit ratelimit(50, \"1m\") deprecated, use zalando.org/skipper-filter instead","title":"Skipper Ingress Annotations"},{"location":"kubernetes/ingress-usage/#supported-service-types","text":"Ingress backend definitions are services, which have different service types . Service type supported workaround ClusterIP yes --- NodePort yes --- ExternalName no, related issue use deployment with routestring LoadBalancer no it should not, because Kubernetes cloud-controller-manager will maintain it","title":"Supported Service types"},{"location":"kubernetes/ingress-usage/#basics","text":"","title":"Basics"},{"location":"kubernetes/ingress-usage/#http-host-header-routing","text":"HTTP host header is defined within the rules host section and this route will match by http Host: app-default.example.org and route to endpoints selected by the Kubernetes service app-svc on port 80 . apiVersion: extensions/v1beta1 kind: Ingress metadata: name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 To have 2 routes with different Host headers serving the same backends, you have to specify 2 entries in the rules section, as Kubernetes defined the ingress spec. This is often used in cases of migrations from one domain to another one or migrations to or from bare metal datacenters to cloud providers or inter cloud or intra cloud providers migrations. Examples are AWS account migration, AWS to GCP migration, GCP to bare metal migration or bare metal to Alibaba Cloud migration. apiVersion: extensions/v1beta1 kind: Ingress metadata: name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 - host: foo.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"HTTP Host header routing"},{"location":"kubernetes/ingress-usage/#ingress-path-handling","text":"Ingress paths can be interpreted in four different modes: based on the kubernetes ingress specification as plain regular expression as a path prefix The default is the kubernetes ingress mode. It can be changed by a startup option to any of the other modes, and the individual ingress rules can also override the default behavior with the zalando.org/skipper-ingress-path-mode annotation. E.g.: zalando.org/skipper-ingress-path-mode: path-prefix","title":"Ingress path handling"},{"location":"kubernetes/ingress-usage/#kubernetes-ingress-specification-base-path","text":"By default, the ingress path is interpreted as a regular expression with a mandatory leading \"/\", and is automatically prepended by a \"^\" control character, enforcing that the path has to be at the start of the incoming request path.","title":"Kubernetes ingress specification base path"},{"location":"kubernetes/ingress-usage/#plain-regular-expression","text":"When the path mode is set to \"path-regexp\", the ingress path is interpreted similar to the default kubernetes ingress specification way, but is not prepended by the \"^\" control character.","title":"Plain regular expression"},{"location":"kubernetes/ingress-usage/#path-prefix","text":"When the path mode is set to \"path-prefix\", the ingress path is not a regular expression. As an example, \"/foo/bar\" will match \"/foo/bar\" or \"/foo/bar/baz\", but won't match \"/foo/barooz\". When PathPrefix is used, the path matching becomes deterministic when a request could match more than one ingress routes otherwise. In PathPrefix mode, when a Path or PathSubtree predicate is set in an annotation, the predicate in the annotation takes precedence over the normal ingress path.","title":"Path prefix"},{"location":"kubernetes/ingress-usage/#filters-and-predicates","text":"Filters can manipulate http data, which is not possible in the ingress spec. Predicates change the route matching, beyond normal ingress definitions This example shows how to add predicates and filters: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: predicate1 && predicate2 && .. && predicateN zalando.org/skipper-filter: filter1 -> filter2 -> .. -> filterN name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Filters and Predicates"},{"location":"kubernetes/ingress-usage/#custom-routes","text":"Custom routes is a way of extending the default routes configured for an ingress resource. Sometimes you just want to return a header, redirect or even static html content. You can return from skipper without doing a proxy call to a backend, if you end your filter chain with <shunt> . The use of <shunt> recommends the use in combination with status() filter, to not respond with the default http code, which defaults to 404. To match your custom route with higher priority than your ingress you also have to add another predicate, for example the Method(\"GET\") predicate to match the route with higher priority. Custom routes specified in ingress will always add the Host() predicate to match the host header specified in the ingress rules: . If there is a path: definition in your ingress, then it will be based on the skipper command line parameter -kubernetes-path-mode set one of theses predicates: Path() PathSubtree() PathRegexp()","title":"Custom Routes"},{"location":"kubernetes/ingress-usage/#return-static-content","text":"The following example sets a response header X: bar , a response body <html><body>hello</body></html> and respond from the ingress directly with a HTTP status code 200: zalando.org/skipper-routes: | Path(\"/\") -> setResponseHeader(\"X\", \"bar\") -> inlineContent(\"<html><body>hello</body></html>\") -> status(200) -> <shunt> Keep in mind that you need a valid backend definition to backends which are available, otherwise Skipper would not accept the entire route definition from the ingress object for safety reasons.","title":"Return static content"},{"location":"kubernetes/ingress-usage/#cors-example","text":"This example shows how to add a custom route for handling OPTIONS requests. apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-routes: | Method(\"OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Origin\", \"*\") -> setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\") -> status(200) -> <shunt> name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 This will generate a custom route for the ingress which looks like this: Host(/^app-default[.]example[.]org$/) && Method(\"OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Origin\", \"*\") -> setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\") -> setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\") -> status(200) -> <shunt>","title":"CORS example"},{"location":"kubernetes/ingress-usage/#multiple-routes","text":"You can also set multiple routes, but you have to set the names of the route as defined in eskip: zalando.org/skipper-routes: | routename1: Path(\"/\") -> localRatelimit(2, \"1h\") -> inlineContent(\"A\") -> status(200) -> <shunt>; routename2: Path(\"/foo\") -> localRatelimit(5, \"1h\") -> inlineContent(\"B\") -> status(200) -> <shunt>; Make sure the ; semicolon is used to terminate the routes, if you use multiple routes definitions.","title":"Multiple routes"},{"location":"kubernetes/ingress-usage/#filters-basic-http-manipulations","text":"HTTP manipulations are done by using skipper filters. Changes can be done in the request path, meaning request to your backend or in the response path to the client, which made the request. The following examples can be used within zalando.org/skipper-filter annotation.","title":"Filters - Basic HTTP manipulations"},{"location":"kubernetes/ingress-usage/#add-a-request-header","text":"Add a HTTP header in the request path to your backend. setRequestHeader(\"X-Foo\", \"bar\")","title":"Add a request Header"},{"location":"kubernetes/ingress-usage/#add-a-response-header","text":"Add a HTTP header in the response path of your clients. setResponseHeader(\"X-Foo\", \"bar\")","title":"Add a response Header"},{"location":"kubernetes/ingress-usage/#enable-gzip","text":"Compress responses with gzip. compress() // compress all valid MIME types compress(\"text/html\") // only compress HTML files compress(9, \"text/html\") // control the level of compression, 1 = fastest, 9 = best compression, 0 = no compression","title":"Enable gzip"},{"location":"kubernetes/ingress-usage/#set-the-path","text":"Change the path in the request path to your backend to /newPath/ . setPath(\"/newPath/\")","title":"Set the Path"},{"location":"kubernetes/ingress-usage/#modify-path","text":"Modify the path in the request path from /api/foo to your backend to /foo . modPath(\"^/api/\", \"/\")","title":"Modify Path"},{"location":"kubernetes/ingress-usage/#set-the-querystring","text":"Set the Querystring in the request path to your backend to ?text=godoc%20skipper . setQuery(\"text\", \"godoc skipper\")","title":"Set the Querystring"},{"location":"kubernetes/ingress-usage/#redirect","text":"Create a redirect with HTTP code 301 to https://foo.example.org/. redirectTo(301, \"https://foo.example.org/\")","title":"Redirect"},{"location":"kubernetes/ingress-usage/#cookies","text":"Set a Cookie in the request path to your backend. requestCookie(\"test-session\", \"abc\") Set a Cookie in the response path of your clients. responseCookie(\"test-session\", \"abc\", 31536000) responseCookie(\"test-session\", \"abc\", 31536000, \"change-only\") // response cookie without HttpOnly: jsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")","title":"Cookies"},{"location":"kubernetes/ingress-usage/#authorization","text":"Our filter auth godoc shows how to use filters for authorization.","title":"Authorization"},{"location":"kubernetes/ingress-usage/#basic-auth","text":"% htpasswd -nbm myName myPassword basicAuth(\"/path/to/htpasswd\") basicAuth(\"/path/to/htpasswd\", \"My Website\")","title":"Basic Auth"},{"location":"kubernetes/ingress-usage/#bearer-token-oauthjwt","text":"OAuth2/JWT tokens can be validated and allowed based on different content of the token. Please check the filter documentation for that: oauthTokeninfoAnyScope oauthTokeninfoAllScope oauthTokeninfoAnyKV oauthTokeninfoAllKV There are also auth predicates , which will allow you to match a route based on the content of a token: JWTPayloadAnyKV() JWTPayloadAllKV() These are not validating the tokens, which should be done separately by the filters mentioned above.","title":"Bearer Token (OAuth/JWT)"},{"location":"kubernetes/ingress-usage/#diagnosis-throttling-bandwidth-latency","text":"For diagnosis purpose there are filters that enable you to throttle the bandwidth or add latency. For the full list of filters see our diag filter godoc page . bandwidth(30) // incoming in kb/s backendBandwidth(30) // outgoing in kb/s backendLatency(120) // in ms","title":"Diagnosis - Throttling Bandwidth - Latency"},{"location":"kubernetes/ingress-usage/#flow-id-to-trace-request-flows","text":"To trace request flows skipper can generate a unique Flow Id for every HTTP request that it receives. You can then find the trace of the request in all your access logs. Skipper sets the X-Flow-Id header to a unique value. Read more about this in our flowid filter godoc . flowId(\"reuse\")","title":"Flow Id to trace request flows"},{"location":"kubernetes/ingress-usage/#filters-reliability-features","text":"Filters can modify http requests and responses. There are plenty of things you can do with them.","title":"Filters - reliability features"},{"location":"kubernetes/ingress-usage/#circuitbreaker","text":"","title":"Circuitbreaker"},{"location":"kubernetes/ingress-usage/#consecutive-breaker","text":"The consecutiveBreaker filter is a breaker for the ingress route that open if the backend failures for the route reach a value of N (in this example N=15), where N is a mandatory argument of the filter and there are some more optional arguments documented : consecutiveBreaker(15) The ingress spec would look like this: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: consecutiveBreaker(15) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Consecutive Breaker"},{"location":"kubernetes/ingress-usage/#rate-breaker","text":"The rateBreaker filter is a breaker for the ingress route that open if the backend failures for the route reach a value of N within a window of the last M requests, where N (in this example 30) and M (in this example 300) are mandatory arguments of the filter and there are some more optional arguments documented . rateBreaker(30, 300) The ingress spec would look like this: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: rateBreaker(30, 300) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Rate Breaker"},{"location":"kubernetes/ingress-usage/#ratelimits","text":"There are two kind of ratelimits: Client side ratelimits are used to slow down login enumeration attacks, that targets your login pages. This is a security protection for DDOS or login attacks. Service or backend side ratelimits are used to protect your services due too much traffic. This can be used in an emergency situation to make sure you calm down ingress traffic or in general if you know how much calls per duration your backend is able to handle. Ratelimits are enforced per route. More details you will find in ratelimit package and Kubernetes dataclient documentation.","title":"Ratelimits"},{"location":"kubernetes/ingress-usage/#client-ratelimits","text":"The example shows 20 calls per hour per client, based on X-Forwarded-For header or IP incase there is no X-Forwarded-For header set, are allowed to each skipper instance for the given ingress. apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: localRatelimit(20, \"1h\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80 If you need to rate limit service to service communication and you use Authorization headers to protect your backend from your clients, then you can pass a 3 parameter to group clients by \"Authorization Header\": apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Client Ratelimits"},{"location":"kubernetes/ingress-usage/#service-ratelimits","text":"The example shows 50 calls per minute are allowed to each skipper instance for the given ingress. apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: ratelimit(50, \"1m\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Service Ratelimits"},{"location":"kubernetes/ingress-usage/#shadow-traffic","text":"If you want to test a new replacement of a production service with production load, you can copy incoming requests to your new endpoint and ignore the responses from your new backend. This can be done by the tee() and teenf() filters . apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: teenf(\"https://app-new.example.org\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Shadow Traffic"},{"location":"kubernetes/ingress-usage/#predicates","text":"Predicates are influencing the route matching, which you might want to carefully test before using it in production. This enables you to do feature toggles or time based enabling endpoints. You can use all kinds of predicates with filters together.","title":"Predicates"},{"location":"kubernetes/ingress-usage/#feature-toggle","text":"Feature toggles are often implemented as query string to select a new feature. Normally you would have to implement this in your application, but Skipper can help you with that and you can select routes with an ingress definition. You create 2 ingresses that matches the same route, here host header match to app-default.example.org and one ingress has a defined query parameter to select the route to the alpha version deployment. If the query string in the URL has version=alpha set, for example https://app-default.example.org/mypath?version=alpha , the service alpha-svc will get the traffic, if not prod-svc . alpha-svc: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\") name: alpha-app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: alpha-svc servicePort: 80 prod-svc: apiVersion: extensions/v1beta1 kind: Ingress metadata: name: prod-app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: prod-svc servicePort: 80","title":"Feature Toggle"},{"location":"kubernetes/ingress-usage/#ip-whitelisting","text":"This ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17 apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"IP Whitelisting"},{"location":"kubernetes/ingress-usage/#ab-test","text":"Implementing A/B testing is heavy. Skipper can help you to do that. You need to have a traffic split somewhere and have your customers sticky to either A or B flavor of your application. Most likely people would implement using cookies. Skipper can set a cookie with responseCookie() in a response to the client and the cookie predicate can be used to match the route based on the cookie. Like this you can have sticky sessions to either A or B for your clients. This example shows to have 10% traffic using A and the rest using B. 10% choice of setting the Cookie \"flavor\" to \"A\": apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Traffic(.1) zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: a-app-svc servicePort: 80 Rest is setting Cookie \"flavor\" to \"B\": apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: b-app-svc servicePort: 80 To be sticky, you have to create 2 ingress with predicate to match routes with the cookie we set before. For \"A\" this would be: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: a-app-svc servicePort: 80 For \"B\" this would be: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: b-app-svc servicePort: 80","title":"A/B test"},{"location":"kubernetes/ingress-usage/#blue-green-deployments","text":"To do blue-green deployments you have to have control over traffic switching. Skipper gives you the opportunity to set weights to backend services in your ingress specification. zalando.org/backend-weights is a hash map, which key relates to the serviceName of the backend and the value is the weight of traffic you want to send to the particular backend. It works for more than 2 backends, but for simplicity this example shows 2 backends, which should be the default case for supporting blue-green deployments. In the following example my-app-1 service will get 80% of the traffic and my-app-2 will get 20% of the traffic: apiVersion: extensions/v1beta1 kind: Ingress metadata: name: my-app labels: application: my-app annotations: zalando.org/backend-weights: | {\"my-app-1\": 80, \"my-app-2\": 20} spec: rules: - host: my-app.example.org http: paths: - backend: serviceName: my-app-1 servicePort: http path: / - backend: serviceName: my-app-2 servicePort: http path: /","title":"Blue-Green deployments"},{"location":"kubernetes/ingress-usage/#chaining-filters-and-predicates","text":"You can set multiple filters in a chain similar to the eskip format . apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) && Source(\"1.2.3.0/24\", \"195.168.0.0/17\") zalando.org/skipper-filter: localRatelimit(50, \"10m\") -> requestCookie(\"test-session\", \"abc\") name: app spec: rules: - host: app-default.example.org http: paths: - backend: serviceName: app-svc servicePort: 80","title":"Chaining Filters and Predicates"}]}