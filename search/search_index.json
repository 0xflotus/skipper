{
    "docs": [
        {
            "location": "/", 
            "text": "Architecture\n\n\nSkipper is written as a library and is also a multi binary project with\n2 binaries, named \nskipper\n and \neskip\n. \nSkipper\n is the HTTP proxy\nand \neskip\n is a CLI application to verify, print, update or delete\nSkipper routes.\n\n\nSkipper's internal architecture is split into different packages. The\n\nskipper\n package has connections to multiple \ndataclient\n, that pull\ninformation from different sources, for example static routes from an\neskip file or dynamic routes from Kubernetes ingress objects.\n\n\nThe \nproxy\n package gets the routes populated by skipper and has\nalways a current routing table which will be replaced on change.\n\n\nA route is one entry in the routing table. A route consists of one or\nmore \npredicate\n, that are used to find a route for a given HTTP\nrequest. A route can also have one or more \nfilter\n, that can modify\nthe content of the request or response.  A route always points to a\nbackend, or it's a \nshunt\n, meaning that skipper serves the requests\nfor the route, or a \nloopback\n, meaning that the request will be\nmatched against the routing table again after filters have modified\nit.\n\n\nOpentracing API\n is supported via\n\nskipper-plugins\n. For\nexample \nJaeger\n is supported.\n\n\nSkipper has a rich set of metrics that are exposed as json, but can be\nexported in \nPrometheus\n format.\n\n\n\n\nRoute processing\n\n\nPackage \nskipper\n has a Go \nhttp.Server\n and does the \nListenAndServe\n\ncall with the \nloggingHandler\n wrapped \nproxy\n.  The \nloggingHandler\n\nis basically a middleware for the \nproxy\n providing access logs and\nboth implement the plain Go \nhttp.Handler interface\n.\n\n\nFor each incoming \nhttp.Request\n the \nproxy\n will create a request\ncontext and enhance it with an \nOpentracing API\n Span.\nIt will check proxy global ratelimits first and after that lookup the\nroute in the routing table. After that skipper will apply all request\nfilters, that can modify the \nhttp.Request\n. It will then check the\nroute local ratelimits, the circuitbreakers and do the backend\ncall. If the backend call got a TCP or TLS connection error in a\nloadbalanced route, skipper will do a retry to another backend of that\nloadbalanced group automatically. Just before the response to the\ncaller, skipper will process the response filters, that can change the\n\nhttp.Response\n.\n\n\nIn two special cases, skipper doesn't forward the request to the\nbackend. When the route is shunted (\nshunt\n), skipper serves the\nrequest alone, by using only the filters. When the route is a\n\nloopback\n, the request is passed to the routing table for finding\nanother route, based on the changes that the filters made to the\nrequest.", 
            "title": "Architecture"
        }, 
        {
            "location": "/#architecture", 
            "text": "Skipper is written as a library and is also a multi binary project with\n2 binaries, named  skipper  and  eskip .  Skipper  is the HTTP proxy\nand  eskip  is a CLI application to verify, print, update or delete\nSkipper routes.  Skipper's internal architecture is split into different packages. The skipper  package has connections to multiple  dataclient , that pull\ninformation from different sources, for example static routes from an\neskip file or dynamic routes from Kubernetes ingress objects.  The  proxy  package gets the routes populated by skipper and has\nalways a current routing table which will be replaced on change.  A route is one entry in the routing table. A route consists of one or\nmore  predicate , that are used to find a route for a given HTTP\nrequest. A route can also have one or more  filter , that can modify\nthe content of the request or response.  A route always points to a\nbackend, or it's a  shunt , meaning that skipper serves the requests\nfor the route, or a  loopback , meaning that the request will be\nmatched against the routing table again after filters have modified\nit.  Opentracing API  is supported via skipper-plugins . For\nexample  Jaeger  is supported.  Skipper has a rich set of metrics that are exposed as json, but can be\nexported in  Prometheus  format.", 
            "title": "Architecture"
        }, 
        {
            "location": "/#route-processing", 
            "text": "Package  skipper  has a Go  http.Server  and does the  ListenAndServe \ncall with the  loggingHandler  wrapped  proxy .  The  loggingHandler \nis basically a middleware for the  proxy  providing access logs and\nboth implement the plain Go  http.Handler interface .  For each incoming  http.Request  the  proxy  will create a request\ncontext and enhance it with an  Opentracing API  Span.\nIt will check proxy global ratelimits first and after that lookup the\nroute in the routing table. After that skipper will apply all request\nfilters, that can modify the  http.Request . It will then check the\nroute local ratelimits, the circuitbreakers and do the backend\ncall. If the backend call got a TCP or TLS connection error in a\nloadbalanced route, skipper will do a retry to another backend of that\nloadbalanced group automatically. Just before the response to the\ncaller, skipper will process the response filters, that can change the http.Response .  In two special cases, skipper doesn't forward the request to the\nbackend. When the route is shunted ( shunt ), skipper serves the\nrequest alone, by using only the filters. When the route is a loopback , the request is passed to the routing table for finding\nanother route, based on the changes that the filters made to the\nrequest.", 
            "title": "Route processing"
        }, 
        {
            "location": "/filters/", 
            "text": "Skipper Filters\n\n\nThe parameters can be strings, regex or float64 / int\n\n\n\n\nstring\n is a string surrounded by double quotes (\n\"\n)\n\n\nregex\n is a regular expression, surrounded by \n/\n, e.g. \n/^www\\.example\\.org(:\\d+)?$/\n\n\nint\n / \nfloat64\n are usual (decimal) numbers like \n401\n or \n1.23456\n\n\ntime\n is a string in double quotes, parseable by \ntime.Duration\n)\n\n\n\n\nFilters are a generic tool and can change HTTP header and body in the request and response path.\nFilter can be chained using the arrow operator \n-\n.\n\n\nExample route with a match all, 2 filters and a backend:\n\n\nall: * -\n filter1 -\n filter2 -\n \nhttp://127.0.0.1:1234/\n;\n\n\n\n\nsetRequestHeader\n\n\nSet headers for requests.\n\n\nParameters:\n\n header name (string)\n\n header value (string)\n\n\nExample:\n\n\nfoo: * -\n setRequestHeader(\nX-Passed-Skipper\n, \ntrue\n) -\n \nhttps://backend.example.org\n;\n\n\n\n\nsetResponseHeader\n\n\nSame as \nsetRequestHeader\n, only for responses\n\n\nappendRequestHeader\n\n\nSame as \nsetRequestHeader\n, does not remove a possibly existing value, but adds a new header value\n\n\nappendResponseHeader\n\n\nSame as \nappendRequestHeader\n, only for responses\n\n\ndropRequestHeader\n\n\nRemoves a header from the request\n\n\nParameters:\n* header name (string)\n\n\nExample:\n\n\nfoo: * -\n dropRequestHeader(\nUser-Agent\n) -\n \nhttps://backend.example.org\n;\n\n\n\n\ndropResponseHeader\n\n\nSame as \ndropRequestHeader\n but for responses from the backend\n\n\nmodPath\n\n\nReplace all matched regex expressions in the path.\n\n\nParameters:\n\n the expression to match (regex)\n\n the replacement (string)\n\n\nsetPath\n\n\nReplace the path of the original request to the replacement.\n\n\nParameters:\n* the replacement (string)\n\n\nredirectTo\n\n\nCreates an HTTP redirect response.\n\n\nParameters:\n\n\n\n\nredirect status code (int)\n\n\nlocation (string)\n\n\n\n\nExample:\n\n\nredir: PathRegex(/^\\/foo\\/bar/) -\n redirectTo(302, \n/foo/newBar\n) -\n \nshunt\n;\n\n\n\n\nredirectToLower\n\n\nSame as \nredirectTo\n, but replaces all strings to lower case.\n\n\nstatic\n\n\nServes static content from the filesystem.\n\n\nParameters:\n\n\n\n\nRequest path to strip (string)\n\n\nTarget base path in the filesystem (string)\n\n\n\n\nExample:\n\n\nThis serves files from \n/srv/www/dehydrated\n when requested via \n/.well-known/acme-challenge/\n,\ne.g. the request \nGET /.well-known/acme-challenge/foo\n will serve the file \n/srv/www/dehydrated/foo\n.\n\n\nacme: Host(/./) \n Method(\nGET\n) \n Path(\n/.well-known/acme-challenge/*\n)\n    -\n static(\n/.well-known/acme-challenge/\n, \n/srv/www/dehydrated\n) -\n \nshunt\n;\n\n\n\n\nNotes:\n\n\n\n\nredirects to the directory when a file \nindex.html\n exists and it is requested, i.e. \nGET /foo/index.html\n redirects to \n/foo/\n which serves then the \n/foo/index.html\n\n\nserves the content of the \nindex.html\n when a directory is requested\n\n\ndoes a simple directory listing of files / directories when no \nindex.html\n is present\n\n\n\n\nstripQuery\n\n\npreserveHost\n\n\nSets the incoming \nHost:\n header also on the outgoing backend connection\n\n\nParameters: none\n\n\nExample:\n\n\nroute1: * -\n preserveHost() -\n \nhttp://backend.example.org\n;\n\n\n\n\nstatus\n\n\nSets the response status code to the given value, with no regards to the backend response.\n\n\nParameters:\n\n\n\n\nstatus code (int)\n\n\n\n\nExample:\n\n\nroute1: Host(/^all401\\.example\\.org$/) -\n status(401) -\n \nshunt\n;\n\n\n\n\ncompress\n\n\nThe filter, when executed on the response path, checks if the response entity can\nbe compressed. To decide, it checks the Content-Encoding, the Cache-Control and\nthe Content-Type headers. It doesn't compress the content if the Content-Encoding\nis set to other than identity, or the Cache-Control applies the no-transform\npragma, or the Content-Type is set to an unsupported value.\n\n\nThe default supported content types are: \ntext/plain\n, \ntext/html\n, \napplication/json\n,\n\napplication/javascript\n, \napplication/x-javascript\n, \ntext/javascript\n, \ntext/css\n,\n\nimage/svg+xml\n, \napplication/octet-stream\n.\n\n\nThe default set of MIME types can be reset or extended by passing in the desired\ntypes as filter arguments. When extending the defaults, the first argument needs to\nbe \n\"...\"\n. E.g. to compress tiff in addition to the defaults:\n\n\n* -\n compress(\n...\n, \nimage/tiff\n) -\n \nhttps://www.example.org\n\n\n\n\n\nTo reset the supported types, e.g. to compress only HTML, the \"...\" argument needs\nto be omitted:\n\n\n* -\n compress(\ntext/html\n) -\n \nhttps://www.example.org\n\n\n\n\n\nIt is possible to control the compression level, by setting it as the first filter\nargument, in front of the MIME types. The default compression level is best-speed.\nThe possible values are integers between 0 and 9 (inclusive), where 0 means\nno-compression, 1 means best-speed and 9 means best-compression. Example:\n\n\n* -\n compress(9, \nimage/tiff\n) -\n \nhttps://www.example.org\n\n\n\n\n\nThe filter also checks the incoming request, if it accepts the supported encodings,\nexplicitly stated in the Accept-Encoding header. The filter currently supports \ngzip\n\nand \ndeflate\n. It does not assume that the client accepts any encoding if the\nAccept-Encoding header is not set. It ignores * in the Accept-Encoding header.\n\n\nWhen compressing the response, it updates the response header. It deletes the\n\nContent-Length\n value triggering the proxy to always return the response with chunked\ntransfer encoding, sets the Content-Encoding to the selected encoding and sets the\n\nVary: Accept-Encoding\n header, if missing.\n\n\nThe compression happens in a streaming way, using only a small internal buffer.\n\n\nsetQuery\n\n\nSet the query string \n?k=v\n in the request to the backend to a given value.\n\n\nParameters:\n\n\n\n\nkey (string)\n\n\nvalue (string)\n\n\n\n\nExample:\n\n\nsetQuery(\nk\n, \nv\n)\n\n\n\n\ndropQuery\n\n\nDelete the query string \n?k=v\n in the request to the backend for a\ngiven key.\n\n\nParameters:\n\n\n\n\nkey (string)\n\n\n\n\nExample:\n\n\ndropQuery(\nk\n)\n\n\n\n\ninlineContent\n\n\nReturns arbitrary content in the HTTP body.\n\n\nParameters:\n\n\n\n\narbitrary (string)\n\n\n\n\nExample:\n\n\n* -\n inlineContent(\nh1\nHello\n/h1\n) -\n \nshunt\n\n\n\n\n\nflowId\n\n\nSets an X-Flow-Id header, if it's not already in the request.\nThis allows you to have a trace in your logs, that traces from\nthe incoming request on the edge to all backend services.\n\n\nParamters:\n\n\n\n\nno parameter: resets always the X-Flow-Id header to a new value\n\n\n\"reuse\": only create X-Flow-Id header if not set in the request\n\n\n\n\nExample:\n\n\n* -\n flowId() -\n \nhttps://some-backend.example.org\n;\n* -\n flowId(\nreuse\n) -\n \nhttps://some-backend.example.org\n;\n\n\n\n\nrandomContent\n\n\nGenerate response with random text of specified length.\n\n\nParameters:\n\n\n\n\nlength of data (int)\n\n\n\n\nExample:\n\n\n* -\n randomContent(42) -\n \nshunt\n;\n\n\n\n\nlatency\n\n\nEnable adding artificial latency\n\n\nParameters:\n\n\n\n\nlatency in milliseconds (int)\n\n\n\n\nExample:\n\n\n* -\n latency(120) -\n \nhttps://www.example.org\n;\n\n\n\n\nbandwidth\n\n\nEnable bandwidth throttling.\n\n\nParameters:\n\n\n\n\nbandwidth in kb/s (int)\n\n\n\n\nExample:\n\n\n* -\n bandwidth(30) -\n \nhttps://www.example.org\n;\n\n\n\n\nchunks\n\n\nEnables adding chunking responses with custom chunk size with\nartificial delays in between response chunks. To disable delays, set\nthe second parameter to \"0\".\n\n\nParameters:\n\n\n\n\nbyte length (int)\n\n\ntime duration (time.Duration)\n\n\n\n\nExample:\n\n\n* -\n chunks(1024, \n120ms\n) -\n \nhttps://www.example.org\n;\n* -\n chunks(1024, \n0\n) -\n \nhttps://www.example.org\n;\n\n\n\n\nbackendLatency\n\n\nSame as \nlatency filter\n, but on the request path and not on\nthe response path.\n\n\nbackendBandwidth\n\n\nSame as \nbandwidth filter\n, but on the request path and not on\nthe response path.\n\n\nbackendChunks\n\n\nSame as \nchunks filter\n, but on the request path and not on\nthe response path.\n\n\ntee\n\n\nProvides a unix-like \ntee\n feature for routing.\n\n\nUsing this filter, the request will be sent to a \"shadow\" backend in addition\nto the main backend of the route.\n\n\nExample:\n\n\n* -\n tee(\nhttps://audit-logging.example.org\n) -\n \nhttps://foo.example.org\n;\n\n\n\n\nThis will send an identical request for foo.example.org to\naudit-logging.example.org. Another use case could be using it for benchmarking\na new backend with some real traffic. This we call \"shadow traffic\".\n\n\nThe above route will forward the request to \nhttps://foo.example.org\n as it\nnormally would do, but in addition to that, it will send an identical request to\n\nhttps://audit-logging.example.org\n. The request sent to\n\nhttps://audit-logging.example.org\n will receive the same method and headers,\nand a copy of the body stream. The \ntee\n response is ignored for this shadow backend.\n\n\nIt is possible to change the path of the tee request, in a similar way to the\n\nmodPath\n filter:\n\n\nPath(\n/api/v1\n) -\n tee(\nhttps://api.example.org\n, \n^/v1\n, \n/v2\n ) -\n \nhttp://api.example.org\n;\n\n\n\n\nIn the above example, one can test how a new version of an API would behave on\nincoming requests.\n\n\nteenf\n\n\nThe same as \ntee filter\n, but does not follow redirects from the backend.\n\n\nbasicAuth\n\n\nEnable Basic Authentication\n\n\nThe filter accepts two parameters, the first mandatory one is the path to the\nhtpasswd file usually used with Apache or nginx. The second one is the optional\nrealm name that will be displayed in the browser. MD5, SHA1 and BCrypt are supported\nfor Basic authentication password storage, see also\n\nthe http-auth module page\n.\n\n\nExamples:\n\n\nbasicAuth(\n/path/to/htpasswd\n)\nbasicAuth(\n/path/to/htpasswd\n, \nMy Website\n)\n\n\n\n\nrequestCookie\n\n\nAppend a cookie to the request header.\n\n\nParameters:\n\n\n\n\ncookie name (string)\n\n\ncookie value (string)\n\n\n\n\nExample:\n\n\nrequestCookie(\ntest-session\n, \nabc\n)\n\n\n\n\nresponseCookie\n\n\nAppends cookies to responses in the \"Set-Cookie\" header. The response cookie\naccepts an optional argument to control the max-age property of the cookie,\nof type \nint\n, in seconds. The response cookie accepts an optional fourth\nargument, \"change-only\", to control if the cookie should be set on every\nresponse, or only if the request does not contain a cookie with the provided\nname and value.\n\n\nExample:\n\n\nresponseCookie(\ntest-session\n, \nabc\n)\nresponseCookie(\ntest-session\n, \nabc\n, 31536000),\nresponseCookie(\ntest-session\n, \nabc\n, 31536000, \nchange-only\n)\n\n\n\n\njsCookie\n\n\nThe JS cookie behaves exactly as the response cookie, but it does not set the\n\nHttpOnly\n directive, so these cookies will be accessible from JS code running\nin web browsers.\n\n\nExample:\n\n\njsCookie(\ntest-session-info\n, \nabc-debug\n, 31536000, \nchange-only\n)\n\n\n\n\nconsecutiveBreaker\n\n\nThis breaker opens when the proxy could not connect to a backend or received\na \n=500 status code at least N times in a row. When open, the proxy returns\n503 - Service Unavailable response during the breaker timeout. After this timeout,\nthe breaker goes into half-open state, in which it expects that M number of\nrequests succeed. The requests in the half-open state are accepted concurrently.\nIf any of the requests during the half-open state fails, the breaker goes back to\nopen state. If all succeed, it goes to closed state again.\n\n\nParameters:\n\n\n\n\nnumber of consecutive failures to open (int)\n\n\ntimeout (time string, parseable by \ntime.Duration\n) - optional\n\n\nhalf-open requests (int) - optional\n\n\nidle-ttl (time string, parseable by \ntime.Duration\n) - optional\n\n\n\n\nSee also the \ncircuit breaker docs\n.\n\n\nrateBreaker\n\n\nThe \"rate breaker\" works similar to the \nconsecutiveBreaker\n, but\ninstead of considering N consecutive failures for going open, it maintains a sliding\nwindow of the last M events, both successes and failures, and opens only when the number\nof failures reaches N within the window. This way the sliding window is not time based\nand allows the same breaker characteristics for low and high rate traffic.\n\n\nParameters:\n\n\n\n\nnumber of consecutive failures to open (int)\n\n\nsliding window (time string, parseable by \ntime.Duration\n)\n\n\nhalf-open requests (int) - optional\n\n\nidle-ttl (time string, parseable by \ntime.Duration\n) - optional\n\n\n\n\nSee also the \ncircuit breaker docs\n.\n\n\ndisableBreaker\n\n\nChange (or set) the breaker configurations for an individual route and disable for another, in eskip:\n\n\nupdates: Method(\nPOST\n) \n Host(\nfoo.example.org\n)\n  -\n consecutiveBreaker(9)\n  -\n \nhttps://foo.backend.net\n;\n\nbackendHealthcheck: Path(\n/healthcheck\n)\n  -\n disableBreaker()\n  -\n \nhttps://foo.backend.net\n;\n\n\n\n\nSee also the \ncircuit breaker docs\n.\n\n\nlocalRatelimit\n\n\nPer skipper instance calculated ratelimit, that allows number of\nrequests by client. The definition of the same client is based on data\nof the http header and can be changed with an optional third\nparameter. If the third parameter is set skipper will use the\nAuthorization header to put the request in the same client bucket,\nelse  the X-Forwarded-For Header will be used.\n\n\nParameters:\n\n\n\n\nnumber of allowed requests per time period (int)\n\n\ntime period for requests being counted (time.Duration)\n\n\noptional parameter can be set to: \"auth\" (string)\n\n\n\n\nlocalRatelimit(3, \n1m\n)\nlocalRatelimit(3, \n1m\n, \nauth\n)\n\n\n\n\nSee also the \nratelimit docs\n.\n\n\nratelimit\n\n\nPer skipper instance calculated ratelimit, that allows number of\nrequests to a backend.\n\n\nParameters:\n\n\n\n\nnumber of allowed requests per time period (int)\n\n\ntime period for requests being counted (time.Duration)\n\n\n\n\nratelimit(20, \n1m\n)\nratelimit(300, \n1h\n)\n\n\n\n\nSee also the \nratelimit docs\n.\n\n\nlua\n\n\nSee \nthe scripts page\n\n\ncorsOrigin\n\n\nThe filter accepts an optional variadic list of acceptable origin\nparameters. If the input argument list is empty, the header will\nalways be set to \n*\n which means any origin is acceptable. Otherwise\nthe header is only set if the request contains an Origin header and\nits value matches one of the elements in the input list. The header is\nonly set on the response.\n\n\nParameters:\n\n\n\n\nurl (variadic string)\n\n\n\n\nExamples:\n\n\ncorsOrigin()\ncorsOrigin(\nhttps://www.example.org\n)\ncorsOrigin(\nhttps://www.example.org\n, \nhttp://localhost:9001\n)", 
            "title": "Filters"
        }, 
        {
            "location": "/filters/#skipper-filters", 
            "text": "The parameters can be strings, regex or float64 / int   string  is a string surrounded by double quotes ( \" )  regex  is a regular expression, surrounded by  / , e.g.  /^www\\.example\\.org(:\\d+)?$/  int  /  float64  are usual (decimal) numbers like  401  or  1.23456  time  is a string in double quotes, parseable by  time.Duration )   Filters are a generic tool and can change HTTP header and body in the request and response path.\nFilter can be chained using the arrow operator  - .  Example route with a match all, 2 filters and a backend:  all: * -  filter1 -  filter2 -   http://127.0.0.1:1234/ ;", 
            "title": "Skipper Filters"
        }, 
        {
            "location": "/filters/#setrequestheader", 
            "text": "Set headers for requests.  Parameters:  header name (string)  header value (string)  Example:  foo: * -  setRequestHeader( X-Passed-Skipper ,  true ) -   https://backend.example.org ;", 
            "title": "setRequestHeader"
        }, 
        {
            "location": "/filters/#setresponseheader", 
            "text": "Same as  setRequestHeader , only for responses", 
            "title": "setResponseHeader"
        }, 
        {
            "location": "/filters/#appendrequestheader", 
            "text": "Same as  setRequestHeader , does not remove a possibly existing value, but adds a new header value", 
            "title": "appendRequestHeader"
        }, 
        {
            "location": "/filters/#appendresponseheader", 
            "text": "Same as  appendRequestHeader , only for responses", 
            "title": "appendResponseHeader"
        }, 
        {
            "location": "/filters/#droprequestheader", 
            "text": "Removes a header from the request  Parameters:\n* header name (string)  Example:  foo: * -  dropRequestHeader( User-Agent ) -   https://backend.example.org ;", 
            "title": "dropRequestHeader"
        }, 
        {
            "location": "/filters/#dropresponseheader", 
            "text": "Same as  dropRequestHeader  but for responses from the backend", 
            "title": "dropResponseHeader"
        }, 
        {
            "location": "/filters/#modpath", 
            "text": "Replace all matched regex expressions in the path.  Parameters:  the expression to match (regex)  the replacement (string)", 
            "title": "modPath"
        }, 
        {
            "location": "/filters/#setpath", 
            "text": "Replace the path of the original request to the replacement.  Parameters:\n* the replacement (string)", 
            "title": "setPath"
        }, 
        {
            "location": "/filters/#redirectto", 
            "text": "Creates an HTTP redirect response.  Parameters:   redirect status code (int)  location (string)   Example:  redir: PathRegex(/^\\/foo\\/bar/) -  redirectTo(302,  /foo/newBar ) -   shunt ;", 
            "title": "redirectTo"
        }, 
        {
            "location": "/filters/#redirecttolower", 
            "text": "Same as  redirectTo , but replaces all strings to lower case.", 
            "title": "redirectToLower"
        }, 
        {
            "location": "/filters/#static", 
            "text": "Serves static content from the filesystem.  Parameters:   Request path to strip (string)  Target base path in the filesystem (string)   Example:  This serves files from  /srv/www/dehydrated  when requested via  /.well-known/acme-challenge/ ,\ne.g. the request  GET /.well-known/acme-challenge/foo  will serve the file  /srv/www/dehydrated/foo .  acme: Host(/./)   Method( GET )   Path( /.well-known/acme-challenge/* )\n    -  static( /.well-known/acme-challenge/ ,  /srv/www/dehydrated ) -   shunt ;  Notes:   redirects to the directory when a file  index.html  exists and it is requested, i.e.  GET /foo/index.html  redirects to  /foo/  which serves then the  /foo/index.html  serves the content of the  index.html  when a directory is requested  does a simple directory listing of files / directories when no  index.html  is present", 
            "title": "static"
        }, 
        {
            "location": "/filters/#stripquery", 
            "text": "", 
            "title": "stripQuery"
        }, 
        {
            "location": "/filters/#preservehost", 
            "text": "Sets the incoming  Host:  header also on the outgoing backend connection  Parameters: none  Example:  route1: * -  preserveHost() -   http://backend.example.org ;", 
            "title": "preserveHost"
        }, 
        {
            "location": "/filters/#status", 
            "text": "Sets the response status code to the given value, with no regards to the backend response.  Parameters:   status code (int)   Example:  route1: Host(/^all401\\.example\\.org$/) -  status(401) -   shunt ;", 
            "title": "status"
        }, 
        {
            "location": "/filters/#compress", 
            "text": "The filter, when executed on the response path, checks if the response entity can\nbe compressed. To decide, it checks the Content-Encoding, the Cache-Control and\nthe Content-Type headers. It doesn't compress the content if the Content-Encoding\nis set to other than identity, or the Cache-Control applies the no-transform\npragma, or the Content-Type is set to an unsupported value.  The default supported content types are:  text/plain ,  text/html ,  application/json , application/javascript ,  application/x-javascript ,  text/javascript ,  text/css , image/svg+xml ,  application/octet-stream .  The default set of MIME types can be reset or extended by passing in the desired\ntypes as filter arguments. When extending the defaults, the first argument needs to\nbe  \"...\" . E.g. to compress tiff in addition to the defaults:  * -  compress( ... ,  image/tiff ) -   https://www.example.org   To reset the supported types, e.g. to compress only HTML, the \"...\" argument needs\nto be omitted:  * -  compress( text/html ) -   https://www.example.org   It is possible to control the compression level, by setting it as the first filter\nargument, in front of the MIME types. The default compression level is best-speed.\nThe possible values are integers between 0 and 9 (inclusive), where 0 means\nno-compression, 1 means best-speed and 9 means best-compression. Example:  * -  compress(9,  image/tiff ) -   https://www.example.org   The filter also checks the incoming request, if it accepts the supported encodings,\nexplicitly stated in the Accept-Encoding header. The filter currently supports  gzip \nand  deflate . It does not assume that the client accepts any encoding if the\nAccept-Encoding header is not set. It ignores * in the Accept-Encoding header.  When compressing the response, it updates the response header. It deletes the Content-Length  value triggering the proxy to always return the response with chunked\ntransfer encoding, sets the Content-Encoding to the selected encoding and sets the Vary: Accept-Encoding  header, if missing.  The compression happens in a streaming way, using only a small internal buffer.", 
            "title": "compress"
        }, 
        {
            "location": "/filters/#setquery", 
            "text": "Set the query string  ?k=v  in the request to the backend to a given value.  Parameters:   key (string)  value (string)   Example:  setQuery( k ,  v )", 
            "title": "setQuery"
        }, 
        {
            "location": "/filters/#dropquery", 
            "text": "Delete the query string  ?k=v  in the request to the backend for a\ngiven key.  Parameters:   key (string)   Example:  dropQuery( k )", 
            "title": "dropQuery"
        }, 
        {
            "location": "/filters/#inlinecontent", 
            "text": "Returns arbitrary content in the HTTP body.  Parameters:   arbitrary (string)   Example:  * -  inlineContent( h1 Hello /h1 ) -   shunt", 
            "title": "inlineContent"
        }, 
        {
            "location": "/filters/#flowid", 
            "text": "Sets an X-Flow-Id header, if it's not already in the request.\nThis allows you to have a trace in your logs, that traces from\nthe incoming request on the edge to all backend services.  Paramters:   no parameter: resets always the X-Flow-Id header to a new value  \"reuse\": only create X-Flow-Id header if not set in the request   Example:  * -  flowId() -   https://some-backend.example.org ;\n* -  flowId( reuse ) -   https://some-backend.example.org ;", 
            "title": "flowId"
        }, 
        {
            "location": "/filters/#randomcontent", 
            "text": "Generate response with random text of specified length.  Parameters:   length of data (int)   Example:  * -  randomContent(42) -   shunt ;", 
            "title": "randomContent"
        }, 
        {
            "location": "/filters/#latency", 
            "text": "Enable adding artificial latency  Parameters:   latency in milliseconds (int)   Example:  * -  latency(120) -   https://www.example.org ;", 
            "title": "latency"
        }, 
        {
            "location": "/filters/#bandwidth", 
            "text": "Enable bandwidth throttling.  Parameters:   bandwidth in kb/s (int)   Example:  * -  bandwidth(30) -   https://www.example.org ;", 
            "title": "bandwidth"
        }, 
        {
            "location": "/filters/#chunks", 
            "text": "Enables adding chunking responses with custom chunk size with\nartificial delays in between response chunks. To disable delays, set\nthe second parameter to \"0\".  Parameters:   byte length (int)  time duration (time.Duration)   Example:  * -  chunks(1024,  120ms ) -   https://www.example.org ;\n* -  chunks(1024,  0 ) -   https://www.example.org ;", 
            "title": "chunks"
        }, 
        {
            "location": "/filters/#backendlatency", 
            "text": "Same as  latency filter , but on the request path and not on\nthe response path.", 
            "title": "backendLatency"
        }, 
        {
            "location": "/filters/#backendbandwidth", 
            "text": "Same as  bandwidth filter , but on the request path and not on\nthe response path.", 
            "title": "backendBandwidth"
        }, 
        {
            "location": "/filters/#backendchunks", 
            "text": "Same as  chunks filter , but on the request path and not on\nthe response path.", 
            "title": "backendChunks"
        }, 
        {
            "location": "/filters/#tee", 
            "text": "Provides a unix-like  tee  feature for routing.  Using this filter, the request will be sent to a \"shadow\" backend in addition\nto the main backend of the route.  Example:  * -  tee( https://audit-logging.example.org ) -   https://foo.example.org ;  This will send an identical request for foo.example.org to\naudit-logging.example.org. Another use case could be using it for benchmarking\na new backend with some real traffic. This we call \"shadow traffic\".  The above route will forward the request to  https://foo.example.org  as it\nnormally would do, but in addition to that, it will send an identical request to https://audit-logging.example.org . The request sent to https://audit-logging.example.org  will receive the same method and headers,\nand a copy of the body stream. The  tee  response is ignored for this shadow backend.  It is possible to change the path of the tee request, in a similar way to the modPath  filter:  Path( /api/v1 ) -  tee( https://api.example.org ,  ^/v1 ,  /v2  ) -   http://api.example.org ;  In the above example, one can test how a new version of an API would behave on\nincoming requests.", 
            "title": "tee"
        }, 
        {
            "location": "/filters/#teenf", 
            "text": "The same as  tee filter , but does not follow redirects from the backend.", 
            "title": "teenf"
        }, 
        {
            "location": "/filters/#basicauth", 
            "text": "Enable Basic Authentication  The filter accepts two parameters, the first mandatory one is the path to the\nhtpasswd file usually used with Apache or nginx. The second one is the optional\nrealm name that will be displayed in the browser. MD5, SHA1 and BCrypt are supported\nfor Basic authentication password storage, see also the http-auth module page .  Examples:  basicAuth( /path/to/htpasswd )\nbasicAuth( /path/to/htpasswd ,  My Website )", 
            "title": "basicAuth"
        }, 
        {
            "location": "/filters/#requestcookie", 
            "text": "Append a cookie to the request header.  Parameters:   cookie name (string)  cookie value (string)   Example:  requestCookie( test-session ,  abc )", 
            "title": "requestCookie"
        }, 
        {
            "location": "/filters/#responsecookie", 
            "text": "Appends cookies to responses in the \"Set-Cookie\" header. The response cookie\naccepts an optional argument to control the max-age property of the cookie,\nof type  int , in seconds. The response cookie accepts an optional fourth\nargument, \"change-only\", to control if the cookie should be set on every\nresponse, or only if the request does not contain a cookie with the provided\nname and value.  Example:  responseCookie( test-session ,  abc )\nresponseCookie( test-session ,  abc , 31536000),\nresponseCookie( test-session ,  abc , 31536000,  change-only )", 
            "title": "responseCookie"
        }, 
        {
            "location": "/filters/#jscookie", 
            "text": "The JS cookie behaves exactly as the response cookie, but it does not set the HttpOnly  directive, so these cookies will be accessible from JS code running\nin web browsers.  Example:  jsCookie( test-session-info ,  abc-debug , 31536000,  change-only )", 
            "title": "jsCookie"
        }, 
        {
            "location": "/filters/#consecutivebreaker", 
            "text": "This breaker opens when the proxy could not connect to a backend or received\na  =500 status code at least N times in a row. When open, the proxy returns\n503 - Service Unavailable response during the breaker timeout. After this timeout,\nthe breaker goes into half-open state, in which it expects that M number of\nrequests succeed. The requests in the half-open state are accepted concurrently.\nIf any of the requests during the half-open state fails, the breaker goes back to\nopen state. If all succeed, it goes to closed state again.  Parameters:   number of consecutive failures to open (int)  timeout (time string, parseable by  time.Duration ) - optional  half-open requests (int) - optional  idle-ttl (time string, parseable by  time.Duration ) - optional   See also the  circuit breaker docs .", 
            "title": "consecutiveBreaker"
        }, 
        {
            "location": "/filters/#ratebreaker", 
            "text": "The \"rate breaker\" works similar to the  consecutiveBreaker , but\ninstead of considering N consecutive failures for going open, it maintains a sliding\nwindow of the last M events, both successes and failures, and opens only when the number\nof failures reaches N within the window. This way the sliding window is not time based\nand allows the same breaker characteristics for low and high rate traffic.  Parameters:   number of consecutive failures to open (int)  sliding window (time string, parseable by  time.Duration )  half-open requests (int) - optional  idle-ttl (time string, parseable by  time.Duration ) - optional   See also the  circuit breaker docs .", 
            "title": "rateBreaker"
        }, 
        {
            "location": "/filters/#disablebreaker", 
            "text": "Change (or set) the breaker configurations for an individual route and disable for another, in eskip:  updates: Method( POST )   Host( foo.example.org )\n  -  consecutiveBreaker(9)\n  -   https://foo.backend.net ;\n\nbackendHealthcheck: Path( /healthcheck )\n  -  disableBreaker()\n  -   https://foo.backend.net ;  See also the  circuit breaker docs .", 
            "title": "disableBreaker"
        }, 
        {
            "location": "/filters/#localratelimit", 
            "text": "Per skipper instance calculated ratelimit, that allows number of\nrequests by client. The definition of the same client is based on data\nof the http header and can be changed with an optional third\nparameter. If the third parameter is set skipper will use the\nAuthorization header to put the request in the same client bucket,\nelse  the X-Forwarded-For Header will be used.  Parameters:   number of allowed requests per time period (int)  time period for requests being counted (time.Duration)  optional parameter can be set to: \"auth\" (string)   localRatelimit(3,  1m )\nlocalRatelimit(3,  1m ,  auth )  See also the  ratelimit docs .", 
            "title": "localRatelimit"
        }, 
        {
            "location": "/filters/#ratelimit", 
            "text": "Per skipper instance calculated ratelimit, that allows number of\nrequests to a backend.  Parameters:   number of allowed requests per time period (int)  time period for requests being counted (time.Duration)   ratelimit(20,  1m )\nratelimit(300,  1h )  See also the  ratelimit docs .", 
            "title": "ratelimit"
        }, 
        {
            "location": "/filters/#lua", 
            "text": "See  the scripts page", 
            "title": "lua"
        }, 
        {
            "location": "/filters/#corsorigin", 
            "text": "The filter accepts an optional variadic list of acceptable origin\nparameters. If the input argument list is empty, the header will\nalways be set to  *  which means any origin is acceptable. Otherwise\nthe header is only set if the request contains an Origin header and\nits value matches one of the elements in the input list. The header is\nonly set on the response.  Parameters:   url (variadic string)   Examples:  corsOrigin()\ncorsOrigin( https://www.example.org )\ncorsOrigin( https://www.example.org ,  http://localhost:9001 )", 
            "title": "corsOrigin"
        }, 
        {
            "location": "/predicates/", 
            "text": "Skipper Predicates\n\n\nThe parameters can be strings, regex or float64 / int\n\n\n\n\nstring\n is a string surrounded by double quotes (\n\"\n)\n\n\nregex\n is a \nre2 regular expression\n, surrounded by \n/\n, e.g. \n/^www\\.example\\.org(:\\d+)?$/\n\n\nint\n / \nfloat64\n are usual (decimal) numbers like \n401\n or \n1.23456\n\n\ntime\n is a string in double quotes, parseable by \ntime.Duration\n)\n\n\n\n\nPredicates are a generic tool and can change the route matching behavior.\nPredicates can be chained using the double ampersand operator \n.\n\n\nExample route with a Host, Method and Path match predicates and a backend:\n\n\nall: Host(\n^my-host-header\\.example\\.org$\n) \n Method(\nGET\n) \n Path(\n/hello\n) -\n \nhttp://127.0.0.1:1234/\n;\n\n\n\n\nPath\n\n\nThe route definitions may contain a single path condition, optionally\nwith wildcards, used for looking up routes in the lookup tree.\n\n\nParameters:\n\n\n\n\nPath (string) can contain a wildcard \n*\n or a named \n:wildcard\n\n\n\n\nExamples:\n\n\nPath(\n/foo/bar\n)\nPath(\n/foo/:bar\n)\nPath(\n/foo*\n)\nPath(\n/foo/*\n)\nPath(\n/foo/**\n)\n\n\n\n\nPathSubtree\n\n\nSimilar to Path, but used to match full subtrees including the path of\nthe definition.\n\n\nPathSubtree(\"/foo\") predicate is equivalent to having routes with\nPath(\"/foo\"), Path(\"/foo/\") and Path(\"/foo/**\") predicates.\n\n\nParameters:\n\n\n\n\nPathSubtree (string)\n\n\n\n\nExamples:\n\n\nPathSubtree(\n/foo/bar\n)\nPathSubtree(\n/\n)\nPathSubtree(\n/foo*\n)\n\n\n\n\nPathRegexp\n\n\nRegular expressions to match the path. It uses Go's standard library\nregexp package to match, which is based on\n\nre2 regular expression syntax\n.\n\n\nParameters:\n\n\n\n\nPathRegexp (regex)\n\n\n\n\nExamples:\n\n\nPathRegexp(\n/^foo\\/bar/\n)\nPathRegexp(\n/foo\\/bar$/\n)\nPathRegexp(\n/foo\\/bar/\n)\nPathRegexp(\n/^foo\\/(bar|qux)/\n)\n\n\n\n\nHost\n\n\nRegular expressions that the host header in the request must match.\n\n\nParameters:\n\n\n\n\nHost (regex)\n\n\n\n\nExamples:\n\n\nHost(\n/^my-host-header\\.example\\.org$/\n)\nHost(\n/header\\.example\\.org$/\n)\n\n\n\n\nMethod\n\n\nThe HTTP method that the request must match. HTTP methods are one of\nGET, HEAD, POST, PUT, DELETE, OPTIONS, CONNECT.\n\n\nParameters:\n\n\n\n\nMethod (string)\n\n\n\n\nExamples:\n\n\nMethod(\nGET\n)\nMethod(\nOPTIONS\n)\n\n\n\n\nHeader\n\n\nA header key and exact value that must be present in the request. Note\nthat Header(\"Key\", \"Value\") is equivalent to HeaderRegexp(\"Key\", \"^Value$\").\n\n\nParameters:\n\n\n\n\nHeader (string, string)\n\n\n\n\nExamples:\n\n\nHeader(\nX-Forwarded-For\n, \n192.168.0.2\n)\nHeader(\nServer\n, \nskipper\n)\n\n\n\n\nHeaderRegexp\n\n\nA header key and a regular expression, where the key must be present\nin the request and one of the associated values must match the\nexpression.\n\n\nParameters:\n\n\n\n\nHeaderRegexp (string, regex)\n\n\n\n\nExamples:\n\n\nHeaderRegexp(\nX-Forwarded-For\n, \n/^192\\.168\\.0\\.[0-2]?[0-9]?[0-9] /\n)\nHeaderRegexp(\nServer\n, \n/skipper/\n)\n\n\n\n\nCookie\n\n\nMatches if the specified cookie is set in the request.\n\n\nParameters:\n\n\n\n\nCookie (string, regex) name and value match\n\n\n\n\nExamples:\n\n\nCookie(\nalpha\n, /^enabled$/)\n\n\n\n\nInterval\n\n\nAn interval implements custom predicates to match routes only during some period of time.\n\n\nThere are three predicates: Between, Before and After. All\npredicates can be created using the date represented as a string in\nRFC3339 format (see https://golang.org/pkg/time/#pkg-constants), int64\nor float64 number. float64 number will be converted into int64 number.\n\n\nAfter\n\n\nMatches if the request is after the specified time\n\n\nParameters:\n\n\n\n\nAfter (string) date string\n\n\nAfter (int) unixtime\n\n\n\n\nExamples:\n\n\nAfter(\n2016-01-01T12:00:00+02:00\n)\nAfter(1451642400)\n\n\n\n\nBefore\n\n\nMatches if the request is before the specified time\n\n\nParameters:\n\n\n\n\nBefore (string) date string\n\n\nBefore (int) unixtime\n\n\n\n\nExamples:\n\n\nBefore(\n2016-01-01T12:00:00+02:00\n)\nBefore(1451642400)\n\n\n\n\nBetween\n\n\nMatches if the request is between the specified timeframe\n\n\nParameters:\n\n\n\n\nBetween (string, string) date string, from - till\n\n\nBetween (int, int) unixtime, from - till\n\n\n\n\nExamples:\n\n\nBetween(\n2016-01-01T12:00:00+02:00\n, \n2016-02-01T12:00:00+02:00\n)\nBetween(1451642400, 1454320800)\n\n\n\n\nQueryParam\n\n\nMatch request based on the Query Params in URL\n\n\nParameters:\n\n\n\n\nQueryParam (string) name\n\n\nQueryParam (string, regex) name and value match\n\n\n\n\nExamples:\n\n\n// matches http://example.org?bb=a\nquery=withvalue\nQueryParam(\nquery\n)\n\n// Even a query param without a value\n// matches http://example.org?bb=a\nquery=\nQueryParam(\nquery\n)\n\n// matches with regexp\n// matches http://example.org?bb=a\nquery=example\nQueryParam(\nquery\n, \n^example$\n)\n\n// matches with regexp and multiple values of query param\n// matches http://example.org?bb=a\nquery=testing\nquery=example\nQueryParam(\nquery\n, \n^example$\n)\n\n\n\n\nSource\n\n\nSource implements a custom predicate to match routes based on\nthe source IP or X-Forwarded-For header of a request.\n\n\nParameters:\n\n\n\n\nSource (string, ..) varargs with IPs or CIDR\n\n\n\n\nExamples:\n\n\n// only match requests from 1.2.3.4\nSource(\n1.2.3.4\n)\n\n// only match requests from 1.2.3.0 - 1.2.3.255\nSource(\n1.2.3.0/24\n)\n\n// only match requests from 1.2.3.4 and the 2.2.2.0/24 network\nSource(\n1.2.3.4\n, \n2.2.2.0/24\n)\n\n\n\n\nSourceFromLast\n\n\nThe same as \nSource\n, but use the last part of the\nX-Forwarded-For header to match the network. This seems to be only\nused in the popular loadbalancers from AWS, ELB and ALB, because they\nput the client-IP as last part of the X-Forwarded-For headers.\n\n\nParameters:\n\n\n\n\nSourceFromLast (string, ..) varargs with IPs or CIDR\n\n\n\n\nExamples:\n\n\nSourceFromLast(\n1.2.3.4\n, \n2.2.2.0/24\n)\n\n\n\n\nTraffic\n\n\nTraffic implements a predicate to control the matching probability for\na given route by setting its weight.\n\n\nThe probability for matching a route is defined by the mandatory first\nparameter, that must be a decimal number between 0.0 and 1.0 (both\nexclusive).\n\n\nThe optional second argument is used to specify the cookie name for\nthe traffic group, in case you want to use stickiness. Stickiness\nallows all subsequent requests from the same client to match the same\nroute. Stickiness of traffic is supported by the optional third\nparameter, indicating whether the request being matched belongs to the\ntraffic group of the current route. If yes, the predicate matches\nignoring the chance argument.\n\n\nParameters:\n\n\n\n\nTraffic (decimal) valid values [0.0, 1.0]\n\n\nTraffic (decimal, string, string) session stickyness\n\n\n\n\nExamples:\n\n\nnon-sticky:\n\n\n// hit by 10% percent chance\nv2:\n    Traffic(.1) -\n\n    \nhttps://api-test-green\n;\n\n// hit by remaining chance\nv1:\n    \nhttps://api-test-blue\n;\n\n\n\n\nstickyness:\n\n\n// hit by 5% percent chance\ncartTest:\n    Traffic(.05, \ncart-test\n, \ntest\n) \n Path(\n/cart\n) -\n\n    responseCookie(\ncart-test\n, \ntest\n) -\n\n    \nhttps://cart-test\n;\n\n// hit by remaining chance\ncart:\n    Path(\n/cart\n) -\n\n    responseCookie(\ncart-test\n, \ndefault\n) -\n\n    \nhttps://cart\n;\n\n// hit by 15% percent chance\ncatalogTestA:\n    Traffic(.15, \ncatalog-test\n, \nA\n) -\n\n    responseCookie(\ncatalog-test\n, \nA\n) -\n\n    \nhttps://catalog-test-a\n;\n\n// hit by 30% percent chance\ncatalogTestB:\n    Traffic(.3, \ncatalog-test\n, \nB\n) -\n\n    responseCookie(\ncatalog-test\n, \nB\n) -\n\n    \nhttps://catalog-test-b\n;\n\n// hit by remaining chance\ncatalog:\n    * -\n\n    responseCookie(\ncatalog-test\n, \ndefault\n) -\n\n    \nhttps://catalog\n;", 
            "title": "Predicates"
        }, 
        {
            "location": "/predicates/#skipper-predicates", 
            "text": "The parameters can be strings, regex or float64 / int   string  is a string surrounded by double quotes ( \" )  regex  is a  re2 regular expression , surrounded by  / , e.g.  /^www\\.example\\.org(:\\d+)?$/  int  /  float64  are usual (decimal) numbers like  401  or  1.23456  time  is a string in double quotes, parseable by  time.Duration )   Predicates are a generic tool and can change the route matching behavior.\nPredicates can be chained using the double ampersand operator  .  Example route with a Host, Method and Path match predicates and a backend:  all: Host( ^my-host-header\\.example\\.org$ )   Method( GET )   Path( /hello ) -   http://127.0.0.1:1234/ ;", 
            "title": "Skipper Predicates"
        }, 
        {
            "location": "/predicates/#path", 
            "text": "The route definitions may contain a single path condition, optionally\nwith wildcards, used for looking up routes in the lookup tree.  Parameters:   Path (string) can contain a wildcard  *  or a named  :wildcard   Examples:  Path( /foo/bar )\nPath( /foo/:bar )\nPath( /foo* )\nPath( /foo/* )\nPath( /foo/** )", 
            "title": "Path"
        }, 
        {
            "location": "/predicates/#pathsubtree", 
            "text": "Similar to Path, but used to match full subtrees including the path of\nthe definition.  PathSubtree(\"/foo\") predicate is equivalent to having routes with\nPath(\"/foo\"), Path(\"/foo/\") and Path(\"/foo/**\") predicates.  Parameters:   PathSubtree (string)   Examples:  PathSubtree( /foo/bar )\nPathSubtree( / )\nPathSubtree( /foo* )", 
            "title": "PathSubtree"
        }, 
        {
            "location": "/predicates/#pathregexp", 
            "text": "Regular expressions to match the path. It uses Go's standard library\nregexp package to match, which is based on re2 regular expression syntax .  Parameters:   PathRegexp (regex)   Examples:  PathRegexp( /^foo\\/bar/ )\nPathRegexp( /foo\\/bar$/ )\nPathRegexp( /foo\\/bar/ )\nPathRegexp( /^foo\\/(bar|qux)/ )", 
            "title": "PathRegexp"
        }, 
        {
            "location": "/predicates/#host", 
            "text": "Regular expressions that the host header in the request must match.  Parameters:   Host (regex)   Examples:  Host( /^my-host-header\\.example\\.org$/ )\nHost( /header\\.example\\.org$/ )", 
            "title": "Host"
        }, 
        {
            "location": "/predicates/#method", 
            "text": "The HTTP method that the request must match. HTTP methods are one of\nGET, HEAD, POST, PUT, DELETE, OPTIONS, CONNECT.  Parameters:   Method (string)   Examples:  Method( GET )\nMethod( OPTIONS )", 
            "title": "Method"
        }, 
        {
            "location": "/predicates/#header", 
            "text": "A header key and exact value that must be present in the request. Note\nthat Header(\"Key\", \"Value\") is equivalent to HeaderRegexp(\"Key\", \"^Value$\").  Parameters:   Header (string, string)   Examples:  Header( X-Forwarded-For ,  192.168.0.2 )\nHeader( Server ,  skipper )", 
            "title": "Header"
        }, 
        {
            "location": "/predicates/#headerregexp", 
            "text": "A header key and a regular expression, where the key must be present\nin the request and one of the associated values must match the\nexpression.  Parameters:   HeaderRegexp (string, regex)   Examples:  HeaderRegexp( X-Forwarded-For ,  /^192\\.168\\.0\\.[0-2]?[0-9]?[0-9] / )\nHeaderRegexp( Server ,  /skipper/ )", 
            "title": "HeaderRegexp"
        }, 
        {
            "location": "/predicates/#cookie", 
            "text": "Matches if the specified cookie is set in the request.  Parameters:   Cookie (string, regex) name and value match   Examples:  Cookie( alpha , /^enabled$/)", 
            "title": "Cookie"
        }, 
        {
            "location": "/predicates/#interval", 
            "text": "An interval implements custom predicates to match routes only during some period of time.  There are three predicates: Between, Before and After. All\npredicates can be created using the date represented as a string in\nRFC3339 format (see https://golang.org/pkg/time/#pkg-constants), int64\nor float64 number. float64 number will be converted into int64 number.", 
            "title": "Interval"
        }, 
        {
            "location": "/predicates/#after", 
            "text": "Matches if the request is after the specified time  Parameters:   After (string) date string  After (int) unixtime   Examples:  After( 2016-01-01T12:00:00+02:00 )\nAfter(1451642400)", 
            "title": "After"
        }, 
        {
            "location": "/predicates/#before", 
            "text": "Matches if the request is before the specified time  Parameters:   Before (string) date string  Before (int) unixtime   Examples:  Before( 2016-01-01T12:00:00+02:00 )\nBefore(1451642400)", 
            "title": "Before"
        }, 
        {
            "location": "/predicates/#between", 
            "text": "Matches if the request is between the specified timeframe  Parameters:   Between (string, string) date string, from - till  Between (int, int) unixtime, from - till   Examples:  Between( 2016-01-01T12:00:00+02:00 ,  2016-02-01T12:00:00+02:00 )\nBetween(1451642400, 1454320800)", 
            "title": "Between"
        }, 
        {
            "location": "/predicates/#queryparam", 
            "text": "Match request based on the Query Params in URL  Parameters:   QueryParam (string) name  QueryParam (string, regex) name and value match   Examples:  // matches http://example.org?bb=a query=withvalue\nQueryParam( query )\n\n// Even a query param without a value\n// matches http://example.org?bb=a query=\nQueryParam( query )\n\n// matches with regexp\n// matches http://example.org?bb=a query=example\nQueryParam( query ,  ^example$ )\n\n// matches with regexp and multiple values of query param\n// matches http://example.org?bb=a query=testing query=example\nQueryParam( query ,  ^example$ )", 
            "title": "QueryParam"
        }, 
        {
            "location": "/predicates/#source", 
            "text": "Source implements a custom predicate to match routes based on\nthe source IP or X-Forwarded-For header of a request.  Parameters:   Source (string, ..) varargs with IPs or CIDR   Examples:  // only match requests from 1.2.3.4\nSource( 1.2.3.4 )\n\n// only match requests from 1.2.3.0 - 1.2.3.255\nSource( 1.2.3.0/24 )\n\n// only match requests from 1.2.3.4 and the 2.2.2.0/24 network\nSource( 1.2.3.4 ,  2.2.2.0/24 )", 
            "title": "Source"
        }, 
        {
            "location": "/predicates/#sourcefromlast", 
            "text": "The same as  Source , but use the last part of the\nX-Forwarded-For header to match the network. This seems to be only\nused in the popular loadbalancers from AWS, ELB and ALB, because they\nput the client-IP as last part of the X-Forwarded-For headers.  Parameters:   SourceFromLast (string, ..) varargs with IPs or CIDR   Examples:  SourceFromLast( 1.2.3.4 ,  2.2.2.0/24 )", 
            "title": "SourceFromLast"
        }, 
        {
            "location": "/predicates/#traffic", 
            "text": "Traffic implements a predicate to control the matching probability for\na given route by setting its weight.  The probability for matching a route is defined by the mandatory first\nparameter, that must be a decimal number between 0.0 and 1.0 (both\nexclusive).  The optional second argument is used to specify the cookie name for\nthe traffic group, in case you want to use stickiness. Stickiness\nallows all subsequent requests from the same client to match the same\nroute. Stickiness of traffic is supported by the optional third\nparameter, indicating whether the request being matched belongs to the\ntraffic group of the current route. If yes, the predicate matches\nignoring the chance argument.  Parameters:   Traffic (decimal) valid values [0.0, 1.0]  Traffic (decimal, string, string) session stickyness   Examples:  non-sticky:  // hit by 10% percent chance\nv2:\n    Traffic(.1) - \n     https://api-test-green ;\n\n// hit by remaining chance\nv1:\n     https://api-test-blue ;  stickyness:  // hit by 5% percent chance\ncartTest:\n    Traffic(.05,  cart-test ,  test )   Path( /cart ) - \n    responseCookie( cart-test ,  test ) - \n     https://cart-test ;\n\n// hit by remaining chance\ncart:\n    Path( /cart ) - \n    responseCookie( cart-test ,  default ) - \n     https://cart ;\n\n// hit by 15% percent chance\ncatalogTestA:\n    Traffic(.15,  catalog-test ,  A ) - \n    responseCookie( catalog-test ,  A ) - \n     https://catalog-test-a ;\n\n// hit by 30% percent chance\ncatalogTestB:\n    Traffic(.3,  catalog-test ,  B ) - \n    responseCookie( catalog-test ,  B ) - \n     https://catalog-test-b ;\n\n// hit by remaining chance\ncatalog:\n    * - \n    responseCookie( catalog-test ,  default ) - \n     https://catalog ;", 
            "title": "Traffic"
        }, 
        {
            "location": "/scripts/", 
            "text": "Lua filter scripts\n\n\nLUA\n scripts can be used as filters in skipper. The\ncurrent implementation supports \nLua 5.1\n.\n\n\nRoute filters\n\n\nThe lua scripts can be added to a route description with the lua() filter,\nthe first parameter for the filter is the script. This can be either a file\nname (ending with \n.lua\n) or inline code, e.g. as\n\n\n\n\nfile \nlua(\"/path/to/file.lua\")\n - if a file path is not absolute, the path\n is relative to skipper's working directory.\n\n\ninline \nlua(\"function request(c, p); print(c.request.url); end\")\n\n\n\n\nAny other additional parameters for the filter must be \nkey=value\n strings.\nThese will be passed as table to the called functions as second parameter.\n\nNOTE\n: Any parameter starting with \"lua-\" should not be used to pass\nvalues for the script - those will be used for configuring the filter.\n\n\nScript requirements\n\n\nA filter script needs at least one global function: \nrequest\n or \nresponse\n.\nIf present, they are called with a skipper filter context and the params passed\nin the route as table like\n\n\n-- route looks like\n--\n-- any: * -\n lua(\n./test.lua\n, \nmyparam=foo\n, \nother=bar\n) -\n \nshunt\n\n--\nfunction request(ctx, params)\n    print(ctx.request.method .. \n \n .. ctx.request.url .. \n -\n \n .. params.myparam)\nend\n\n\n\n\nAvailable lua modules\n\n\nBesides the \nstandard modules\n - except\nfor \ndebug\n - the following modules have been preloaded and can be used with e.g.\n\nlocal http = require(\"http\")\n, see also the examples below\n\n\n\n\nhttp\n \ngluahttp\n - TODO: configurable\n with something different than \nhttp.Client{}\n\n\nurl\n  \ngluaurl\n\n\njson\n \ngopher-json\n\n\nbase64\n \nlua base64\n\n\n\n\nFor differences between the standard modules and the gopher-lua implementation\ncheck the \ngopher-lua documentation\n.\n\n\nAny other module can be loaded in non-byte code form from the lua path (by default\nfor \nrequire(\"mod\")\n this is \n./mod.lua\n, \n/usr/local/share/lua/5.1/mod.lua\n and\n\n/usr/local/share/lua/5.1/mod/init.lua\n).\n\n\nLua states\n\n\nThere is no guarantee that the \nrequest()\n and \nresponse()\n functions of a\nlua script run in the same lua state during one request. Setting a variable\nin the request and accessing it in the response will most likely fail and lead\nto hard debuggable errors. Use the \nctx.state_bag\n to propagate values from\n\nrequest\n to \nresponse\n - and any other filter in the chain.\n\n\nRequest\n\n\nThe \nrequest()\n function is run for an incoming request.\n\n\nHeaders\n\n\nRequest headers can be accessed by accessing the \nctx.request.header\n map like\n\n\nua = ctx.request.header[\nuser-agent\n]\n\n\n\n\nHeader names are normalized by the \nnet/http\n go module\n\nlike usual\n. Setting a\nheader is done by assigning to the headers map. Setting a header to \nnil\n or\nan empty string deletes the header - setting to \nnil\n is preferred.\n\n\nctx.request.header[\nuser-agent\n] = \nskipper.lua/0.0.1\n\nctx.request.header[\nAuthorization\n] = nil -- delete authorization header\n\n\n\n\nResponse headers work the same way by accessing / assigning to\n\nctx.response.header\n - this is of course only valid in the \nresponse()\n phase.\n\n\nOther request fields\n\n\n\n\nbackend_url\n - (read only) returns the backend url specified in the route\n  or an empty value in case it's a shunt or loopback\n\n\noutgoing_host\n - (read/write) the host that will be set for the outgoing\n  proxy request as the 'Host' header.\n\n\nremote_addr\n - (read only) the remote host, usually IP:port\n\n\ncontent_length\n - (read only) content length\n\n\nproto\n - (read only) something like \"HTTP/1.1\"\n\n\nmethod\n - (read only) request method, e.g. \"GET\" or \"POST\"\n\n\nurl\n - (read/write) request URL as string\n\n\n\n\nServing requests from lua\n\n\nRequests can be served with \nctx.serve(table)\n, you must return after this\ncall. Possible keys for the table:\n\n\n\n\nstatus_code\n (number) - required (but currently not enforced)\n\n\nheader\n (table)\n\n\nbody\n (string)\n\n\n\n\nSee also \nredirect\n and \ninternal server error\n\nexamples below\n\n\nStateBag\n\n\nThe state bag can be used to pass values from one filter to another in the same\nchain. It is shared by all filters in one request.\n\n\nfunction request(ctx, params)\n    -- the value of \nmykey\n will be available to all filters in the chain now:\n    ctx.state_bag[\nmykey\n] = \nfoo\n\nend\n\nfunction response(ctx, params)\n    print(ctx.state_bag[\nmykey\n])\nend\n\n\n\n\nExamples\n\n\nNote: the examples serve as examples. If there is a go based plugin available,\nuse that instead. The overhead of calling lua is 4-5 times slower than pure go.\n\n\nOAuth2 token as basic auth password\n\n\nlocal base64 = require(\nbase64\n)\n\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[\nAuthorization\n], \n^%s*[Bb]earer%s+\n, \n, 1)\n    user = ctx.request.header[\nx-username\n]\n    if user == \n then\n        user = params.username\n    end\n    ctx.request.header[\nAuthorization\n] = \nBasic \n .. base64.encode(user .. \n:\n  .. token)\n    -- print(ctx.request.header[\nAuthorization\n])\nend\n\n\n\n\nvalidate token\n\n\nlocal http = require(\nhttp\n)\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[\nAuthorization\n], \n^%s*[Bb]earer%s+\n, \n, 1)\n    if token == \n then\n        ctx.serve({status_code=401, body=\nMissing Token\n})\n        return\n    end\n\n    res, err = http.get(\nhttps://auth.example.com/oauth2/tokeninfo?access_token=\n..token)\n    if err ~= nil then\n        print(\nFailed to get tokeninfo: \n .. err)\n        ctx.serve({status_code=401, body=\nFailed to validate token: \n..err})\n        return\n    end\n    if res.status_code ~= 200 then\n        ctx.serve({status_code=401, body=\nInvalid token\n})\n        return\n    end\nend\n\n\n\n\nstrip query\n\n\nfunction request(ctx, params)\n    ctx.request.url = string.gsub(ctx.request.url, \n%?.*$\n, \n)\n    -- print(\nURL=\n..ctx.request.url)\nend\n\n\n\n\nredirect\n\n\nfunction request(ctx, params)\n    ctx.serve({\n        status_code=302,\n        header={\n            location=\nhttp://www.example.org/\n,\n        },\n    })\nend\n\n\n\n\ninternal server error\n\n\nfunction request(ctx, params)\n    -- let 10% of all requests fail with 500\n    if math.random() \n 0.1 then\n        ctx.serve({\n            status_code=500,\n            body=\nInternal Server Error.\\n\n,\n        })\n    end\nend\n\n\n\n\nBenchmark\n\n\nredirectTo vs lua redirect\n\n\nSee skptesting/benchmark-lua.sh\n\n\nRoute for \"skipper\" is \n* -\n redirectTo(\"http://localhost:9980\") -\n \nshunt\n,\nroute for \"lua\" is \n* -\n lua(\"function request(c,p); c.serve({status_code=302, header={location='http://localhost:9980'}});end\") -\n \nshunt\n\n\n[benchmarking skipper]\nRunning 12s test @ http://127.0.0.1:9990/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     6.75ms   14.22ms 260.28ms   92.19%\n    Req/Sec    23.87k     2.93k   32.22k    70.42%\n  572695 requests in 12.06s, 100.49MB read\n  Non-2xx or 3xx responses: 572695\nRequests/sec:  47474.31\nTransfer/sec:      8.33MB\n[benchmarking skipper done]\n\n[benchmarking lua]\nRunning 12s test @ http://127.0.0.1:9991/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    38.31ms   53.48ms 580.80ms   83.69%\n    Req/Sec     5.44k     1.03k    8.23k    71.25%\n  130123 requests in 12.01s, 20.97MB read\nRequests/sec:  10831.94\nTransfer/sec:      1.75MB\n[benchmarking lua done]\n\n\n\n\nThe benchmark was run with the default pool size of \nscript.InitialPoolSize = 3; script.MaxPoolSize = 10\n.\nWith \nscript.InitialPoolSize = 128; script.MaxPoolSize = 128\n (tweaked for this benchmark) you get about 12k req/s in lua.\n\n\nSimilar results are achieved when testing \nstripQuery()\n vs the lua version from above.", 
            "title": "Scripts"
        }, 
        {
            "location": "/scripts/#lua-filter-scripts", 
            "text": "LUA  scripts can be used as filters in skipper. The\ncurrent implementation supports  Lua 5.1 .", 
            "title": "Lua filter scripts"
        }, 
        {
            "location": "/scripts/#route-filters", 
            "text": "The lua scripts can be added to a route description with the lua() filter,\nthe first parameter for the filter is the script. This can be either a file\nname (ending with  .lua ) or inline code, e.g. as   file  lua(\"/path/to/file.lua\")  - if a file path is not absolute, the path\n is relative to skipper's working directory.  inline  lua(\"function request(c, p); print(c.request.url); end\")   Any other additional parameters for the filter must be  key=value  strings.\nThese will be passed as table to the called functions as second parameter. NOTE : Any parameter starting with \"lua-\" should not be used to pass\nvalues for the script - those will be used for configuring the filter.", 
            "title": "Route filters"
        }, 
        {
            "location": "/scripts/#script-requirements", 
            "text": "A filter script needs at least one global function:  request  or  response .\nIf present, they are called with a skipper filter context and the params passed\nin the route as table like  -- route looks like\n--\n-- any: * -  lua( ./test.lua ,  myparam=foo ,  other=bar ) -   shunt \n--\nfunction request(ctx, params)\n    print(ctx.request.method ..     .. ctx.request.url ..   -    .. params.myparam)\nend", 
            "title": "Script requirements"
        }, 
        {
            "location": "/scripts/#available-lua-modules", 
            "text": "Besides the  standard modules  - except\nfor  debug  - the following modules have been preloaded and can be used with e.g. local http = require(\"http\") , see also the examples below   http   gluahttp  - TODO: configurable\n with something different than  http.Client{}  url    gluaurl  json   gopher-json  base64   lua base64   For differences between the standard modules and the gopher-lua implementation\ncheck the  gopher-lua documentation .  Any other module can be loaded in non-byte code form from the lua path (by default\nfor  require(\"mod\")  this is  ./mod.lua ,  /usr/local/share/lua/5.1/mod.lua  and /usr/local/share/lua/5.1/mod/init.lua ).", 
            "title": "Available lua modules"
        }, 
        {
            "location": "/scripts/#lua-states", 
            "text": "There is no guarantee that the  request()  and  response()  functions of a\nlua script run in the same lua state during one request. Setting a variable\nin the request and accessing it in the response will most likely fail and lead\nto hard debuggable errors. Use the  ctx.state_bag  to propagate values from request  to  response  - and any other filter in the chain.", 
            "title": "Lua states"
        }, 
        {
            "location": "/scripts/#request", 
            "text": "The  request()  function is run for an incoming request.", 
            "title": "Request"
        }, 
        {
            "location": "/scripts/#headers", 
            "text": "Request headers can be accessed by accessing the  ctx.request.header  map like  ua = ctx.request.header[ user-agent ]  Header names are normalized by the  net/http  go module like usual . Setting a\nheader is done by assigning to the headers map. Setting a header to  nil  or\nan empty string deletes the header - setting to  nil  is preferred.  ctx.request.header[ user-agent ] =  skipper.lua/0.0.1 \nctx.request.header[ Authorization ] = nil -- delete authorization header  Response headers work the same way by accessing / assigning to ctx.response.header  - this is of course only valid in the  response()  phase.", 
            "title": "Headers"
        }, 
        {
            "location": "/scripts/#other-request-fields", 
            "text": "backend_url  - (read only) returns the backend url specified in the route\n  or an empty value in case it's a shunt or loopback  outgoing_host  - (read/write) the host that will be set for the outgoing\n  proxy request as the 'Host' header.  remote_addr  - (read only) the remote host, usually IP:port  content_length  - (read only) content length  proto  - (read only) something like \"HTTP/1.1\"  method  - (read only) request method, e.g. \"GET\" or \"POST\"  url  - (read/write) request URL as string", 
            "title": "Other request fields"
        }, 
        {
            "location": "/scripts/#serving-requests-from-lua", 
            "text": "Requests can be served with  ctx.serve(table) , you must return after this\ncall. Possible keys for the table:   status_code  (number) - required (but currently not enforced)  header  (table)  body  (string)   See also  redirect  and  internal server error \nexamples below", 
            "title": "Serving requests from lua"
        }, 
        {
            "location": "/scripts/#statebag", 
            "text": "The state bag can be used to pass values from one filter to another in the same\nchain. It is shared by all filters in one request.  function request(ctx, params)\n    -- the value of  mykey  will be available to all filters in the chain now:\n    ctx.state_bag[ mykey ] =  foo \nend\n\nfunction response(ctx, params)\n    print(ctx.state_bag[ mykey ])\nend", 
            "title": "StateBag"
        }, 
        {
            "location": "/scripts/#examples", 
            "text": "Note: the examples serve as examples. If there is a go based plugin available,\nuse that instead. The overhead of calling lua is 4-5 times slower than pure go.", 
            "title": "Examples"
        }, 
        {
            "location": "/scripts/#oauth2-token-as-basic-auth-password", 
            "text": "local base64 = require( base64 )\n\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[ Authorization ],  ^%s*[Bb]earer%s+ ,  , 1)\n    user = ctx.request.header[ x-username ]\n    if user ==   then\n        user = params.username\n    end\n    ctx.request.header[ Authorization ] =  Basic   .. base64.encode(user ..  :   .. token)\n    -- print(ctx.request.header[ Authorization ])\nend", 
            "title": "OAuth2 token as basic auth password"
        }, 
        {
            "location": "/scripts/#validate-token", 
            "text": "local http = require( http )\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[ Authorization ],  ^%s*[Bb]earer%s+ ,  , 1)\n    if token ==   then\n        ctx.serve({status_code=401, body= Missing Token })\n        return\n    end\n\n    res, err = http.get( https://auth.example.com/oauth2/tokeninfo?access_token= ..token)\n    if err ~= nil then\n        print( Failed to get tokeninfo:   .. err)\n        ctx.serve({status_code=401, body= Failed to validate token:  ..err})\n        return\n    end\n    if res.status_code ~= 200 then\n        ctx.serve({status_code=401, body= Invalid token })\n        return\n    end\nend", 
            "title": "validate token"
        }, 
        {
            "location": "/scripts/#strip-query", 
            "text": "function request(ctx, params)\n    ctx.request.url = string.gsub(ctx.request.url,  %?.*$ ,  )\n    -- print( URL= ..ctx.request.url)\nend", 
            "title": "strip query"
        }, 
        {
            "location": "/scripts/#redirect", 
            "text": "function request(ctx, params)\n    ctx.serve({\n        status_code=302,\n        header={\n            location= http://www.example.org/ ,\n        },\n    })\nend", 
            "title": "redirect"
        }, 
        {
            "location": "/scripts/#internal-server-error", 
            "text": "function request(ctx, params)\n    -- let 10% of all requests fail with 500\n    if math.random()   0.1 then\n        ctx.serve({\n            status_code=500,\n            body= Internal Server Error.\\n ,\n        })\n    end\nend", 
            "title": "internal server error"
        }, 
        {
            "location": "/scripts/#benchmark", 
            "text": "", 
            "title": "Benchmark"
        }, 
        {
            "location": "/scripts/#redirectto-vs-lua-redirect", 
            "text": "See skptesting/benchmark-lua.sh  Route for \"skipper\" is  * -  redirectTo(\"http://localhost:9980\") -   shunt ,\nroute for \"lua\" is  * -  lua(\"function request(c,p); c.serve({status_code=302, header={location='http://localhost:9980'}});end\") -   shunt  [benchmarking skipper]\nRunning 12s test @ http://127.0.0.1:9990/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     6.75ms   14.22ms 260.28ms   92.19%\n    Req/Sec    23.87k     2.93k   32.22k    70.42%\n  572695 requests in 12.06s, 100.49MB read\n  Non-2xx or 3xx responses: 572695\nRequests/sec:  47474.31\nTransfer/sec:      8.33MB\n[benchmarking skipper done]\n\n[benchmarking lua]\nRunning 12s test @ http://127.0.0.1:9991/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    38.31ms   53.48ms 580.80ms   83.69%\n    Req/Sec     5.44k     1.03k    8.23k    71.25%\n  130123 requests in 12.01s, 20.97MB read\nRequests/sec:  10831.94\nTransfer/sec:      1.75MB\n[benchmarking lua done]  The benchmark was run with the default pool size of  script.InitialPoolSize = 3; script.MaxPoolSize = 10 .\nWith  script.InitialPoolSize = 128; script.MaxPoolSize = 128  (tweaked for this benchmark) you get about 12k req/s in lua.  Similar results are achieved when testing  stripQuery()  vs the lua version from above.", 
            "title": "redirectTo vs lua redirect"
        }, 
        {
            "location": "/plugins/", 
            "text": "Skipper plugins\n\n\nSkipper may be extended with functionality not present in the core.\nThese additions can be built as go plugin, so they do not have to\nbe present in the main skipper repository.\n\n\nNote the warning from Go's plugin.go:\n\n\n// The plugin support is currently incomplete, only supports Linux,\n// and has known bugs. Please report any issues.\n\n\n\nPlugin directories\n\n\nPlugins are loaded from sub directories of the plugin directories. By default\nthe plugin directory is set to \n./plugins\n (i.e. relative to skipper's working\ndirectory). An additional directory may be given with the \n-plugindir=/path/to/dir\n\noption to skipper.\n\n\nAny file with the suffix \n.so\n found below the plugin directories (also in sub\ndirectories) is attempted to load without any arguments. When a plugin needs an\nargument, this must be explicitly loaded and the arguments passed, e.g. with\n\n-filter-plugin geoip,db=/path/to/db\n.\n\n\nBuilding a plugin\n\n\nEach plugin should be built with\n\n\ngo build -buildmode=plugin -o example.so example.go\n\n\n\nThere are some pitfalls:\n\n\n\n\npackages which are shared between skipper and the plugin \nmust not\n be in\n  a \nvendor/\n directory, otherwise the plugin will fail to load or in some\n  cases give wrong results (e.g. an opentracing span cannot be found in the\n  context even if it is present). This also means:\n  Do not vendor skipper in a plugin repo...\n\n\nplugins must be rebuilt when skipper is rebuilt\n\n\ndo not attempt to rebuild a module and copy it over a loaded plugin, that\n  will crash skipper immediately...\n\n\n\n\nFilter plugins\n\n\nAll plugins must have a function named \nInitFilter\n with the following signature\n\n\nfunc([]string) (filters.Spec, error)\n\n\n\nThe parameters passed are all arguments for the plugin, i.e. everything after the first\nword from skipper's \n-filter-plugin\n parameter. E.g. when the \n-filter-plugin\n \nparameter is\n\n\nmyfilter,datafile=/path/to/file,foo=bar\n\n\n\nthe \nmyfilter\n plugin will receive\n\n\n[]string{\"datafile=/path/to/file\", \"foo=bar\"}\n\n\n\nas arguments.\n\n\nThe filter plugin implementation is responsible to parse the received arguments.\n\n\nFilter plugins can be found in the \nfilter repo\n\n\nExample filter plugin\n\n\nAn example \nnoop\n plugin looks like\n\n\npackage main\n\nimport (\n    \ngithub.com/zalando/skipper/filters\n\n)\n\ntype noopSpec struct{}\n\nfunc InitFilter(opts []string) (filters.Spec, error) {\n    return noopSpec{}, nil\n}\n\nfunc (s noopSpec) Name() string {\n    return \nnoop\n\n}\nfunc (s noopSpec) CreateFilter(config []interface{}) (filters.Filter, error) {\n    return noopFilter{}, nil\n}\n\ntype noopFilter struct{}\n\nfunc (f noopFilter) Request(filters.FilterContext)  {}\nfunc (f noopFilter) Response(filters.FilterContext) {}\n\n\n\n\nPredicate plugins\n\n\nAll plugins must have a function named \nInitPredicate\n with the following signature\n\n\nfunc([]string) (routing.PredicateSpec, error)\n\n\n\nThe parameters passed are all arguments for the plugin, i.e. everything after the first\nword from skipper's \n-predicate-plugin\n parameter. E.g. when the \n-predicate-plugin\n \nparameter is\n\n\nmypred,datafile=/path/to/file,foo=bar\n\n\n\nthe \nmypred\n plugin will receive\n\n\n[]string{\"datafile=/path/to/file\", \"foo=bar\"}\n\n\n\nas arguments.\n\n\nThe predicate plugin implementation is responsible to parse the received arguments.\n\n\nPredicate plugins can be found in the \npredicate repo\n\n\nExample predicate plugin\n\n\nAn example \nMatchAll\n plugin looks like\n\n\npackage main\n\nimport (\n    \ngithub.com/zalando/skipper/routing\n\n    \nnet/http\n\n)\n\ntype noopSpec struct{}\n\nfunc InitPredicate(opts []string) (routing.PredicateSpec, error) {\n    return noopSpec{}, nil\n}\n\nfunc (s noopSpec) Name() string {\n    return \nMatchAll\n\n}\nfunc (s noopSpec) Create(config []interface{}) (routing.Predicate, error) {\n    return noopPredicate{}, nil\n}\n\ntype noopPredicate struct{}\n\nfunc (p noopPredicate) Match(*http.Request) bool {\n    return true\n}\n\n\n\n\nDataClient plugins\n\n\nSimilar to the above predicate and filter plugins. The command line option for data\nclient plugins is \n-dataclient-plugin\n. The module must have a \nInitDataClient\n\nfunction with the signature\n\n\nfunc([]string) (routing.DataClient, error)\n\n\n\nA \nnoop\n data client looks like\n\n\npackage main\n\nimport (\n    \ngithub.com/zalando/skipper/eskip\n\n    \ngithub.com/zalando/skipper/routing\n\n)\n\nfunc InitDataClient([]string) (routing.DataClient, error) {\n    var dc DataClient = \n\n    return dc, nil\n}\n\ntype DataClient string\n\nfunc (dc DataClient) LoadAll() ([]*eskip.Route, error) {\n    return eskip.Parse(string(dc))\n}\n\nfunc (dc DataClient) LoadUpdate() ([]*eskip.Route, []string, error) {\n    return nil, nil, nil\n}\n\n\n\n\nMultiType plugins\n\n\nSometimes it is necessary to combine multiple plugin types into one module. This can\nbe done with this kind of plugin. Note that these modules are not auto loaded, these\nneed an explicit \n-multi-plugin name,arg1,arg2\n command line switch for skipper.\n\n\nThe module must have a \nInitPlugin\n function with the signature\n\n\nfunc([]string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error)\n\n\n\nAny of the returned types may be nil, so you can have e.g. a combined filter / data client\nplugin or share a filter and a predicate, e.g. like\n\n\npackage main\n\nimport (\n    \nfmt\n\n    \nnet\n\n    \nnet/http\n\n    \nstrconv\n\n    \nstrings\n\n\n    ot \ngithub.com/opentracing/opentracing-go\n\n    maxminddb \ngithub.com/oschwald/maxminddb-golang\n\n\n    \ngithub.com/zalando/skipper/filters\n\n    snet \ngithub.com/zalando/skipper/net\n\n    \ngithub.com/zalando/skipper/predicates\n\n    \ngithub.com/zalando/skipper/routing\n\n)\n\ntype geoipSpec struct {\n    db   *maxminddb.Reader\n    name string\n}\n\nfunc InitPlugin(opts []string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error) {\n    var db string\n    for _, o := range opts {\n        switch {\n        case strings.HasPrefix(o, \ndb=\n):\n            db = o[3:]\n        }\n    }\n    if db == \n {\n        return nil, nil, nil, fmt.Errorf(\nmissing db= parameter for geoip plugin\n)\n    }\n    reader, err := maxminddb.Open(db)\n    if err != nil {\n        return nil, nil, nil, fmt.Errorf(\nfailed to open db %s: %s\n, db, err)\n    }\n\n    return []filters.Spec{\ngeoipSpec{db: reader, name: \ngeoip\n}},\n        []routing.PredicateSpec{\ngeoipSpec{db: reader, name: \nGeoIP\n}},\n        nil,\n        nil\n}\n\nfunc (s *geoipSpec) Name() string {\n    return s.name\n}\n\nfunc (s *geoipSpec) CreateFilter(config []interface{}) (filters.Filter, error) {\n    var fromLast bool\n    header := \nX-GeoIP-Country\n\n    var err error\n    for _, c := range config {\n        if s, ok := c.(string); ok {\n            switch {\n            case strings.HasPrefix(s, \nfrom_last=\n):\n                fromLast, err = strconv.ParseBool(s[10:])\n                if err != nil {\n                    return nil, filters.ErrInvalidFilterParameters\n                }\n            case strings.HasPrefix(s, \nheader=\n):\n                header = s[7:]\n            }\n        }\n    }\n    return \ngeoip{db: s.db, fromLast: fromLast, header: header}, nil\n}\n\nfunc (s *geoipSpec) Create(config []interface{}) (routing.Predicate, error) {\n    var fromLast bool\n    var err error\n    countries := make(map[string]struct{})\n    for _, c := range config {\n        if s, ok := c.(string); ok {\n            switch {\n            case strings.HasPrefix(s, \nfrom_last=\n):\n                fromLast, err = strconv.ParseBool(s[10:])\n                if err != nil {\n                    return nil, predicates.ErrInvalidPredicateParameters\n                }\n            default:\n                countries[strings.ToUpper(s)] = struct{}{}\n            }\n        }\n    }\n    return \ngeoip{db: s.db, fromLast: fromLast, countries: countries}, nil\n}\n\ntype geoip struct {\n    db        *maxminddb.Reader\n    fromLast  bool\n    header    string\n    countries map[string]struct{}\n}\n\ntype countryRecord struct {\n    Country struct {\n        ISOCode string `maxminddb:\niso_code\n`\n    } `maxminddb:\ncountry\n`\n}\n\nfunc (g *geoip) lookup(r *http.Request) string {\n    var src net.IP\n    if g.fromLast {\n        src = snet.RemoteHostFromLast(r)\n    } else {\n        src = snet.RemoteHost(r)\n    }\n\n    record := countryRecord{}\n    err := g.db.Lookup(src, \nrecord)\n    if err != nil {\n        fmt.Printf(\ngeoip(): failed to lookup %s: %s\n, src, err)\n    }\n    if record.Country.ISOCode == \n {\n        return \nUNKNOWN\n\n    }\n    return record.Country.ISOCode\n}\n\nfunc (g *geoip) Request(c filters.FilterContext) {\n    c.Request().Header.Set(g.header, g.lookup(c.Request()))\n}\n\nfunc (g *geoip) Response(c filters.FilterContext) {}\n\nfunc (g *geoip) Match(r *http.Request) bool {\n    span := ot.SpanFromContext(r.Context())\n    if span != nil {\n        span.LogKV(\nGeoIP\n, \nstart\n)\n    }\n\n    code := g.lookup(r)\n    _, ok := g.countries[code]\n\n    if span != nil {\n        span.LogKV(\nGeoIP\n, code)\n    }\n    return ok\n}\n\n\n\n\nOpenTracing plugins\n\n\nThe tracers, except for \nnoop\n, are built as Go Plugins. A tracing plugin can\nbe loaded with \n-opentracing NAME\n as parameter to skipper.\n\n\nImplementations of OpenTracing API can be found in the\nhttps://github.com/skipper-plugins/opentracing repository.\n\n\nAll plugins must have a function named \nInitTracer\n with the following signature\n\n\nfunc([]string) (opentracing.Tracer, error)\n\n\n\nThe parameters passed are all arguments for the plugin, i.e. everything after the first\nword from skipper's -opentracing parameter. E.g. when the -opentracing parameter is\n\nmytracer foo=bar token=xxx somename=bla:3\n the \"mytracer\" plugin will receive\n\n\n[]string{\"foo=bar\", \"token=xxx\", \"somename=bla:3\"}\n\n\n\nas arguments.\n\n\nThe tracer plugin implementation is responsible to parse the received arguments.\n\n\nAn example plugin looks like\n\n\npackage main\n\nimport (\n     basic \ngithub.com/opentracing/basictracer-go\n\n     opentracing \ngithub.com/opentracing/opentracing-go\n\n)\n\nfunc InitTracer(opts []string) (opentracing.Tracer, error) {\n     return basic.NewTracerWithOptions(basic.Options{\n         Recorder:       basic.NewInMemoryRecorder(),\n         ShouldSample:   func(traceID uint64) bool { return traceID%64 == 0 },\n         MaxLogsPerSpan: 25,\n     }), nil\n}", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#skipper-plugins", 
            "text": "Skipper may be extended with functionality not present in the core.\nThese additions can be built as go plugin, so they do not have to\nbe present in the main skipper repository.  Note the warning from Go's plugin.go:  // The plugin support is currently incomplete, only supports Linux,\n// and has known bugs. Please report any issues.", 
            "title": "Skipper plugins"
        }, 
        {
            "location": "/plugins/#plugin-directories", 
            "text": "Plugins are loaded from sub directories of the plugin directories. By default\nthe plugin directory is set to  ./plugins  (i.e. relative to skipper's working\ndirectory). An additional directory may be given with the  -plugindir=/path/to/dir \noption to skipper.  Any file with the suffix  .so  found below the plugin directories (also in sub\ndirectories) is attempted to load without any arguments. When a plugin needs an\nargument, this must be explicitly loaded and the arguments passed, e.g. with -filter-plugin geoip,db=/path/to/db .", 
            "title": "Plugin directories"
        }, 
        {
            "location": "/plugins/#building-a-plugin", 
            "text": "Each plugin should be built with  go build -buildmode=plugin -o example.so example.go  There are some pitfalls:   packages which are shared between skipper and the plugin  must not  be in\n  a  vendor/  directory, otherwise the plugin will fail to load or in some\n  cases give wrong results (e.g. an opentracing span cannot be found in the\n  context even if it is present). This also means:\n  Do not vendor skipper in a plugin repo...  plugins must be rebuilt when skipper is rebuilt  do not attempt to rebuild a module and copy it over a loaded plugin, that\n  will crash skipper immediately...", 
            "title": "Building a plugin"
        }, 
        {
            "location": "/plugins/#filter-plugins", 
            "text": "All plugins must have a function named  InitFilter  with the following signature  func([]string) (filters.Spec, error)  The parameters passed are all arguments for the plugin, i.e. everything after the first\nword from skipper's  -filter-plugin  parameter. E.g. when the  -filter-plugin  \nparameter is  myfilter,datafile=/path/to/file,foo=bar  the  myfilter  plugin will receive  []string{\"datafile=/path/to/file\", \"foo=bar\"}  as arguments.  The filter plugin implementation is responsible to parse the received arguments.  Filter plugins can be found in the  filter repo", 
            "title": "Filter plugins"
        }, 
        {
            "location": "/plugins/#example-filter-plugin", 
            "text": "An example  noop  plugin looks like  package main\n\nimport (\n     github.com/zalando/skipper/filters \n)\n\ntype noopSpec struct{}\n\nfunc InitFilter(opts []string) (filters.Spec, error) {\n    return noopSpec{}, nil\n}\n\nfunc (s noopSpec) Name() string {\n    return  noop \n}\nfunc (s noopSpec) CreateFilter(config []interface{}) (filters.Filter, error) {\n    return noopFilter{}, nil\n}\n\ntype noopFilter struct{}\n\nfunc (f noopFilter) Request(filters.FilterContext)  {}\nfunc (f noopFilter) Response(filters.FilterContext) {}", 
            "title": "Example filter plugin"
        }, 
        {
            "location": "/plugins/#predicate-plugins", 
            "text": "All plugins must have a function named  InitPredicate  with the following signature  func([]string) (routing.PredicateSpec, error)  The parameters passed are all arguments for the plugin, i.e. everything after the first\nword from skipper's  -predicate-plugin  parameter. E.g. when the  -predicate-plugin  \nparameter is  mypred,datafile=/path/to/file,foo=bar  the  mypred  plugin will receive  []string{\"datafile=/path/to/file\", \"foo=bar\"}  as arguments.  The predicate plugin implementation is responsible to parse the received arguments.  Predicate plugins can be found in the  predicate repo", 
            "title": "Predicate plugins"
        }, 
        {
            "location": "/plugins/#example-predicate-plugin", 
            "text": "An example  MatchAll  plugin looks like  package main\n\nimport (\n     github.com/zalando/skipper/routing \n     net/http \n)\n\ntype noopSpec struct{}\n\nfunc InitPredicate(opts []string) (routing.PredicateSpec, error) {\n    return noopSpec{}, nil\n}\n\nfunc (s noopSpec) Name() string {\n    return  MatchAll \n}\nfunc (s noopSpec) Create(config []interface{}) (routing.Predicate, error) {\n    return noopPredicate{}, nil\n}\n\ntype noopPredicate struct{}\n\nfunc (p noopPredicate) Match(*http.Request) bool {\n    return true\n}", 
            "title": "Example predicate plugin"
        }, 
        {
            "location": "/plugins/#dataclient-plugins", 
            "text": "Similar to the above predicate and filter plugins. The command line option for data\nclient plugins is  -dataclient-plugin . The module must have a  InitDataClient \nfunction with the signature  func([]string) (routing.DataClient, error)  A  noop  data client looks like  package main\n\nimport (\n     github.com/zalando/skipper/eskip \n     github.com/zalando/skipper/routing \n)\n\nfunc InitDataClient([]string) (routing.DataClient, error) {\n    var dc DataClient =  \n    return dc, nil\n}\n\ntype DataClient string\n\nfunc (dc DataClient) LoadAll() ([]*eskip.Route, error) {\n    return eskip.Parse(string(dc))\n}\n\nfunc (dc DataClient) LoadUpdate() ([]*eskip.Route, []string, error) {\n    return nil, nil, nil\n}", 
            "title": "DataClient plugins"
        }, 
        {
            "location": "/plugins/#multitype-plugins", 
            "text": "Sometimes it is necessary to combine multiple plugin types into one module. This can\nbe done with this kind of plugin. Note that these modules are not auto loaded, these\nneed an explicit  -multi-plugin name,arg1,arg2  command line switch for skipper.  The module must have a  InitPlugin  function with the signature  func([]string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error)  Any of the returned types may be nil, so you can have e.g. a combined filter / data client\nplugin or share a filter and a predicate, e.g. like  package main\n\nimport (\n     fmt \n     net \n     net/http \n     strconv \n     strings \n\n    ot  github.com/opentracing/opentracing-go \n    maxminddb  github.com/oschwald/maxminddb-golang \n\n     github.com/zalando/skipper/filters \n    snet  github.com/zalando/skipper/net \n     github.com/zalando/skipper/predicates \n     github.com/zalando/skipper/routing \n)\n\ntype geoipSpec struct {\n    db   *maxminddb.Reader\n    name string\n}\n\nfunc InitPlugin(opts []string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error) {\n    var db string\n    for _, o := range opts {\n        switch {\n        case strings.HasPrefix(o,  db= ):\n            db = o[3:]\n        }\n    }\n    if db ==   {\n        return nil, nil, nil, fmt.Errorf( missing db= parameter for geoip plugin )\n    }\n    reader, err := maxminddb.Open(db)\n    if err != nil {\n        return nil, nil, nil, fmt.Errorf( failed to open db %s: %s , db, err)\n    }\n\n    return []filters.Spec{ geoipSpec{db: reader, name:  geoip }},\n        []routing.PredicateSpec{ geoipSpec{db: reader, name:  GeoIP }},\n        nil,\n        nil\n}\n\nfunc (s *geoipSpec) Name() string {\n    return s.name\n}\n\nfunc (s *geoipSpec) CreateFilter(config []interface{}) (filters.Filter, error) {\n    var fromLast bool\n    header :=  X-GeoIP-Country \n    var err error\n    for _, c := range config {\n        if s, ok := c.(string); ok {\n            switch {\n            case strings.HasPrefix(s,  from_last= ):\n                fromLast, err = strconv.ParseBool(s[10:])\n                if err != nil {\n                    return nil, filters.ErrInvalidFilterParameters\n                }\n            case strings.HasPrefix(s,  header= ):\n                header = s[7:]\n            }\n        }\n    }\n    return  geoip{db: s.db, fromLast: fromLast, header: header}, nil\n}\n\nfunc (s *geoipSpec) Create(config []interface{}) (routing.Predicate, error) {\n    var fromLast bool\n    var err error\n    countries := make(map[string]struct{})\n    for _, c := range config {\n        if s, ok := c.(string); ok {\n            switch {\n            case strings.HasPrefix(s,  from_last= ):\n                fromLast, err = strconv.ParseBool(s[10:])\n                if err != nil {\n                    return nil, predicates.ErrInvalidPredicateParameters\n                }\n            default:\n                countries[strings.ToUpper(s)] = struct{}{}\n            }\n        }\n    }\n    return  geoip{db: s.db, fromLast: fromLast, countries: countries}, nil\n}\n\ntype geoip struct {\n    db        *maxminddb.Reader\n    fromLast  bool\n    header    string\n    countries map[string]struct{}\n}\n\ntype countryRecord struct {\n    Country struct {\n        ISOCode string `maxminddb: iso_code `\n    } `maxminddb: country `\n}\n\nfunc (g *geoip) lookup(r *http.Request) string {\n    var src net.IP\n    if g.fromLast {\n        src = snet.RemoteHostFromLast(r)\n    } else {\n        src = snet.RemoteHost(r)\n    }\n\n    record := countryRecord{}\n    err := g.db.Lookup(src,  record)\n    if err != nil {\n        fmt.Printf( geoip(): failed to lookup %s: %s , src, err)\n    }\n    if record.Country.ISOCode ==   {\n        return  UNKNOWN \n    }\n    return record.Country.ISOCode\n}\n\nfunc (g *geoip) Request(c filters.FilterContext) {\n    c.Request().Header.Set(g.header, g.lookup(c.Request()))\n}\n\nfunc (g *geoip) Response(c filters.FilterContext) {}\n\nfunc (g *geoip) Match(r *http.Request) bool {\n    span := ot.SpanFromContext(r.Context())\n    if span != nil {\n        span.LogKV( GeoIP ,  start )\n    }\n\n    code := g.lookup(r)\n    _, ok := g.countries[code]\n\n    if span != nil {\n        span.LogKV( GeoIP , code)\n    }\n    return ok\n}", 
            "title": "MultiType plugins"
        }, 
        {
            "location": "/plugins/#opentracing-plugins", 
            "text": "The tracers, except for  noop , are built as Go Plugins. A tracing plugin can\nbe loaded with  -opentracing NAME  as parameter to skipper.  Implementations of OpenTracing API can be found in the\nhttps://github.com/skipper-plugins/opentracing repository.  All plugins must have a function named  InitTracer  with the following signature  func([]string) (opentracing.Tracer, error)  The parameters passed are all arguments for the plugin, i.e. everything after the first\nword from skipper's -opentracing parameter. E.g. when the -opentracing parameter is mytracer foo=bar token=xxx somename=bla:3  the \"mytracer\" plugin will receive  []string{\"foo=bar\", \"token=xxx\", \"somename=bla:3\"}  as arguments.  The tracer plugin implementation is responsible to parse the received arguments.  An example plugin looks like  package main\n\nimport (\n     basic  github.com/opentracing/basictracer-go \n     opentracing  github.com/opentracing/opentracing-go \n)\n\nfunc InitTracer(opts []string) (opentracing.Tracer, error) {\n     return basic.NewTracerWithOptions(basic.Options{\n         Recorder:       basic.NewInMemoryRecorder(),\n         ShouldSample:   func(traceID uint64) bool { return traceID%64 == 0 },\n         MaxLogsPerSpan: 25,\n     }), nil\n}", 
            "title": "OpenTracing plugins"
        }, 
        {
            "location": "/deployments/", 
            "text": "Deployments and Data-Clients\n\n\nEdge HTTP Routing\n\n\nEdge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.\n\n\nOn the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.\n\n\nIn this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.\n\n\nTo support this scenario we have the \netcd dataclient\n.\n\n\nEtcd\n is a distributed database.\n\n\nTODO: why we use ETCD for this purpose\n\n\nKubernetes Ingress\n\n\nKubernetes Ingress\n is the\ncomponent responsible to route traffic into your\n\nKubernetes\n cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the\n\nKubernetes dataclient\n and is used in\nproduction since end of 2016.\n\n\nSkipper as ingress controller does not need to have any file\nconfiguration or anything external which configures Skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof Skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.\n\n\nRead more about \nSkipper's Kubernetes dataclient\n.\n\n\nInkeeper Routes API\n\n\nSkipper\n can read from an\n\nInkeeper API\n, if you like to\ncreate routes via an API.\nOur \nInkeeper API dataclient\n can be used\nas well. It was used in production in the past. (TODO: do we use it somewhere?)\n\n\nDemos / Talks\n\n\nIn demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe \nroute-string dataclient\n.\n\n\nSimple Routes File\n\n\nThe most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the \nEskip file dataclient\n is about.", 
            "title": "Deployments"
        }, 
        {
            "location": "/deployments/#deployments-and-data-clients", 
            "text": "", 
            "title": "Deployments and Data-Clients"
        }, 
        {
            "location": "/deployments/#edge-http-routing", 
            "text": "Edge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.  On the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.  In this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.  To support this scenario we have the  etcd dataclient .  Etcd  is a distributed database.  TODO: why we use ETCD for this purpose", 
            "title": "Edge HTTP Routing"
        }, 
        {
            "location": "/deployments/#kubernetes-ingress", 
            "text": "Kubernetes Ingress  is the\ncomponent responsible to route traffic into your Kubernetes  cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the Kubernetes dataclient  and is used in\nproduction since end of 2016.  Skipper as ingress controller does not need to have any file\nconfiguration or anything external which configures Skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof Skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.  Read more about  Skipper's Kubernetes dataclient .", 
            "title": "Kubernetes Ingress"
        }, 
        {
            "location": "/deployments/#inkeeper-routes-api", 
            "text": "Skipper  can read from an Inkeeper API , if you like to\ncreate routes via an API.\nOur  Inkeeper API dataclient  can be used\nas well. It was used in production in the past. (TODO: do we use it somewhere?)", 
            "title": "Inkeeper Routes API"
        }, 
        {
            "location": "/deployments/#demos-talks", 
            "text": "In demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe  route-string dataclient .", 
            "title": "Demos / Talks"
        }, 
        {
            "location": "/deployments/#simple-routes-file", 
            "text": "The most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the  Eskip file dataclient  is about.", 
            "title": "Simple Routes File"
        }, 
        {
            "location": "/dataclients/eskip-file/", 
            "text": "Eskip File\n\n\nEskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The \nfile format eskip\n\nshows your route definitions in a clear way:\n\n\n% cat example.eskip\nhello: Path(\"/hello\") -\n \"https://www.example.org\"'\n\n\n\nThe \nSkipper project\n has two\nbinaries, one is \nskipper\n, the other is \neskip\n.\n\nEskip\n\ncan be used to validate the syntax of your routes file before\nreloading a production server:\n\n\n% eskip check example.eskip\n\n\n\nTo run Skipper serving routes from an \neskip\n file you have to use\n\n-routes-file \nfile\n parameter:\n\n\n% skipper -routes-file example.eskip\n\n\n\nA more complicated example with different routes, matches,\n\npredicates\n and\n\nfilters\n shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:\n\n\n% cat complicated_example.eskip\nhostHeaderMatch:\n         Host(\"^skipper.teapot.org$\")\n         -\n setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -\n \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaiduPathMatch:\n        Path(\"/baidu\")\n        -\n setRequestHeader(\"Host\", \"www.baidu.com\")\n        -\n setPath(\"/s\")\n        -\n setQuery(\"wd\", \"godoc skipper\")\n        -\n \"http://www.baidu.com\";\ngoogleWildcardMatch:\n        *\n        -\n setPath(\"/search\")\n        -\n setQuery(\"q\", \"godoc skipper\")\n        -\n \"https://www.google.com\";\nyandexWildacardIfCookie:\n        * \n Cookie(\"yandex\", \"true\")\n        -\n setPath(\"/search/\")\n        -\n setQuery(\"text\", \"godoc skipper\")\n        -\n tee(\"http://127.0.0.1:12345/\")\n        -\n \"https://yandex.ru\";\n\n\n\nThe former example shows 4 routes: hostHeaderMatch,\nbaiduPathMatch, googleWildcardMatch and yandexWildcardIfCookie.\n\n\n\n\nhostHeaderMatch:\n\n\nused if HTTP host header is exactly: \"skipper.teapot.org\",\n\n\nsets a Basic Authorization header and\n\n\nsends the modified request to https://target-to.auth-with.basic-auth.enterprise.com\n\n\n\n\n\n\nbaiduPathMatch:\n\n\nused in case the request patch matches /baidu\n\n\nit will set the Host header to the proxy request\n\n\nit will set the path from /baidu to /s\n\n\nit will set the querystring to \"ws=godoc skipper\" and\n\n\nsends the modified request to http://baidu.com\n\n\n\n\n\n\ngoogleWildcardMatch:\n\n\nused as default if no other route matches\n\n\nit will set the path to /search\n\n\nit will set the querystring to \"q=godoc skipper\" and\n\n\nsends the modified request to https://www.google.com\n\n\n\n\n\n\nyandexWildcardIfCookie:\n\n\nused as default if a Cookie named \"yandex\" has the value \"true\"\n\n\nit will set the path to /search/\n\n\nit will set the querystring to \"text=godoc skipper\"\n\n\nit will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix \ntee\n) and drop the response and\n\n\nsends the modified request to https://yandex.ru\n\n\n\n\n\n\n\n\nMore examples you find in \neskip file format\n\ndescription, in \nfilters\n\nand in \npredicates\n.\n\n\nEskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):\n\n\n% curl localhost:9911/routes\n*\n  -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -\n inlineContent(\"{\\\"foo\\\": 3}\")\n  -\n \nshunt", 
            "title": "Eskip"
        }, 
        {
            "location": "/dataclients/eskip-file/#eskip-file", 
            "text": "Eskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The  file format eskip \nshows your route definitions in a clear way:  % cat example.eskip\nhello: Path(\"/hello\") -  \"https://www.example.org\"'  The  Skipper project  has two\nbinaries, one is  skipper , the other is  eskip . Eskip \ncan be used to validate the syntax of your routes file before\nreloading a production server:  % eskip check example.eskip  To run Skipper serving routes from an  eskip  file you have to use -routes-file  file  parameter:  % skipper -routes-file example.eskip  A more complicated example with different routes, matches, predicates  and filters  shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:  % cat complicated_example.eskip\nhostHeaderMatch:\n         Host(\"^skipper.teapot.org$\")\n         -  setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -  \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaiduPathMatch:\n        Path(\"/baidu\")\n        -  setRequestHeader(\"Host\", \"www.baidu.com\")\n        -  setPath(\"/s\")\n        -  setQuery(\"wd\", \"godoc skipper\")\n        -  \"http://www.baidu.com\";\ngoogleWildcardMatch:\n        *\n        -  setPath(\"/search\")\n        -  setQuery(\"q\", \"godoc skipper\")\n        -  \"https://www.google.com\";\nyandexWildacardIfCookie:\n        *   Cookie(\"yandex\", \"true\")\n        -  setPath(\"/search/\")\n        -  setQuery(\"text\", \"godoc skipper\")\n        -  tee(\"http://127.0.0.1:12345/\")\n        -  \"https://yandex.ru\";  The former example shows 4 routes: hostHeaderMatch,\nbaiduPathMatch, googleWildcardMatch and yandexWildcardIfCookie.   hostHeaderMatch:  used if HTTP host header is exactly: \"skipper.teapot.org\",  sets a Basic Authorization header and  sends the modified request to https://target-to.auth-with.basic-auth.enterprise.com    baiduPathMatch:  used in case the request patch matches /baidu  it will set the Host header to the proxy request  it will set the path from /baidu to /s  it will set the querystring to \"ws=godoc skipper\" and  sends the modified request to http://baidu.com    googleWildcardMatch:  used as default if no other route matches  it will set the path to /search  it will set the querystring to \"q=godoc skipper\" and  sends the modified request to https://www.google.com    yandexWildcardIfCookie:  used as default if a Cookie named \"yandex\" has the value \"true\"  it will set the path to /search/  it will set the querystring to \"text=godoc skipper\"  it will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix  tee ) and drop the response and  sends the modified request to https://yandex.ru     More examples you find in  eskip file format \ndescription, in  filters \nand in  predicates .  Eskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):  % curl localhost:9911/routes\n*\n  -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -  inlineContent(\"{\\\"foo\\\": 3}\")\n  -   shunt", 
            "title": "Eskip File"
        }, 
        {
            "location": "/dataclients/etcd/", 
            "text": "ETCD\n\n\nTODO", 
            "title": "Etcd"
        }, 
        {
            "location": "/dataclients/etcd/#etcd", 
            "text": "TODO", 
            "title": "ETCD"
        }, 
        {
            "location": "/dataclients/inkeeper-api/", 
            "text": "Inkeeper API\n\n\nTODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/inkeeper-api/#inkeeper-api", 
            "text": "TODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/kubernetes/", 
            "text": "Kubernetes\n\n\nSkipper's Kubernetes dataclient can be used, if you want to run Skipper as\n\nkubernetes-ingress-controller\n.\nIt will get it's route information from provisioned\n\nIngress Objects\n.\nDetailed information you find in our \ngodoc for dataclient kubernetes\n.\n\n\nKubernetes Ingress Controller deployment\n\n\nHow to \ninstall Skipper ingress-controller\n for cluster operators.\n\n\nKubernetes Ingress Usage\n\n\nFind out more \nhow to use Skipper ingress features\n for deployers.\n\n\nWhy to choose Skipper?\n\n\nKubernetes is a fast changing environment and traditional http routers\nare not made for frequently changing routing tables. Skipper is a http\nproxy made to apply updates very often. Skipper is used in\nproduction with more than 200.000 routing table entries.\nSkipper has Filters to change http data and Predicates to change the\nmatching rules, both can combined and chained. You can set these in\ningress.yaml files to build resiliency patterns like ratelimit or\ncircuitbreaker. You can also use them to build more highlevel\ndeployment patterns, for example feature toggles, shadow traffic or\nblue-green deployments.\n\n\nSkipper's main features:\n\n\n\n\nFilters - create, update, delete all kind of HTTP data\n\n\ncollection of base http manipulations\n: for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling\n\n\ncookie handling\n\n\ncircuitbreakers\n: consecutiveBreaker or rateBreaker\n\n\nratelimit\n: based on client or backend data\n\n\nShadow traffic: \ntee()\n\n\nPredicates - advanced matching capability\n\n\nURL Path match: \nPath(\"/foo\")\n\n\nHost header match: \nHost(\"^www.example.org$\")\n\n\nQuerystring\n: \nQueryParam(\"featureX\")\n\n\nCookie based\n: \nCookie(\"alpha\", /^enabled$/)\n\n\nsource whitelist\n: \nSource(\"1.2.3.4/24\")\n\n\ntime based interval\n\n\ntraffic by percentage\n supports also sticky sessions\n\n\nKubernetes integration\n\n\nAll Filters and Predicates can be used with 2 annotations\n\n\nPredicates: \nzalando.org/skipper-predicate\n\n\nFilters: \nzalando.org/skipper-filter\n\n\n\n\n\n\nCustom routes can be defined with the annotation \nzalando.org/skipper-routes\n\n\nmetrics\n\n\naccess logs\n\n\nBlue-Green deployments, with another Ingress annotation \nzalando.org/backend-weights", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes", 
            "text": "Skipper's Kubernetes dataclient can be used, if you want to run Skipper as kubernetes-ingress-controller .\nIt will get it's route information from provisioned Ingress Objects .\nDetailed information you find in our  godoc for dataclient kubernetes .", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes-ingress-controller-deployment", 
            "text": "How to  install Skipper ingress-controller  for cluster operators.", 
            "title": "Kubernetes Ingress Controller deployment"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes-ingress-usage", 
            "text": "Find out more  how to use Skipper ingress features  for deployers.", 
            "title": "Kubernetes Ingress Usage"
        }, 
        {
            "location": "/dataclients/kubernetes/#why-to-choose-skipper", 
            "text": "Kubernetes is a fast changing environment and traditional http routers\nare not made for frequently changing routing tables. Skipper is a http\nproxy made to apply updates very often. Skipper is used in\nproduction with more than 200.000 routing table entries.\nSkipper has Filters to change http data and Predicates to change the\nmatching rules, both can combined and chained. You can set these in\ningress.yaml files to build resiliency patterns like ratelimit or\ncircuitbreaker. You can also use them to build more highlevel\ndeployment patterns, for example feature toggles, shadow traffic or\nblue-green deployments.  Skipper's main features:   Filters - create, update, delete all kind of HTTP data  collection of base http manipulations : for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling  cookie handling  circuitbreakers : consecutiveBreaker or rateBreaker  ratelimit : based on client or backend data  Shadow traffic:  tee()  Predicates - advanced matching capability  URL Path match:  Path(\"/foo\")  Host header match:  Host(\"^www.example.org$\")  Querystring :  QueryParam(\"featureX\")  Cookie based :  Cookie(\"alpha\", /^enabled$/)  source whitelist :  Source(\"1.2.3.4/24\")  time based interval  traffic by percentage  supports also sticky sessions  Kubernetes integration  All Filters and Predicates can be used with 2 annotations  Predicates:  zalando.org/skipper-predicate  Filters:  zalando.org/skipper-filter    Custom routes can be defined with the annotation  zalando.org/skipper-routes  metrics  access logs  Blue-Green deployments, with another Ingress annotation  zalando.org/backend-weights", 
            "title": "Why to choose Skipper?"
        }, 
        {
            "location": "/dataclients/route-string/", 
            "text": "Route String\n\n\nRoute string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.\n\n\nServe text\n\n\nServe with \nContent-Type: text/plain; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nServe HTML with CSS\n\n\nServe with \nContent-Type: text/html; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nServe JSON\n\n\nServe with \nContent-Type: application/json; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n% skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'\n\n\n\nProxy to a given URL\n\n\nIf you just have to build a workaround and you do not want to use\nsocat to do a tcp proxy, but proxy http, you can do:\n\n\n% skipper -inline-routes '* -\n \"https://my-new-backend.example.org/\"'", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#route-string", 
            "text": "Route string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#serve-text", 
            "text": "Serve with  Content-Type: text/plain; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '", 
            "title": "Serve text"
        }, 
        {
            "location": "/dataclients/route-string/#serve-html-with-css", 
            "text": "Serve with  Content-Type: text/html; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '", 
            "title": "Serve HTML with CSS"
        }, 
        {
            "location": "/dataclients/route-string/#serve-json", 
            "text": "Serve with  Content-Type: application/json; charset=utf-8  Example (Open your browser http://localhost:9090/):  % skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '", 
            "title": "Serve JSON"
        }, 
        {
            "location": "/dataclients/route-string/#proxy-to-a-given-url", 
            "text": "If you just have to build a workaround and you do not want to use\nsocat to do a tcp proxy, but proxy http, you can do:  % skipper -inline-routes '* -  \"https://my-new-backend.example.org/\"'", 
            "title": "Proxy to a given URL"
        }, 
        {
            "location": "/kubernetes/ingress-controller/", 
            "text": "Skipper Ingress Controller\n\n\nThis documentation is meant for for cluster operators and describes\nhow to install Skipper as Ingress-Controller into your Kubernetes\nCluster.\n\n\nWhy you should use skipper as ingress controller?\n\n\nBaremetal loadbalancer perform really well, but the configuration is\nnot updated frequently and most of these installations are not meant\nto rapidly change. With introducing Kubernetes this will change and\nthere is a need of rapid changing http routers. Skipper is designed\nfor rapidly changing it's routing tree.\n\n\nCloud loadbalancers are fine to scale and to change, but does not\nprovide many features. Skipper has advanced resiliency and deployment\nfeatures, that you can use to enhance your environment. For example\nratelimits, circuitbreakers, blue-green deployments, shadow traffic\nand \nmore\n.\n\n\nWhat is an Ingress-Controller?\n\n\nIngress-controllers are serving http requests into a Kubernetes\ncluster. Most of the time traffic will pass ingress got to a\nKubernetes service IP which will forward the packets to Kubernetes Pods\nselected by the Kubernetes service.\nFor having a successful ingress, you need to have a DNS name pointing\nto some stable IP addresses that act as a loadbalancer.\n\n\nSkipper as ingress-controller:\n\n\n\n\ncloud: deploy behind the cloud loadbalancer\n\n\nbaremetal: deploy behind your hardware/software loadbalancer and have all skipper as members in one pool.\n\n\n\n\nYou would point your DNS entries to the\nloadbalancer in front of skipper, for example automated using\n\nexternal-dns\n.\n\n\nWhy skipper uses endpoints and not services?\n\n\nSkipper does not use \nKubernetes\nServices\n to route\ntraffic to the pods. Instead it uses the Endpoints API to bypass\nkube-proxy created iptables to remove overhead like conntrack entries\nfor iptables DNAT. Skipper can also reuse connections to Pods, such\nthat you have no overhead in establishing connections all the time. To\nprevent errors on node failures, Skipper also does automatically\nretries to another endpoint in case it gets a connection refused or\nTLS handshake error to the endpoint.  Other reasons are future support\nof features like session affinity, different loadbalancer\nalgorithms or distributed loadbalancing also known as service mesh.\n\n\nAWS deployment\n\n\nIn AWS, this could be an ALB with DNS pointing to the ALB. The ALB can\nthen point to an ingress-controller running on an EC2 node and uses\nKubernetes \nhostnetwork\n port specification in the Pod spec.\n\n\nA logical overview of the traffic flow in AWS is shown in this picture:\n\n\n\n\nWe described that Skipper bypasses Kubernetes Service and use directly\nendpoints for \ngood reasons\n,\ntherefore the real traffic flow is shown in the next picture.\n\n\n\nBaremetal deployment\n\n\nIn datacenter, baremetal environments, you probably have a hardware\nloadbalancer or some haproxy or nginx setup, that serves most of your\nproduction traffic and DNS points to these endpoints. For example\n\n*.ingress.example.com\n could point to your virtual server IPs in front\nof ingress. Skippers could be used as pool members, which do the http\nrouting. Your loadbalancer of choice could have a wildcard certificate\nfor \n*.ingress.example.com\n and DNS for this would point to your\nloadbalancer. You can also automate DNS records with\n\nexternal-dns\n,\nif you for example use PowerDNS as provider and have a loadbalancer\ncontroller that modifies the status field in ingress to your\nloadbalancer virtual IP.\n\n\n\n\nRequirements\n\n\nIn general for one endpoint you need, a DNS A/AAAA record pointing to\none or more loadbalancer IPs. Skipper is best used behind this\nlayer 4 loadbalancer to route and manipulate HTTP data.\n\n\nminimal example:\n\n\n\n\nlayer 4 loadbalancer has \n1.2.3.4:80\n as socket for a virtual server pointing to all skipper ingress\n\n\n*.ingress.example.com\n points to 1.2.3.4\n\n\ningress object with host entry for \nmyapp.ingress.example.com\n targets a service type ClusterIP\n\n\nservice type ClusterIP has a selector that targets your Pods of your myapp deployment\n\n\n\n\nTLS example:\n\n\n\n\nsame as before, but you would terminate TLS on your layer 4 loadbalancer\n\n\nlayer 4 loadbalancer has \n1.2.3.4:443\n as socket for a virtual server\n\n\nyou can use an automated redirect for all port 80 requests to https with \n-kubernetes-https-redirect\n\n\n\n\nInstall Skipper as ingress-controller\n\n\nYou should have a base understanding of \nKubernetes\n and\n\nIngress\n.\n\n\nPrerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.\n\n\nWe start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.\n\n\n% cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.10.5\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.10.5\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n          - \"-lb-healthcheck-interval=3s\"\n          - \"-metrics-flavour=codahale,prometheus\"\n          - \"-enable-connection-metrics\"\n        resources:\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5\n\n\n\nPlease check, that you are using the \nlatest\nrelease\n, we do\nnot maintain the \nlatest\n tag.\n\n\nWe now deploy a simple demo application serving html:\n\n\n% cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -\n inlineContent(\\\"\nbody style='color: white; background-color: green;'\nh1\nHello!\n/h1\n\\\") -\n \nshunt\n\"\n        ports:\n        - containerPort: 9090\n\n\n\nWe deploy a service type ClusterIP that we will select from ingress:\n\n\n% cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: skipper-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: skipper-demo\n\n\n\nTo deploy both, you have to run:\n\n\n% kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml\n\n\n\nNow we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:\n\n\n% cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo.\nmydomain.org\n\n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80\n\n\n\nTo deploy this ingress, you have to run:\n\n\n% kubectl create -f demo-ing.yaml\n\n\n\nSkipper will configure itself for the given ingress, such that you can test doing:\n\n\n% curl -v -H\"Host: skipper-demo.\nmydomain.org\n\" http://\nnodeip\n:9999/\n\n\n\nThe next question you may ask is: how to expose this to your customers?\n\n\nThe answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS \n*.\nmydomain.org\n\nto your frontend loadbalancer IP that directs all traffic from \n*.\nmydomain.org\n\nto all Kubernetes worker nodes on TCP port 9999.\n\n\nA more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example\n\nkube-aws-ingress-controller\n,\nand your DNS, \nexternal-dns\n\nautomatically.\n\n\nMultiple skipper deployments\n\n\nIf you want to split for example \ninternal\n and \npublic\n traffic, it\nmight be a good choice to split your ingress deployments. Skipper has\nthe flag \n--kubernetes-ingress-class=\nstring\n to only select ingress\nobjects that have the annotation \nkubernetes.io/ingress.class\n set to\n\nstring\n. Skipper will only create routes for ingress objects with\nit's annotation or ingress objects that do not have this annotation.\n\n\nThe default ingress class is \nskipper\n, if not set. You have to create\nyour ingress objects with the annotation\n\nkubernetes.io/ingress.class: skipper\n to make sure only skipper will\nserve the traffic.\n\n\nExample ingress:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: skipper\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nInstall Skipper with enabled RBAC\n\n\nIf Role-Based Access Control (\"RBAC\") is enabled you have to create some additional\nresources to enable Skipper to query the Kubernetes API.\n\n\nThis guide describes all necessary resources to get Skipper up and running in a\nKubernetes cluster with RBAC enabled but it's highly recommended to read the\n\nRBAC docs\n to get a better\nunderstanding which permissions are delegated to Skipper within your Kubernetes cluster.\n\n\nFirst create a new \nServiceAccount\n which will be assigned to the Skipper pods:\n\n\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n\n\n\nthe required permissions are defined within a \nClusterRole\n resource.\n\n\nNote: It's important to use a \nClusterRole\n instead of normal \nRole\n because otherwise Skipper could only access resources in the namespace the \nRole\n was created!\n\n\nClusterRole:\n\n\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRole\nmetadata:\n  name: skipper-ingress\nrules:\n- apiGroups: [\"extensions\"]\n  resources: [\"ingresses\", ]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"namespaces\", \"services\", \"endpoints\"]\n  verbs: [\"get\"]\n\n\n\nThis \nClusterRole\n defines access to \nget\n and \nlist\n all created ingresses, namespaces, services and endpoints.\n\n\nTo assign the defined \nClusterRole\n to the previously created \nServiceAccount\n\na \nClusterRoleBinding\n has to be created:\n\n\nClusterRoleBinding:\n\n\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRoleBinding\nmetadata:\n  name: skipper-ingress\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: skipper-ingress\nsubjects:\n- kind: ServiceAccount\n  name: skipper-ingress\n  namespace: kube-system\n\n\n\nLast but not least the \nServiceAccount\n has to be assigned to the Skipper daemonset.\n\n\ndaemonset:\n\n\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      component: ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        component: ingress\n        application: skipper\n    spec:\n      hostNetwork: true\n      serviceAccountName: skipper-ingress\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        - name: metrics-port\n          containerPort: 9911\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n          - \"-lb-healthcheck-interval=3s\"\n          - \"-metrics-flavour=codahale,prometheus\"\n          - \"-enable-connection-metrics\"\n        resources:\n          requests:\n            cpu: 200m\n            memory: 200Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5\n\n\n\nPlease check, that you are using the \nlatest\nrelease\n, we do\nnot maintain the \nlatest\n tag.\n\n\nHelm-based deployment\n\n\nHelm\n calls itself the package manager for Kubernetes and therefore take cares of the deployment of whole applications including resources like services, configurations and so on.\n\n\nSkipper is also available as community contributed Helm chart in the public \nquay.io\n registry.\nThe latest packaged release can be found \nhere\n.\nThe source code is available at \nGitHub\n.\n\n\nThe chart includes resource definitions for the following use cases:\n\n\n\n\nRBAC\n\n\nCoreOS \nPrometheus-Operator\n\n\n\n\nAs this chart is not maintained by the Skipper developers and is still under development only the basic deployment workflow is covered here.\nCheck the GitHub repository for all details.\n\n\nTo be able to deploy the chart you will need the following components:\n\n\n\n\nhelm\n CLI (Install guide \nhere\n)\n\n\nHelm registry plugin (available \nhere\n)\n\n\n\n\nIf your environment is setup correctly you should be able to run \nhelm version --client\n and \nhelm registry version quay.io\n and get some information about your tooling without any error.\n\n\nIt is possible to deploy the chart without any further configuration like this:\n\n\nhelm registry upgrade quay.io/baez/skipper -- \\\n    --install \\\n    --wait \\\n    \"\nyour release name e.g. skipper\n\"\n\n\n\nThe \n--wait\n switch can be omitted as it only takes care that Helm is waiting until the chart is completely deployed (meaning all resources are created).\n\n\nTo update the deployment to a newer version the same command can be used.\n\n\nIf you have RBAC enabled in your Kubernetes instance you don't have to create all the previously described resources on your own but you can let Helm create them by simply adding one more switch:\n\n\nhelm registry upgrade quay.io/baez/skipper -- \\\n    --install \\\n    --wait \\\n    --set rbac.create=true \\\n    \"\nyour release name e.g. skipper\n\"\n\n\n\nThere are some more options available for customization of the chart.\nCheck the repository if you need more configuration possibilities.", 
            "title": "Ingress Controller Deployment"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#skipper-ingress-controller", 
            "text": "This documentation is meant for for cluster operators and describes\nhow to install Skipper as Ingress-Controller into your Kubernetes\nCluster.", 
            "title": "Skipper Ingress Controller"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#why-you-should-use-skipper-as-ingress-controller", 
            "text": "Baremetal loadbalancer perform really well, but the configuration is\nnot updated frequently and most of these installations are not meant\nto rapidly change. With introducing Kubernetes this will change and\nthere is a need of rapid changing http routers. Skipper is designed\nfor rapidly changing it's routing tree.  Cloud loadbalancers are fine to scale and to change, but does not\nprovide many features. Skipper has advanced resiliency and deployment\nfeatures, that you can use to enhance your environment. For example\nratelimits, circuitbreakers, blue-green deployments, shadow traffic\nand  more .", 
            "title": "Why you should use skipper as ingress controller?"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#what-is-an-ingress-controller", 
            "text": "Ingress-controllers are serving http requests into a Kubernetes\ncluster. Most of the time traffic will pass ingress got to a\nKubernetes service IP which will forward the packets to Kubernetes Pods\nselected by the Kubernetes service.\nFor having a successful ingress, you need to have a DNS name pointing\nto some stable IP addresses that act as a loadbalancer.  Skipper as ingress-controller:   cloud: deploy behind the cloud loadbalancer  baremetal: deploy behind your hardware/software loadbalancer and have all skipper as members in one pool.   You would point your DNS entries to the\nloadbalancer in front of skipper, for example automated using external-dns .", 
            "title": "What is an Ingress-Controller?"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#why-skipper-uses-endpoints-and-not-services", 
            "text": "Skipper does not use  Kubernetes\nServices  to route\ntraffic to the pods. Instead it uses the Endpoints API to bypass\nkube-proxy created iptables to remove overhead like conntrack entries\nfor iptables DNAT. Skipper can also reuse connections to Pods, such\nthat you have no overhead in establishing connections all the time. To\nprevent errors on node failures, Skipper also does automatically\nretries to another endpoint in case it gets a connection refused or\nTLS handshake error to the endpoint.  Other reasons are future support\nof features like session affinity, different loadbalancer\nalgorithms or distributed loadbalancing also known as service mesh.", 
            "title": "Why skipper uses endpoints and not services?"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#aws-deployment", 
            "text": "In AWS, this could be an ALB with DNS pointing to the ALB. The ALB can\nthen point to an ingress-controller running on an EC2 node and uses\nKubernetes  hostnetwork  port specification in the Pod spec.  A logical overview of the traffic flow in AWS is shown in this picture:   We described that Skipper bypasses Kubernetes Service and use directly\nendpoints for  good reasons ,\ntherefore the real traffic flow is shown in the next picture.", 
            "title": "AWS deployment"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#baremetal-deployment", 
            "text": "In datacenter, baremetal environments, you probably have a hardware\nloadbalancer or some haproxy or nginx setup, that serves most of your\nproduction traffic and DNS points to these endpoints. For example *.ingress.example.com  could point to your virtual server IPs in front\nof ingress. Skippers could be used as pool members, which do the http\nrouting. Your loadbalancer of choice could have a wildcard certificate\nfor  *.ingress.example.com  and DNS for this would point to your\nloadbalancer. You can also automate DNS records with external-dns ,\nif you for example use PowerDNS as provider and have a loadbalancer\ncontroller that modifies the status field in ingress to your\nloadbalancer virtual IP.", 
            "title": "Baremetal deployment"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#requirements", 
            "text": "In general for one endpoint you need, a DNS A/AAAA record pointing to\none or more loadbalancer IPs. Skipper is best used behind this\nlayer 4 loadbalancer to route and manipulate HTTP data.  minimal example:   layer 4 loadbalancer has  1.2.3.4:80  as socket for a virtual server pointing to all skipper ingress  *.ingress.example.com  points to 1.2.3.4  ingress object with host entry for  myapp.ingress.example.com  targets a service type ClusterIP  service type ClusterIP has a selector that targets your Pods of your myapp deployment   TLS example:   same as before, but you would terminate TLS on your layer 4 loadbalancer  layer 4 loadbalancer has  1.2.3.4:443  as socket for a virtual server  you can use an automated redirect for all port 80 requests to https with  -kubernetes-https-redirect", 
            "title": "Requirements"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#install-skipper-as-ingress-controller", 
            "text": "You should have a base understanding of  Kubernetes  and Ingress .  Prerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.  We start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.  % cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.10.5\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.10.5\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n          - \"-lb-healthcheck-interval=3s\"\n          - \"-metrics-flavour=codahale,prometheus\"\n          - \"-enable-connection-metrics\"\n        resources:\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5  Please check, that you are using the  latest\nrelease , we do\nnot maintain the  latest  tag.  We now deploy a simple demo application serving html:  % cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -  inlineContent(\\\" body style='color: white; background-color: green;' h1 Hello! /h1 \\\") -   shunt \"\n        ports:\n        - containerPort: 9090  We deploy a service type ClusterIP that we will select from ingress:  % cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: skipper-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: skipper-demo  To deploy both, you have to run:  % kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml  Now we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:  % cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo. mydomain.org \n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80  To deploy this ingress, you have to run:  % kubectl create -f demo-ing.yaml  Skipper will configure itself for the given ingress, such that you can test doing:  % curl -v -H\"Host: skipper-demo. mydomain.org \" http:// nodeip :9999/  The next question you may ask is: how to expose this to your customers?  The answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS  *. mydomain.org \nto your frontend loadbalancer IP that directs all traffic from  *. mydomain.org \nto all Kubernetes worker nodes on TCP port 9999.  A more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example kube-aws-ingress-controller ,\nand your DNS,  external-dns \nautomatically.", 
            "title": "Install Skipper as ingress-controller"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#multiple-skipper-deployments", 
            "text": "If you want to split for example  internal  and  public  traffic, it\nmight be a good choice to split your ingress deployments. Skipper has\nthe flag  --kubernetes-ingress-class= string  to only select ingress\nobjects that have the annotation  kubernetes.io/ingress.class  set to string . Skipper will only create routes for ingress objects with\nit's annotation or ingress objects that do not have this annotation.  The default ingress class is  skipper , if not set. You have to create\nyour ingress objects with the annotation kubernetes.io/ingress.class: skipper  to make sure only skipper will\nserve the traffic.  Example ingress:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: skipper\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Multiple skipper deployments"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#install-skipper-with-enabled-rbac", 
            "text": "If Role-Based Access Control (\"RBAC\") is enabled you have to create some additional\nresources to enable Skipper to query the Kubernetes API.  This guide describes all necessary resources to get Skipper up and running in a\nKubernetes cluster with RBAC enabled but it's highly recommended to read the RBAC docs  to get a better\nunderstanding which permissions are delegated to Skipper within your Kubernetes cluster.  First create a new  ServiceAccount  which will be assigned to the Skipper pods:  apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system  the required permissions are defined within a  ClusterRole  resource.  Note: It's important to use a  ClusterRole  instead of normal  Role  because otherwise Skipper could only access resources in the namespace the  Role  was created!  ClusterRole:  apiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRole\nmetadata:\n  name: skipper-ingress\nrules:\n- apiGroups: [\"extensions\"]\n  resources: [\"ingresses\", ]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"namespaces\", \"services\", \"endpoints\"]\n  verbs: [\"get\"]  This  ClusterRole  defines access to  get  and  list  all created ingresses, namespaces, services and endpoints.  To assign the defined  ClusterRole  to the previously created  ServiceAccount \na  ClusterRoleBinding  has to be created:  ClusterRoleBinding:  apiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRoleBinding\nmetadata:\n  name: skipper-ingress\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: skipper-ingress\nsubjects:\n- kind: ServiceAccount\n  name: skipper-ingress\n  namespace: kube-system  Last but not least the  ServiceAccount  has to be assigned to the Skipper daemonset.  daemonset:  apiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      component: ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        component: ingress\n        application: skipper\n    spec:\n      hostNetwork: true\n      serviceAccountName: skipper-ingress\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.10.5\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        - name: metrics-port\n          containerPort: 9911\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n          - \"-lb-healthcheck-interval=3s\"\n          - \"-metrics-flavour=codahale,prometheus\"\n          - \"-enable-connection-metrics\"\n        resources:\n          requests:\n            cpu: 200m\n            memory: 200Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5  Please check, that you are using the  latest\nrelease , we do\nnot maintain the  latest  tag.", 
            "title": "Install Skipper with enabled RBAC"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#helm-based-deployment", 
            "text": "Helm  calls itself the package manager for Kubernetes and therefore take cares of the deployment of whole applications including resources like services, configurations and so on.  Skipper is also available as community contributed Helm chart in the public  quay.io  registry.\nThe latest packaged release can be found  here .\nThe source code is available at  GitHub .  The chart includes resource definitions for the following use cases:   RBAC  CoreOS  Prometheus-Operator   As this chart is not maintained by the Skipper developers and is still under development only the basic deployment workflow is covered here.\nCheck the GitHub repository for all details.  To be able to deploy the chart you will need the following components:   helm  CLI (Install guide  here )  Helm registry plugin (available  here )   If your environment is setup correctly you should be able to run  helm version --client  and  helm registry version quay.io  and get some information about your tooling without any error.  It is possible to deploy the chart without any further configuration like this:  helm registry upgrade quay.io/baez/skipper -- \\\n    --install \\\n    --wait \\\n    \" your release name e.g. skipper \"  The  --wait  switch can be omitted as it only takes care that Helm is waiting until the chart is completely deployed (meaning all resources are created).  To update the deployment to a newer version the same command can be used.  If you have RBAC enabled in your Kubernetes instance you don't have to create all the previously described resources on your own but you can let Helm create them by simply adding one more switch:  helm registry upgrade quay.io/baez/skipper -- \\\n    --install \\\n    --wait \\\n    --set rbac.create=true \\\n    \" your release name e.g. skipper \"  There are some more options available for customization of the chart.\nCheck the repository if you need more configuration possibilities.", 
            "title": "Helm-based deployment"
        }, 
        {
            "location": "/kubernetes/ingress-usage/", 
            "text": "Skipper Ingress Usage\n\n\nThis documentation is meant for people deploying to Kubernetes\nClusters and describes to use Ingress and low level and high level\nfeatures Skipper provides\n\n\nSkipper Ingress Annotations\n\n\n\n\n\n\n\n\nAnnotation\n\n\nexample data\n\n\nusage\n\n\n\n\n\n\n\n\n\n\nzalando.org/backend-weights\n\n\n{\"my-app-1\": 80, \"my-app-2\": 20}\n\n\nblue-green deployments\n\n\n\n\n\n\nzalando.org/skipper-filter\n\n\nconsecutiveBreaker(15)\n\n\narbitrary filters\n\n\n\n\n\n\nzalando.org/skipper-predicate\n\n\nQueryParam(\"version\", \"^alpha$\")\n\n\narbitrary predicates\n\n\n\n\n\n\nzalando.org/skipper-routes\n\n\nMethod(\"OPTIONS\") -\n status(200) -\n \nshunt\n\n\nextra custom routes\n\n\n\n\n\n\nzalando.org/ratelimit\n\n\nratelimit(50, \"1m\")\n\n\ndeprecated, use zalando.org/skipper-filter instead\n\n\n\n\n\n\n\n\nSupported Service types\n\n\nIngress backend definitions are services, which have different\n\nservice types\n.\n\n\n\n\n\n\n\n\nService type\n\n\nsupported\n\n\nworkaround\n\n\n\n\n\n\n\n\n\n\nClusterIP\n\n\nyes\n\n\n---\n\n\n\n\n\n\nNodePort\n\n\nyes\n\n\n---\n\n\n\n\n\n\nExternalName\n\n\nno, \nrelated issue\n\n\nuse deployment with routestring\n\n\n\n\n\n\nLoadBalancer\n\n\nno\n\n\nit should not, because Kubernetes cloud-controller-manager will maintain it\n\n\n\n\n\n\n\n\nBasics\n\n\nHTTP Host header routing\n\n\nHTTP host header is defined within the rules \nhost\n section and this\nroute will match by http \nHost: app-default.example.org\n and route to\nendpoints selected by the Kubernetes service \napp-svc\n on port \n80\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nTo have 2 routes with different \nHost\n headers serving the same\nbackends, you have to specify 2 entries in the rules section, as\nKubernetes defined the ingress spec. This is often used in cases of\nmigrations from one domain to another one or migrations to or from\nbare metal datacenters to cloud providers or inter cloud or intra\ncloud providers migrations. Examples are AWS account migration, AWS to\nGCP migration, GCP to bare metal migration or bare metal to Alibaba\nCloud migration.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n  - host: foo.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nIngress path handling\n\n\nIngress paths can be interpreted in four different modes:\n\n\n\n\nbased on the kubernetes ingress specification\n\n\nas plain regular expression\n\n\nas a path prefix\n\n\n\n\nThe default is the kubernetes ingress mode. It can be changed by a startup option\nto any of the other modes, and the individual ingress rules can also override the\ndefault behavior with the zalando.org/skipper-ingress-path-mode annotation.\n\n\nE.g.:\n\n\nzalando.org/skipper-ingress-path-mode: path-prefix\n\n\n\nKubernetes ingress specification base path\n\n\nBy default, the ingress path is interpreted as a regular expression with a\nmandatory leading \"/\", and is automatically prepended by a \"^\" control character,\nenforcing that the path has to be at the start of the incoming request path.\n\n\nPlain regular expression\n\n\nWhen the path mode is set to \"path-regexp\", the ingress path is interpreted similar\nto the default kubernetes ingress specification way, but is not prepended by the \"^\"\ncontrol character.\n\n\nPath prefix\n\n\nWhen the path mode is set to \"path-prefix\", the ingress path is not a regular\nexpression. As an example, \"/foo/bar\" will match \"/foo/bar\" or \"/foo/bar/baz\", but\nwon't match \"/foo/barooz\".\n\n\nWhen PathPrefix is used, the path matching becomes deterministic when\na request could match more than one ingress routes otherwise.\n\n\nIn PathPrefix mode, when a Path or PathSubtree predicate is set in an\nannotation, the predicate in the annotation takes precedence over the normal ingress\npath.\n\n\nFilters and Predicates\n\n\n\n\nFilters\n can manipulate http data, which is not possible in the ingress spec.\n\n\nPredicates\n change the route matching, beyond normal ingress definitions\n\n\n\n\nThis example shows how to add predicates and filters:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: predicate1 \n predicate2 \n .. \n predicateN\n    zalando.org/skipper-filter: filter1 -\n filter2 -\n .. -\n filterN\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nCustom Routes\n\n\nCustom routes is a way of extending the default routes configured for an\ningress resource.\n\n\nThis example shows how to add a custom route for handling \nOPTIONS\n requests.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-routes: |\n      Method(\nOPTIONS\n) -\n\n      setResponseHeader(\nAccess-Control-Allow-Origin\n, \n*\n) -\n\n      setResponseHeader(\nAccess-Control-Allow-Methods\n, \nGET, OPTIONS\n) -\n\n      setResponseHeader(\nAccess-Control-Allow-Headers\n, \nAuthorization\n) -\n\n      status(200) -\n \nshunt\n\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\n\nThis will generate a custom route for the ingress which looks like this:\n\n\nHost(/^app-default[.]example[.]org$/) \n Method(\nOPTIONS\n) -\n\n  setResponseHeader(\nAccess-Control-Allow-Origin\n, \n*\n) -\n\n  setResponseHeader(\nAccess-Control-Allow-Methods\n, \nGET, OPTIONS\n) -\n\n  setResponseHeader(\nAccess-Control-Allow-Headers\n, \nAuthorization\n) -\n\n  status(200) -\n \nshunt\n\n\n\n\n\nFilters - Basic HTTP manipulations\n\n\nHTTP manipulations are done by using skipper filters. Changes can be\ndone in the request path, meaning request to your backend or in the\nresponse path to the client, which made the request.\n\n\nThe following examples can be used within \nzalando.org/skipper-filter\n\nannotation.\n\n\nAdd a request Header\n\n\nAdd a HTTP header in the request path to your backend.\n\n\nsetRequestHeader(\"X-Foo\", \"bar\")\n\n\n\nAdd a response Header\n\n\nAdd a HTTP header in the response path of your clients.\n\n\nsetResponseHeader(\"X-Foo\", \"bar\")\n\n\n\nEnable gzip\n\n\nCompress responses with gzip.\n\n\ncompress() // compress all valid MIME types\ncompress(\"text/html\") // only compress HTML files\ncompress(9, \"text/html\") // control the level of compression, 1 = fastest, 9 = best compression, 0 = no compression\n\n\n\nSet the Path\n\n\nChange the path in the request path to your backend to \n/newPath/\n.\n\n\nsetPath(\"/newPath/\")\n\n\n\nModify Path\n\n\nModify the path in the request path from \n/api/foo\n to your backend to \n/foo\n.\n\n\nmodPath(\"^/api/\", \"/\")\n\n\n\nSet the Querystring\n\n\nSet the Querystring in the request path to your backend to \n?text=godoc%20skipper\n.\n\n\nsetQuery(\"text\", \"godoc skipper\")\n\n\n\nRedirect\n\n\nCreate a redirect with HTTP code 301 to https://foo.example.org/.\n\n\nredirectTo(301, \"https://foo.example.org/\")\n\n\n\nCookies\n\n\nSet a Cookie in the request path to your backend.\n\n\nrequestCookie(\"test-session\", \"abc\")\n\n\n\nSet a Cookie in the response path of your clients.\n\n\nresponseCookie(\"test-session\", \"abc\", 31536000)\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\n\n// response cookie without HttpOnly:\njsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")\n\n\n\nAuthorization\n\n\nOur \nfilter auth godoc\n\nshows how to use filters for authorization.\n\n\nBasic Auth\n\n\n% htpasswd -nbm myName myPassword\n\nbasicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")\n\n\n\nBearer Token (OAuth/JWT)\n\n\nTBD\n\n\nDiagnosis - Throttling Bandwidth - Latency\n\n\nFor diagnosis purpose there are filters that enable you to throttle\nthe bandwidth or add latency. For the full list of filters see our\n\ndiag filter godoc page\n.\n\n\nbandwidth(30) // incoming in kb/s\nbackendBandwidth(30) // outgoing in kb/s\nbackendLatency(120) // in ms\n\n\n\nFlow Id to trace request flows\n\n\nTo trace request flows skipper can generate a unique Flow Id for every\nHTTP request that it receives. You can then find the trace of the\nrequest in all your access logs.  Skipper sets the X-Flow-Id header to\na unique value. Read more about this in our\n\nflowid filter godoc\n.\n\n\n flowId(\"reuse\")\n\n\n\nFilters - return fast\n\n\nSometimes you just want to return a header, redirect or even static\nhtml content. You can return from skipper without doing a proxy call\nto a backend, if you end your filter chain with \nshunt\n.\n\n\nReturn static content\n\n\nThe following example sets a response header \nX: bar\n, a response body\n\nhtml\nbody\nhello\n/body\n/html\n and a\nHTTP status code 200:\n\n\nzalando.org/skipper-filter: |\n  setResponseHeader(\"X\", \"bar\") -\n inlineContent(\"\nhtml\nbody\nhello\n/body\n/html\n\") -\n status(200) -\n \nshunt\n\n\n\n\nKeep in mind you need a valid backend definition to backends which are\navailable, otherwise Skipper would not accept the entire route\ndefinition from the ingress object for safety reasons.\n\n\nFilters - reliability features\n\n\nFilters can modify http requests and responses. There are plenty of\nthings you can do with them.\n\n\nCircuitbreaker\n\n\nConsecutive Breaker\n\n\nThe \nconsecutiveBreaker\n\nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments\n\ndocumented\n:\n\n\nconsecutiveBreaker(15)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRate Breaker\n\n\nThe \nrateBreaker\n\nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments\n\ndocumented\n.\n\n\nrateBreaker(30, 300)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRatelimits\n\n\nThere are two kind of ratelimits:\n\n\n\n\nClient side ratelimits are used to slow down login enumeration\nattacks, that targets your login pages. This is a security protection\nfor DDOS or login attacks.\n\n\nService or backend side ratelimits are used to protect your\nservices due too much traffic. This can be used in an emergency\nsituation to make sure you calm down ingress traffic or in general if\nyou know how much calls per duration your backend is able to handle.\n\n\n\n\nRatelimits are enforced per route.\n\n\nMore details you will find in \nratelimit package\n\nand \nKubernetes dataclient\n documentation.\n\n\nClient Ratelimits\n\n\nThe example shows 20 calls per hour per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nIf you need to rate limit service to service communication and\nyou use Authorization headers to protect your backend from your\nclients, then you can pass a 3 parameter to group clients by \"Authorization\nHeader\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nService Ratelimits\n\n\nThe example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nShadow Traffic\n\n\nIf you want to test a new replacement of a production service with\nproduction load, you can copy incoming requests to your new endpoint\nand ignore the responses from your new backend. This can be done by\nthe \ntee() and teenf() filters\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: teenf(\"https://app-new.example.org\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nPredicates\n\n\nPredicates\n\nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.\n\n\nYou can use all kinds of \npredicates\n\nwith \nfilters\n together.\n\n\nFeature Toggle\n\n\nFeature toggles are often implemented as query string to select a new\nfeature. Normally you would have to implement this in your\napplication, but Skipper can help you with that and you can select\nroutes with an ingress definition.\n\n\nYou create 2 ingresses that matches the same route, here host header\nmatch to \napp-default.example.org\n and one ingress has a defined query\nparameter to select the route to the alpha version deployment. If the\nquery string in the URL has \nversion=alpha\n set, for example\n\nhttps://app-default.example.org/mypath?version=alpha\n, the service\n\nalpha-svc\n will get the traffic, if not \nprod-svc\n.\n\n\nalpha-svc:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80\n\n\n\nprod-svc:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: prod-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: prod-svc\n          servicePort: 80\n\n\n\nIP Whitelisting\n\n\nThis ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nA/B test\n\n\nImplementing A/B testing is heavy. Skipper can help you to do\nthat. You need to have a traffic split somewhere and have your\ncustomers sticky to either A or B flavor of your application. Most\nlikely people would implement using cookies. Skipper can set a\n\ncookie with responseCookie()\n\nin a response to the client and the\n\ncookie predicate\n\ncan be used to match the route based on the cookie. Like this you can\nhave sticky sessions to either A or B for your clients.  This example\nshows to have 10% traffic using A and the rest using B.\n\n\n10% choice of setting the Cookie \"flavor\" to \"A\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Traffic(.1)\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80\n\n\n\nRest is setting Cookie \"flavor\" to \"B\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80\n\n\n\nTo be sticky, you have to create 2 ingress with predicate to match\nroutes with the cookie we set before. For \"A\" this would be:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80\n\n\n\nFor \"B\" this would be:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80\n\n\n\nBlue-Green deployments\n\n\nTo do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification. \nzalando.org/backend-weights\n\nis a hash map, which key relates to the \nserviceName\n of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.\n\n\nIn the following example \nmy-app-1\n service will get \n80%\n of the traffic\nand \nmy-app-2\n will get \n20%\n of the traffic:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /\n\n\n\nChaining Filters and Predicates\n\n\nYou can set multiple filters in a chain similar to the \neskip format\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) \n Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -\n requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Ingress Usage"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#skipper-ingress-usage", 
            "text": "This documentation is meant for people deploying to Kubernetes\nClusters and describes to use Ingress and low level and high level\nfeatures Skipper provides", 
            "title": "Skipper Ingress Usage"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#skipper-ingress-annotations", 
            "text": "Annotation  example data  usage      zalando.org/backend-weights  {\"my-app-1\": 80, \"my-app-2\": 20}  blue-green deployments    zalando.org/skipper-filter  consecutiveBreaker(15)  arbitrary filters    zalando.org/skipper-predicate  QueryParam(\"version\", \"^alpha$\")  arbitrary predicates    zalando.org/skipper-routes  Method(\"OPTIONS\") -  status(200) -   shunt  extra custom routes    zalando.org/ratelimit  ratelimit(50, \"1m\")  deprecated, use zalando.org/skipper-filter instead", 
            "title": "Skipper Ingress Annotations"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#supported-service-types", 
            "text": "Ingress backend definitions are services, which have different service types .     Service type  supported  workaround      ClusterIP  yes  ---    NodePort  yes  ---    ExternalName  no,  related issue  use deployment with routestring    LoadBalancer  no  it should not, because Kubernetes cloud-controller-manager will maintain it", 
            "title": "Supported Service types"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#basics", 
            "text": "", 
            "title": "Basics"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#http-host-header-routing", 
            "text": "HTTP host header is defined within the rules  host  section and this\nroute will match by http  Host: app-default.example.org  and route to\nendpoints selected by the Kubernetes service  app-svc  on port  80 .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80  To have 2 routes with different  Host  headers serving the same\nbackends, you have to specify 2 entries in the rules section, as\nKubernetes defined the ingress spec. This is often used in cases of\nmigrations from one domain to another one or migrations to or from\nbare metal datacenters to cloud providers or inter cloud or intra\ncloud providers migrations. Examples are AWS account migration, AWS to\nGCP migration, GCP to bare metal migration or bare metal to Alibaba\nCloud migration.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n  - host: foo.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "HTTP Host header routing"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#ingress-path-handling", 
            "text": "Ingress paths can be interpreted in four different modes:   based on the kubernetes ingress specification  as plain regular expression  as a path prefix   The default is the kubernetes ingress mode. It can be changed by a startup option\nto any of the other modes, and the individual ingress rules can also override the\ndefault behavior with the zalando.org/skipper-ingress-path-mode annotation.  E.g.:  zalando.org/skipper-ingress-path-mode: path-prefix", 
            "title": "Ingress path handling"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#kubernetes-ingress-specification-base-path", 
            "text": "By default, the ingress path is interpreted as a regular expression with a\nmandatory leading \"/\", and is automatically prepended by a \"^\" control character,\nenforcing that the path has to be at the start of the incoming request path.", 
            "title": "Kubernetes ingress specification base path"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#plain-regular-expression", 
            "text": "When the path mode is set to \"path-regexp\", the ingress path is interpreted similar\nto the default kubernetes ingress specification way, but is not prepended by the \"^\"\ncontrol character.", 
            "title": "Plain regular expression"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#path-prefix", 
            "text": "When the path mode is set to \"path-prefix\", the ingress path is not a regular\nexpression. As an example, \"/foo/bar\" will match \"/foo/bar\" or \"/foo/bar/baz\", but\nwon't match \"/foo/barooz\".  When PathPrefix is used, the path matching becomes deterministic when\na request could match more than one ingress routes otherwise.  In PathPrefix mode, when a Path or PathSubtree predicate is set in an\nannotation, the predicate in the annotation takes precedence over the normal ingress\npath.", 
            "title": "Path prefix"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#filters-and-predicates", 
            "text": "Filters  can manipulate http data, which is not possible in the ingress spec.  Predicates  change the route matching, beyond normal ingress definitions   This example shows how to add predicates and filters:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: predicate1   predicate2   ..   predicateN\n    zalando.org/skipper-filter: filter1 -  filter2 -  .. -  filterN\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Filters and Predicates"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#custom-routes", 
            "text": "Custom routes is a way of extending the default routes configured for an\ningress resource.  This example shows how to add a custom route for handling  OPTIONS  requests.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-routes: |\n      Method( OPTIONS ) - \n      setResponseHeader( Access-Control-Allow-Origin ,  * ) - \n      setResponseHeader( Access-Control-Allow-Methods ,  GET, OPTIONS ) - \n      setResponseHeader( Access-Control-Allow-Headers ,  Authorization ) - \n      status(200) -   shunt \n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80  This will generate a custom route for the ingress which looks like this:  Host(/^app-default[.]example[.]org$/)   Method( OPTIONS ) - \n  setResponseHeader( Access-Control-Allow-Origin ,  * ) - \n  setResponseHeader( Access-Control-Allow-Methods ,  GET, OPTIONS ) - \n  setResponseHeader( Access-Control-Allow-Headers ,  Authorization ) - \n  status(200) -   shunt", 
            "title": "Custom Routes"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#filters-basic-http-manipulations", 
            "text": "HTTP manipulations are done by using skipper filters. Changes can be\ndone in the request path, meaning request to your backend or in the\nresponse path to the client, which made the request.  The following examples can be used within  zalando.org/skipper-filter \nannotation.", 
            "title": "Filters - Basic HTTP manipulations"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#add-a-request-header", 
            "text": "Add a HTTP header in the request path to your backend.  setRequestHeader(\"X-Foo\", \"bar\")", 
            "title": "Add a request Header"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#add-a-response-header", 
            "text": "Add a HTTP header in the response path of your clients.  setResponseHeader(\"X-Foo\", \"bar\")", 
            "title": "Add a response Header"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#enable-gzip", 
            "text": "Compress responses with gzip.  compress() // compress all valid MIME types\ncompress(\"text/html\") // only compress HTML files\ncompress(9, \"text/html\") // control the level of compression, 1 = fastest, 9 = best compression, 0 = no compression", 
            "title": "Enable gzip"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#set-the-path", 
            "text": "Change the path in the request path to your backend to  /newPath/ .  setPath(\"/newPath/\")", 
            "title": "Set the Path"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#modify-path", 
            "text": "Modify the path in the request path from  /api/foo  to your backend to  /foo .  modPath(\"^/api/\", \"/\")", 
            "title": "Modify Path"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#set-the-querystring", 
            "text": "Set the Querystring in the request path to your backend to  ?text=godoc%20skipper .  setQuery(\"text\", \"godoc skipper\")", 
            "title": "Set the Querystring"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#redirect", 
            "text": "Create a redirect with HTTP code 301 to https://foo.example.org/.  redirectTo(301, \"https://foo.example.org/\")", 
            "title": "Redirect"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#cookies", 
            "text": "Set a Cookie in the request path to your backend.  requestCookie(\"test-session\", \"abc\")  Set a Cookie in the response path of your clients.  responseCookie(\"test-session\", \"abc\", 31536000)\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\n\n// response cookie without HttpOnly:\njsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")", 
            "title": "Cookies"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#authorization", 
            "text": "Our  filter auth godoc \nshows how to use filters for authorization.", 
            "title": "Authorization"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#basic-auth", 
            "text": "% htpasswd -nbm myName myPassword\n\nbasicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")", 
            "title": "Basic Auth"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#bearer-token-oauthjwt", 
            "text": "TBD", 
            "title": "Bearer Token (OAuth/JWT)"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#diagnosis-throttling-bandwidth-latency", 
            "text": "For diagnosis purpose there are filters that enable you to throttle\nthe bandwidth or add latency. For the full list of filters see our diag filter godoc page .  bandwidth(30) // incoming in kb/s\nbackendBandwidth(30) // outgoing in kb/s\nbackendLatency(120) // in ms", 
            "title": "Diagnosis - Throttling Bandwidth - Latency"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#flow-id-to-trace-request-flows", 
            "text": "To trace request flows skipper can generate a unique Flow Id for every\nHTTP request that it receives. You can then find the trace of the\nrequest in all your access logs.  Skipper sets the X-Flow-Id header to\na unique value. Read more about this in our flowid filter godoc .   flowId(\"reuse\")", 
            "title": "Flow Id to trace request flows"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#filters-return-fast", 
            "text": "Sometimes you just want to return a header, redirect or even static\nhtml content. You can return from skipper without doing a proxy call\nto a backend, if you end your filter chain with  shunt .", 
            "title": "Filters - return fast"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#return-static-content", 
            "text": "The following example sets a response header  X: bar , a response body html body hello /body /html  and a\nHTTP status code 200:  zalando.org/skipper-filter: |\n  setResponseHeader(\"X\", \"bar\") -  inlineContent(\" html body hello /body /html \") -  status(200) -   shunt   Keep in mind you need a valid backend definition to backends which are\navailable, otherwise Skipper would not accept the entire route\ndefinition from the ingress object for safety reasons.", 
            "title": "Return static content"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#filters-reliability-features", 
            "text": "Filters can modify http requests and responses. There are plenty of\nthings you can do with them.", 
            "title": "Filters - reliability features"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#circuitbreaker", 
            "text": "", 
            "title": "Circuitbreaker"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#consecutive-breaker", 
            "text": "The  consecutiveBreaker \nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments documented :  consecutiveBreaker(15)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Consecutive Breaker"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#rate-breaker", 
            "text": "The  rateBreaker \nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments documented .  rateBreaker(30, 300)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Rate Breaker"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#ratelimits", 
            "text": "There are two kind of ratelimits:   Client side ratelimits are used to slow down login enumeration\nattacks, that targets your login pages. This is a security protection\nfor DDOS or login attacks.  Service or backend side ratelimits are used to protect your\nservices due too much traffic. This can be used in an emergency\nsituation to make sure you calm down ingress traffic or in general if\nyou know how much calls per duration your backend is able to handle.   Ratelimits are enforced per route.  More details you will find in  ratelimit package \nand  Kubernetes dataclient  documentation.", 
            "title": "Ratelimits"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#client-ratelimits", 
            "text": "The example shows 20 calls per hour per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80  If you need to rate limit service to service communication and\nyou use Authorization headers to protect your backend from your\nclients, then you can pass a 3 parameter to group clients by \"Authorization\nHeader\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Client Ratelimits"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#service-ratelimits", 
            "text": "The example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Service Ratelimits"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#shadow-traffic", 
            "text": "If you want to test a new replacement of a production service with\nproduction load, you can copy incoming requests to your new endpoint\nand ignore the responses from your new backend. This can be done by\nthe  tee() and teenf() filters .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: teenf(\"https://app-new.example.org\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Shadow Traffic"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#predicates", 
            "text": "Predicates \nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.  You can use all kinds of  predicates \nwith  filters  together.", 
            "title": "Predicates"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#feature-toggle", 
            "text": "Feature toggles are often implemented as query string to select a new\nfeature. Normally you would have to implement this in your\napplication, but Skipper can help you with that and you can select\nroutes with an ingress definition.  You create 2 ingresses that matches the same route, here host header\nmatch to  app-default.example.org  and one ingress has a defined query\nparameter to select the route to the alpha version deployment. If the\nquery string in the URL has  version=alpha  set, for example https://app-default.example.org/mypath?version=alpha , the service alpha-svc  will get the traffic, if not  prod-svc .  alpha-svc:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80  prod-svc:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: prod-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: prod-svc\n          servicePort: 80", 
            "title": "Feature Toggle"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#ip-whitelisting", 
            "text": "This ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "IP Whitelisting"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#ab-test", 
            "text": "Implementing A/B testing is heavy. Skipper can help you to do\nthat. You need to have a traffic split somewhere and have your\ncustomers sticky to either A or B flavor of your application. Most\nlikely people would implement using cookies. Skipper can set a cookie with responseCookie() \nin a response to the client and the cookie predicate \ncan be used to match the route based on the cookie. Like this you can\nhave sticky sessions to either A or B for your clients.  This example\nshows to have 10% traffic using A and the rest using B.  10% choice of setting the Cookie \"flavor\" to \"A\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Traffic(.1)\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80  Rest is setting Cookie \"flavor\" to \"B\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80  To be sticky, you have to create 2 ingress with predicate to match\nroutes with the cookie we set before. For \"A\" this would be:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80  For \"B\" this would be:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80", 
            "title": "A/B test"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#blue-green-deployments", 
            "text": "To do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification.  zalando.org/backend-weights \nis a hash map, which key relates to the  serviceName  of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.  In the following example  my-app-1  service will get  80%  of the traffic\nand  my-app-2  will get  20%  of the traffic:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /", 
            "title": "Blue-Green deployments"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#chaining-filters-and-predicates", 
            "text": "You can set multiple filters in a chain similar to the  eskip format .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)   Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -  requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Chaining Filters and Predicates"
        }, 
        {
            "location": "/kubernetes/ingress-backends/", 
            "text": "Kubernetes Backend Deployments\n\n\nKubernetes Race Condition problem\n\n\nAs described in \n#652\n,\nthere is a problem that exists in Kubernetes, while terminating Pods.\nTerminating Pods could be graceful, but the nature of distributed\nenvironments will show failures, because not all components in the\ndistributed system changed already their state. When a Pod terminates,\nthe controller-manager has to update the \nendpoints\n of the Kubernetes\n\nservice\n.  Additionally Skipper has to get this endpoints\nlist. Skipper polls the kube-apiserver every \n-source-poll-timeout=\nms\n,\nwhich defaults to 3000.\nReducing this interval or implementing watch will only reduce the\ntimeframe, but not fix the underlying race condition.\n\n\nMitigation strategies can be different and the next section document\nstrategies for application developers to mitigate the problem.\n\n\nTeardown strategies\n\n\nAn application that is target of an ingress can circumvent HTTP code\n504s Gateway Timeouts with these strategies:\n\n\n\n\nuse \nPod lifecycle hooks\n\n\nuse a SIGTERM handler to switch \nreadinessProbe\n to unhealthy and\nexit later, or just wait for SIGKILL terminating the process.\n\n\n\n\nPod Lifecycle Hooks\n\n\nKubernetes Pod Lifecycle\nHooks\n\nin the Pod spec can have a \npreStop\n command which executes for\nexample a binary. The following will execute the binary \nsleep\n with\nargument \n20\n to wait 20 seconds before terminating the containers\nwithin the Pod:\n\n\nlifecycle:\n  preStop:\n    exec:\n      command: [\nsleep\n,\n20\n]\n\n\n\n\n20 seconds should be enough to fade your Pod out of the endpoints list\nand Skipper's routing table.\n\n\nSIGTERM handling in Containers\n\n\nAn application can implement a SIGTERM handler, that changes the\n\nreadinessProbe\n target to unhealthy for the application\ninstance. This will make sure it will be deleted from the endpoints\nlist and from Skipper's routing table. Similar to \nPod Lifecycle\nHooks\n you could sleep 20 seconds and after that\nterminate your application or you just wait until SIGKILL will cleanup\nthe instance after 60s.\n\n\ngo func() {\n    var sigs chan os.Signal\n    sigs = make(chan os.Signal, 1)\n    signal.Notify(sigs, syscall.SIGTERM)\n    for {\n        select {\n            case \n-sigs:\n               healthCheck = unhealthy\n               time.Sleep(20*time.Second)\n               os.Exit(0)\n        }\n    }\n}()", 
            "title": "Ingress Backends"
        }, 
        {
            "location": "/kubernetes/ingress-backends/#kubernetes-backend-deployments", 
            "text": "", 
            "title": "Kubernetes Backend Deployments"
        }, 
        {
            "location": "/kubernetes/ingress-backends/#kubernetes-race-condition-problem", 
            "text": "As described in  #652 ,\nthere is a problem that exists in Kubernetes, while terminating Pods.\nTerminating Pods could be graceful, but the nature of distributed\nenvironments will show failures, because not all components in the\ndistributed system changed already their state. When a Pod terminates,\nthe controller-manager has to update the  endpoints  of the Kubernetes service .  Additionally Skipper has to get this endpoints\nlist. Skipper polls the kube-apiserver every  -source-poll-timeout= ms ,\nwhich defaults to 3000.\nReducing this interval or implementing watch will only reduce the\ntimeframe, but not fix the underlying race condition.  Mitigation strategies can be different and the next section document\nstrategies for application developers to mitigate the problem.", 
            "title": "Kubernetes Race Condition problem"
        }, 
        {
            "location": "/kubernetes/ingress-backends/#teardown-strategies", 
            "text": "An application that is target of an ingress can circumvent HTTP code\n504s Gateway Timeouts with these strategies:   use  Pod lifecycle hooks  use a SIGTERM handler to switch  readinessProbe  to unhealthy and\nexit later, or just wait for SIGKILL terminating the process.", 
            "title": "Teardown strategies"
        }, 
        {
            "location": "/kubernetes/ingress-backends/#pod-lifecycle-hooks", 
            "text": "Kubernetes Pod Lifecycle\nHooks \nin the Pod spec can have a  preStop  command which executes for\nexample a binary. The following will execute the binary  sleep  with\nargument  20  to wait 20 seconds before terminating the containers\nwithin the Pod:  lifecycle:\n  preStop:\n    exec:\n      command: [ sleep , 20 ]  20 seconds should be enough to fade your Pod out of the endpoints list\nand Skipper's routing table.", 
            "title": "Pod Lifecycle Hooks"
        }, 
        {
            "location": "/kubernetes/ingress-backends/#sigterm-handling-in-containers", 
            "text": "An application can implement a SIGTERM handler, that changes the readinessProbe  target to unhealthy for the application\ninstance. This will make sure it will be deleted from the endpoints\nlist and from Skipper's routing table. Similar to  Pod Lifecycle\nHooks  you could sleep 20 seconds and after that\nterminate your application or you just wait until SIGKILL will cleanup\nthe instance after 60s.  go func() {\n    var sigs chan os.Signal\n    sigs = make(chan os.Signal, 1)\n    signal.Notify(sigs, syscall.SIGTERM)\n    for {\n        select {\n            case  -sigs:\n               healthCheck = unhealthy\n               time.Sleep(20*time.Second)\n               os.Exit(0)\n        }\n    }\n}()", 
            "title": "SIGTERM handling in Containers"
        }, 
        {
            "location": "/operations/", 
            "text": "Operations\n\n\nThis is the work in progress operations guide for showing information,\nwhich are relevant for production use.\n\n\nSkipper is proven to scale with number of routes beyond 200.000 routes\nper instance. Skipper is running with peaks to 45.000 http requests\nper second using multiple instances.\n\n\nConnection Options\n\n\nSkipper's connection options are allowing you to set Go's \nhttp.Server\n\nOptions on the client side and \nhttp.Transport\n on the backend side.\n\n\n\"It is recommended to read\n\nthis blog post about net http timeouts\n\nin order to better understand the impact of these settings.\n\n\nBackend\n\n\nBackend is the side skipper opens a client connection to.\n\n\nClosing idle connections is required for DNS failover, because Go's\n\nhttp.Transport\n caches\nDNS lookups and needs to create new connections for doing so. Skipper\nwill start a goroutine and use the specified\n\ntime.Duration\n to call\nCloseIdleConnections() on that\n\nhttp.Transport\n.\n\n\n-close-idle-conns-period string\n    period of closing all idle connections in seconds or as a\n    duration string. Not closing when less than 0 (default \"20\")\n\n\n\nThis will set MaxIdleConnsPerHost on the\n\nhttp.Transport\n to limit\nthe number of idle connections per backend such that we do not run out\nof sockets.\n\n\n-idle-conns-num int\n    maximum idle connections per backend host (default 64)\n\n\n\nThis will set MaxIdleConns on the\n\nhttp.Transport\n to limit\nthe number for all backends such that we do not run out of sockets.\n\n\n-max-idle-connection-backend int\n    sets the maximum idle connections for all backend connections\n\n\n\nThis will set TLSHandshakeTimeout on the\n\nhttp.Transport\n to have\ntimeouts based on TLS connections.\n\n\n-tls-timeout-backend duration\n    sets the TLS handshake timeout for backend connections (default 1m0s)\n\n\n\nThis will set Timeout on\n\nnet.Dialer\n that is the\nimplementation of DialContext, which is the TCP connection pool used in the\n\nhttp.Transport\n.\n\n\n-timeout-backend duration\n    sets the TCP client connection timeout for backend connections (default 1m0s)\n\n\n\nThis will set KeepAlive on\n\nnet.Dialer\n that is the\nimplementation of DialContext, which is the TCP connection pool used in the\n\nhttp.Transport\n.\n\n\n-keepalive-backend duration\n    sets the keepalive for backend connections (default 30s)\n\n\n\nThis will set DualStack (IPv4 and IPv6) on\n\nnet.Dialer\n that is the\nimplementation of DialContext, which is the TCP connection pool used in the\n\nhttp.Transport\n.\n\n\n-enable-dualstack-backend\n    enables DualStack for backend connections (default true)\n\n\n\nClient\n\n\nClient is the side skipper gets incoming calls from.\nHere we can set timeouts in different parts of the http connection.\n\n\nThis will set ReadTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-read-timeout-server duration\n    set ReadTimeout for http server connections (default 5m0s)\n\n\n\nThis will set ReadHeaderTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-read-header-timeout-server duration\n    set ReadHeaderTimeout for http server connections (default 1m0s)\n\n\n\nThis will set WriteTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-write-timeout-server duration\n    set WriteTimeout for http server connections (default 1m0s)\n\n\n\nThis will set IdleTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-idle-timeout-server duration\n    maximum idle connections per backend host (default 1m0s)\n\n\n\nThis will set MaxHeaderBytes in\n\nhttp.Server\n to limit the\nsize of the http header from your clients.\n\n\n-max-header-bytes int\n    set MaxHeaderBytes for http server connections (default 1048576)\n\n\n\nMonitoring\n\n\nMonitoring is one of the most important things you need to run in\nproduction and skipper has a \ngodoc page\n\nfor the \nmetrics package\n,\ndescribing options and most keys you will find in the metrics handler\nendpoint. The default is listening on \n:9911/metrics\n. You can modify\nthe listen port with the \n-support-listener\n flag.\n\n\nPrometheus\n\n\nIn case you want to get metrics in \nPrometheus\n format exposed, use this\noption to enable it:\n\n\n-enable-prometheus-metrics\n\n\n\nIt will return \nPrometheus\n metrics on the\ncommon metrics endpoint :9911/metrics.\n\n\nConnection metrics\n\n\nThis option will enable known loadbalancer connections metrics, like\ncounters for active and new connections. This feature sets a metrics\ncallback on \nhttp.Server\n and\nuses a counter to collect\n\nhttp.ConnState\n.\n\n\n-enable-connection-metrics\n    enables connection metrics for http server connections\n\n\n\nIt will expose them in /metrics, for example json structure looks like this example:\n\n\n{\n  \"counters\": {\n    \"skipper.lb-conn-active\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-closed\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-idle\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-new\": {\n      \"count\": 6\n    }\n  },\n  /* stripped a lot of metrics here */\n}\n\n\n\nApplication metrics\n\n\nApplication metrics for your proxied applications you can enable with the option:\n\n\n-serve-host-metrics\n    enables reporting total serve time metrics for each host\n\n\n\nThis will make sure you will get stats for each \"Host\" header as \"timers\":\n\n\n\"timers\": {\n  \"skipper.servehost.app1_example_com.GET.200\": {\n    \"15m.rate\": 0.06830666203045982,\n    \"1m.rate\": 2.162612637718806e-06,\n    \"5m.rate\": 0.008312609284452856,\n    \"75%\": 236603815,\n    \"95%\": 236603815,\n    \"99%\": 236603815,\n    \"99.9%\": 236603815,\n    \"count\": 3,\n    \"max\": 236603815,\n    \"mean\": 116515451.66666667,\n    \"mean.rate\": 0.0030589345776699827,\n    \"median\": 91273391,\n    \"min\": 21669149,\n    \"stddev\": 89543653.71950394\n  },\n  \"skipper.servehost.app1_example_com.GET.304\": {\n    \"15m.rate\": 0.3503336738177459,\n    \"1m.rate\": 0.07923086447313292,\n    \"5m.rate\": 0.27019839341602214,\n    \"75%\": 99351895.25,\n    \"95%\": 105381847,\n    \"99%\": 105381847,\n    \"99.9%\": 105381847,\n    \"count\": 4,\n    \"max\": 105381847,\n    \"mean\": 47621612,\n    \"mean.rate\": 0.03087161486272533,\n    \"median\": 41676170.5,\n    \"min\": 1752260,\n    \"stddev\": 46489302.203724876\n  },\n  \"skipper.servehost.app1_example_com.GET.401\": {\n    \"15m.rate\": 0.16838468990057648,\n    \"1m.rate\": 0.01572861413072501,\n    \"5m.rate\": 0.1194724817779537,\n    \"75%\": 91094832,\n    \"95%\": 91094832,\n    \"99%\": 91094832,\n    \"99.9%\": 91094832,\n    \"count\": 2,\n    \"max\": 91094832,\n    \"mean\": 58090623,\n    \"mean.rate\": 0.012304914018033056,\n    \"median\": 58090623,\n    \"min\": 25086414,\n    \"stddev\": 33004209\n  }\n},\n\n\n\nTo change the sampling type of how metrics are handled from\n\nuniform\n\nto \nexponential decay\n,\nyou can use the following option, which is better for not so huge\nutilized applications (less than 100 requests per second):\n\n\n-metrics-exp-decay-sample\n    use exponentially decaying sample in metrics\n\n\n\nGo metrics\n\n\nMetrics from the\n\ngo runtime memstats\n\nare exposed from skipper to the metrics endpoint, default listener\n:9911, on path /metrics :\n\n\n\"gauges\": {\n  \"skipper.runtime.MemStats.Alloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.BuckHashSys\": {\n    \"value\": 1452675\n  },\n  \"skipper.runtime.MemStats.DebugGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.EnableGC\": {\n    \"value\": 1\n  },\n  \"skipper.runtime.MemStats.Frees\": {\n    \"value\": 121\n  },\n  \"skipper.runtime.MemStats.HeapAlloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.HeapIdle\": {\n    \"value\": 778240\n  },\n  \"skipper.runtime.MemStats.HeapInuse\": {\n    \"value\": 4988928\n  },\n  \"skipper.runtime.MemStats.HeapObjects\": {\n    \"value\": 24005\n  },\n  \"skipper.runtime.MemStats.HeapReleased\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.HeapSys\": {\n    \"value\": 5767168\n  },\n  \"skipper.runtime.MemStats.LastGC\": {\n    \"value\": 1516098381155094500\n  },\n  \"skipper.runtime.MemStats.Lookups\": {\n    \"value\": 2\n  },\n  \"skipper.runtime.MemStats.MCacheInuse\": {\n    \"value\": 6944\n  },\n  \"skipper.runtime.MemStats.MCacheSys\": {\n    \"value\": 16384\n  },\n  \"skipper.runtime.MemStats.MSpanInuse\": {\n    \"value\": 77368\n  },\n  \"skipper.runtime.MemStats.MSpanSys\": {\n    \"value\": 81920\n  },\n  \"skipper.runtime.MemStats.Mallocs\": {\n    \"value\": 1459\n  },\n  \"skipper.runtime.MemStats.NextGC\": {\n    \"value\": 4194304\n  },\n  \"skipper.runtime.MemStats.NumGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.PauseTotalNs\": {\n    \"value\": 683352\n  },\n  \"skipper.runtime.MemStats.StackInuse\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.StackSys\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.Sys\": {\n    \"value\": 9246968\n  },\n  \"skipper.runtime.MemStats.TotalAlloc\": {\n    \"value\": 35127624\n  },\n  \"skipper.runtime.NumCgoCall\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.NumGoroutine\": {\n    \"value\": 11\n  },\n  \"skipper.runtime.NumThread\": {\n    \"value\": 9\n  }\n},\n\"histograms\": {\n  \"skipper.runtime.MemStats.PauseNs\": {\n    \"75%\": 82509.25,\n    \"95%\": 132609,\n    \"99%\": 132609,\n    \"99.9%\": 132609,\n    \"count\": 12,\n    \"max\": 132609,\n    \"mean\": 56946,\n    \"median\": 39302.5,\n    \"min\": 28749,\n    \"stddev\": 31567.015005117817\n  }\n\n\n\n}\n\n\nDataclient\n\n\nDataclients poll some kind of data source for routes. To change the\ntimeout for calls that polls a dataclient, which could be the\nKubernetes API, use the following option:\n\n\n-source-poll-timeout int\n    polling timeout of the routing data sources, in milliseconds (default 3000)\n\n\n\nRouting table information\n\n\nSkipper allows you to get some runtime insights. You can get the\ncurrent routing table from skipper with in the\n\neskip file format\n:\n\n\n% curl localhost:9911/routes\n*\n  -\n \"http://localhost:12345/\"\n\n\n\nYou also can get the number of routes \nX-Count\n and the UNIX timestamp\nof the last route table update \nX-Timestamp\n, using a HEAD request:\n\n\n% curl -I localhost:9911/routes\nHTTP/1.1 200 OK\nContent-Type: text/plain\nX-Count: 1\nX-Timestamp: 1517777628\nDate: Sun, 04 Feb 2018 20:54:31 GMT", 
            "title": "Operations"
        }, 
        {
            "location": "/operations/#operations", 
            "text": "This is the work in progress operations guide for showing information,\nwhich are relevant for production use.  Skipper is proven to scale with number of routes beyond 200.000 routes\nper instance. Skipper is running with peaks to 45.000 http requests\nper second using multiple instances.", 
            "title": "Operations"
        }, 
        {
            "location": "/operations/#connection-options", 
            "text": "Skipper's connection options are allowing you to set Go's  http.Server \nOptions on the client side and  http.Transport  on the backend side.  \"It is recommended to read this blog post about net http timeouts \nin order to better understand the impact of these settings.", 
            "title": "Connection Options"
        }, 
        {
            "location": "/operations/#backend", 
            "text": "Backend is the side skipper opens a client connection to.  Closing idle connections is required for DNS failover, because Go's http.Transport  caches\nDNS lookups and needs to create new connections for doing so. Skipper\nwill start a goroutine and use the specified time.Duration  to call\nCloseIdleConnections() on that http.Transport .  -close-idle-conns-period string\n    period of closing all idle connections in seconds or as a\n    duration string. Not closing when less than 0 (default \"20\")  This will set MaxIdleConnsPerHost on the http.Transport  to limit\nthe number of idle connections per backend such that we do not run out\nof sockets.  -idle-conns-num int\n    maximum idle connections per backend host (default 64)  This will set MaxIdleConns on the http.Transport  to limit\nthe number for all backends such that we do not run out of sockets.  -max-idle-connection-backend int\n    sets the maximum idle connections for all backend connections  This will set TLSHandshakeTimeout on the http.Transport  to have\ntimeouts based on TLS connections.  -tls-timeout-backend duration\n    sets the TLS handshake timeout for backend connections (default 1m0s)  This will set Timeout on net.Dialer  that is the\nimplementation of DialContext, which is the TCP connection pool used in the http.Transport .  -timeout-backend duration\n    sets the TCP client connection timeout for backend connections (default 1m0s)  This will set KeepAlive on net.Dialer  that is the\nimplementation of DialContext, which is the TCP connection pool used in the http.Transport .  -keepalive-backend duration\n    sets the keepalive for backend connections (default 30s)  This will set DualStack (IPv4 and IPv6) on net.Dialer  that is the\nimplementation of DialContext, which is the TCP connection pool used in the http.Transport .  -enable-dualstack-backend\n    enables DualStack for backend connections (default true)", 
            "title": "Backend"
        }, 
        {
            "location": "/operations/#client", 
            "text": "Client is the side skipper gets incoming calls from.\nHere we can set timeouts in different parts of the http connection.  This will set ReadTimeout in http.Server  handling\nincoming calls from your clients.  -read-timeout-server duration\n    set ReadTimeout for http server connections (default 5m0s)  This will set ReadHeaderTimeout in http.Server  handling\nincoming calls from your clients.  -read-header-timeout-server duration\n    set ReadHeaderTimeout for http server connections (default 1m0s)  This will set WriteTimeout in http.Server  handling\nincoming calls from your clients.  -write-timeout-server duration\n    set WriteTimeout for http server connections (default 1m0s)  This will set IdleTimeout in http.Server  handling\nincoming calls from your clients.  -idle-timeout-server duration\n    maximum idle connections per backend host (default 1m0s)  This will set MaxHeaderBytes in http.Server  to limit the\nsize of the http header from your clients.  -max-header-bytes int\n    set MaxHeaderBytes for http server connections (default 1048576)", 
            "title": "Client"
        }, 
        {
            "location": "/operations/#monitoring", 
            "text": "Monitoring is one of the most important things you need to run in\nproduction and skipper has a  godoc page \nfor the  metrics package ,\ndescribing options and most keys you will find in the metrics handler\nendpoint. The default is listening on  :9911/metrics . You can modify\nthe listen port with the  -support-listener  flag.", 
            "title": "Monitoring"
        }, 
        {
            "location": "/operations/#prometheus", 
            "text": "In case you want to get metrics in  Prometheus  format exposed, use this\noption to enable it:  -enable-prometheus-metrics  It will return  Prometheus  metrics on the\ncommon metrics endpoint :9911/metrics.", 
            "title": "Prometheus"
        }, 
        {
            "location": "/operations/#connection-metrics", 
            "text": "This option will enable known loadbalancer connections metrics, like\ncounters for active and new connections. This feature sets a metrics\ncallback on  http.Server  and\nuses a counter to collect http.ConnState .  -enable-connection-metrics\n    enables connection metrics for http server connections  It will expose them in /metrics, for example json structure looks like this example:  {\n  \"counters\": {\n    \"skipper.lb-conn-active\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-closed\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-idle\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-new\": {\n      \"count\": 6\n    }\n  },\n  /* stripped a lot of metrics here */\n}", 
            "title": "Connection metrics"
        }, 
        {
            "location": "/operations/#application-metrics", 
            "text": "Application metrics for your proxied applications you can enable with the option:  -serve-host-metrics\n    enables reporting total serve time metrics for each host  This will make sure you will get stats for each \"Host\" header as \"timers\":  \"timers\": {\n  \"skipper.servehost.app1_example_com.GET.200\": {\n    \"15m.rate\": 0.06830666203045982,\n    \"1m.rate\": 2.162612637718806e-06,\n    \"5m.rate\": 0.008312609284452856,\n    \"75%\": 236603815,\n    \"95%\": 236603815,\n    \"99%\": 236603815,\n    \"99.9%\": 236603815,\n    \"count\": 3,\n    \"max\": 236603815,\n    \"mean\": 116515451.66666667,\n    \"mean.rate\": 0.0030589345776699827,\n    \"median\": 91273391,\n    \"min\": 21669149,\n    \"stddev\": 89543653.71950394\n  },\n  \"skipper.servehost.app1_example_com.GET.304\": {\n    \"15m.rate\": 0.3503336738177459,\n    \"1m.rate\": 0.07923086447313292,\n    \"5m.rate\": 0.27019839341602214,\n    \"75%\": 99351895.25,\n    \"95%\": 105381847,\n    \"99%\": 105381847,\n    \"99.9%\": 105381847,\n    \"count\": 4,\n    \"max\": 105381847,\n    \"mean\": 47621612,\n    \"mean.rate\": 0.03087161486272533,\n    \"median\": 41676170.5,\n    \"min\": 1752260,\n    \"stddev\": 46489302.203724876\n  },\n  \"skipper.servehost.app1_example_com.GET.401\": {\n    \"15m.rate\": 0.16838468990057648,\n    \"1m.rate\": 0.01572861413072501,\n    \"5m.rate\": 0.1194724817779537,\n    \"75%\": 91094832,\n    \"95%\": 91094832,\n    \"99%\": 91094832,\n    \"99.9%\": 91094832,\n    \"count\": 2,\n    \"max\": 91094832,\n    \"mean\": 58090623,\n    \"mean.rate\": 0.012304914018033056,\n    \"median\": 58090623,\n    \"min\": 25086414,\n    \"stddev\": 33004209\n  }\n},  To change the sampling type of how metrics are handled from uniform \nto  exponential decay ,\nyou can use the following option, which is better for not so huge\nutilized applications (less than 100 requests per second):  -metrics-exp-decay-sample\n    use exponentially decaying sample in metrics", 
            "title": "Application metrics"
        }, 
        {
            "location": "/operations/#go-metrics", 
            "text": "Metrics from the go runtime memstats \nare exposed from skipper to the metrics endpoint, default listener\n:9911, on path /metrics :  \"gauges\": {\n  \"skipper.runtime.MemStats.Alloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.BuckHashSys\": {\n    \"value\": 1452675\n  },\n  \"skipper.runtime.MemStats.DebugGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.EnableGC\": {\n    \"value\": 1\n  },\n  \"skipper.runtime.MemStats.Frees\": {\n    \"value\": 121\n  },\n  \"skipper.runtime.MemStats.HeapAlloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.HeapIdle\": {\n    \"value\": 778240\n  },\n  \"skipper.runtime.MemStats.HeapInuse\": {\n    \"value\": 4988928\n  },\n  \"skipper.runtime.MemStats.HeapObjects\": {\n    \"value\": 24005\n  },\n  \"skipper.runtime.MemStats.HeapReleased\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.HeapSys\": {\n    \"value\": 5767168\n  },\n  \"skipper.runtime.MemStats.LastGC\": {\n    \"value\": 1516098381155094500\n  },\n  \"skipper.runtime.MemStats.Lookups\": {\n    \"value\": 2\n  },\n  \"skipper.runtime.MemStats.MCacheInuse\": {\n    \"value\": 6944\n  },\n  \"skipper.runtime.MemStats.MCacheSys\": {\n    \"value\": 16384\n  },\n  \"skipper.runtime.MemStats.MSpanInuse\": {\n    \"value\": 77368\n  },\n  \"skipper.runtime.MemStats.MSpanSys\": {\n    \"value\": 81920\n  },\n  \"skipper.runtime.MemStats.Mallocs\": {\n    \"value\": 1459\n  },\n  \"skipper.runtime.MemStats.NextGC\": {\n    \"value\": 4194304\n  },\n  \"skipper.runtime.MemStats.NumGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.PauseTotalNs\": {\n    \"value\": 683352\n  },\n  \"skipper.runtime.MemStats.StackInuse\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.StackSys\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.Sys\": {\n    \"value\": 9246968\n  },\n  \"skipper.runtime.MemStats.TotalAlloc\": {\n    \"value\": 35127624\n  },\n  \"skipper.runtime.NumCgoCall\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.NumGoroutine\": {\n    \"value\": 11\n  },\n  \"skipper.runtime.NumThread\": {\n    \"value\": 9\n  }\n},\n\"histograms\": {\n  \"skipper.runtime.MemStats.PauseNs\": {\n    \"75%\": 82509.25,\n    \"95%\": 132609,\n    \"99%\": 132609,\n    \"99.9%\": 132609,\n    \"count\": 12,\n    \"max\": 132609,\n    \"mean\": 56946,\n    \"median\": 39302.5,\n    \"min\": 28749,\n    \"stddev\": 31567.015005117817\n  }  }", 
            "title": "Go metrics"
        }, 
        {
            "location": "/operations/#dataclient", 
            "text": "Dataclients poll some kind of data source for routes. To change the\ntimeout for calls that polls a dataclient, which could be the\nKubernetes API, use the following option:  -source-poll-timeout int\n    polling timeout of the routing data sources, in milliseconds (default 3000)", 
            "title": "Dataclient"
        }, 
        {
            "location": "/operations/#routing-table-information", 
            "text": "Skipper allows you to get some runtime insights. You can get the\ncurrent routing table from skipper with in the eskip file format :  % curl localhost:9911/routes\n*\n  -  \"http://localhost:12345/\"  You also can get the number of routes  X-Count  and the UNIX timestamp\nof the last route table update  X-Timestamp , using a HEAD request:  % curl -I localhost:9911/routes\nHTTP/1.1 200 OK\nContent-Type: text/plain\nX-Count: 1\nX-Timestamp: 1517777628\nDate: Sun, 04 Feb 2018 20:54:31 GMT", 
            "title": "Routing table information"
        }, 
        {
            "location": "/videos/", 
            "text": "How to build Skipper\n\n\nWe expect you to have \nGo\n and \nglide\n installed.\n\n\nHow to build Skipper without plugins\n\n\n\n\n\nHow to build Skipper with plugins\n\n\nTODO\n\n\nHow to run Skipper\n\n\nWe expect you to have already built Skipper.\n\n\nTODO", 
            "title": "Videos"
        }, 
        {
            "location": "/videos/#how-to-build-skipper", 
            "text": "We expect you to have  Go  and  glide  installed.", 
            "title": "How to build Skipper"
        }, 
        {
            "location": "/videos/#how-to-build-skipper-without-plugins", 
            "text": "", 
            "title": "How to build Skipper without plugins"
        }, 
        {
            "location": "/videos/#how-to-build-skipper-with-plugins", 
            "text": "TODO", 
            "title": "How to build Skipper with plugins"
        }, 
        {
            "location": "/videos/#how-to-run-skipper", 
            "text": "We expect you to have already built Skipper.  TODO", 
            "title": "How to run Skipper"
        }
    ]
}