{
    "docs": [
        {
            "location": "/", 
            "text": "Architecture\n\n\nSkipper is written as library and has also 2 binaries, named \nskipper\n\nand \neskip\n.", 
            "title": "Architecture"
        }, 
        {
            "location": "/#architecture", 
            "text": "Skipper is written as library and has also 2 binaries, named  skipper \nand  eskip .", 
            "title": "Architecture"
        }, 
        {
            "location": "/deployments/", 
            "text": "Deployments and Data-Clients\n\n\nEdge HTTP Routing\n\n\nEdge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.\n\n\nOn the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.\n\n\nIn this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.\n\n\nTo support this scenario we have the \netcd dataclient\n.\n\n\nEtcd\n is a distributed database.\n\n\nTODO: why we use ETCD for this purpose\n\n\nKubernetes Ingress\n\n\nKubernetes Ingress\n is the\ncomponent responsible to route traffic into your\n\nKubernetes\n cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the\n\nkubernetes dataclient\n and is used in\nproduction since end of 2016.\n\n\nSkipper as ingress controller does not need to have any file\nconfiguration or anything external which configures skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.\n\n\nRead more about \nSkipper's kubernetes dataclient\n.\n\n\nInkeeper Routes API\n\n\nSkipper\n can read from an\n\nInkeeper API\n, if you like to\ncreate routes via an API.\nOur \nInkeeper API dataclient\n can be used\nas well. It was used in production in the past. (TODO: do we use it somwhere?)\n\n\nDemos / Talks\n\n\nIn demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe \nroute-string dataclient\n.\n\n\nSimple Routes File\n\n\nThe most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the \nEskip file dataclient\n is about.", 
            "title": "Deployments"
        }, 
        {
            "location": "/deployments/#deployments-and-data-clients", 
            "text": "", 
            "title": "Deployments and Data-Clients"
        }, 
        {
            "location": "/deployments/#edge-http-routing", 
            "text": "Edge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.  On the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.  In this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.  To support this scenario we have the  etcd dataclient .  Etcd  is a distributed database.  TODO: why we use ETCD for this purpose", 
            "title": "Edge HTTP Routing"
        }, 
        {
            "location": "/deployments/#kubernetes-ingress", 
            "text": "Kubernetes Ingress  is the\ncomponent responsible to route traffic into your Kubernetes  cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the kubernetes dataclient  and is used in\nproduction since end of 2016.  Skipper as ingress controller does not need to have any file\nconfiguration or anything external which configures skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.  Read more about  Skipper's kubernetes dataclient .", 
            "title": "Kubernetes Ingress"
        }, 
        {
            "location": "/deployments/#inkeeper-routes-api", 
            "text": "Skipper  can read from an Inkeeper API , if you like to\ncreate routes via an API.\nOur  Inkeeper API dataclient  can be used\nas well. It was used in production in the past. (TODO: do we use it somwhere?)", 
            "title": "Inkeeper Routes API"
        }, 
        {
            "location": "/deployments/#demos-talks", 
            "text": "In demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe  route-string dataclient .", 
            "title": "Demos / Talks"
        }, 
        {
            "location": "/deployments/#simple-routes-file", 
            "text": "The most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the  Eskip file dataclient  is about.", 
            "title": "Simple Routes File"
        }, 
        {
            "location": "/dataclients/eskip-file/", 
            "text": "Eskip File\n\n\nEskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The \nfile format eskip\n\nshows your route definitions in a clear way:\n\n\n% cat example.eskip\nhello: Path(\"/hello\") -\n \"https://www.example.org\"'\n\n\n\nThe \nskipper project\n has two\nbinaries, one is \nskipper\n, the other is \neskip\n.\n\nEskip\n\ncan be used to validate the syntax of your routes file before\nreloading a production server:\n\n\n% eskip check example.eskip\n\n\n\nTo run skipper serving routes from an \neskip\n file you have to use\n\n-routes-file \nfile\n parameter:\n\n\n% skipper -routes-file example.eskip\n\n\n\nA more complicated example with different routes, matches,\n\npredicates\n and\n\nfilters\n shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:\n\n\n% cat complicated_example.eskip\nhost-header-match:\n         Host(\"^skipper.teapot.org$\")\n         -\n setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -\n \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaidu-path-match:\n        Path(\"/baidu\")\n        -\n setRequestHeader(\"Host\", \"www.baidu.com\")\n        -\n setPath(\"/s\")\n        -\n setQuery(\"wd\", \"godoc skipper\")\n        -\n \"http://www.baidu.com\";\ngoogle-wildcard-match:\n        *\n        -\n setPath(\"/search\")\n        -\n setQuery(\"q\", \"godoc skipper\")\n        -\n \"https://www.google.com\";\nyandex-wildacard-if-cookie:\n        * \n Cookie(\"yandex\", \"true\")\n        -\n setPath(\"/search/\")\n        -\n setQuery(\"text\", \"godoc skipper\")\n        -\n tee(\"http://127.0.0.1:12345/\")\n        -\n \"https://yandex.ru\";\n\n\n\nThe former example shows 4 routes: host-header-match,\nbaidu-path-match, google-wildcard-match and yandex-wildcard-if-cookie.\n\n\n\n\nhost-header-match:\n\n\nused if HTTP host header is exactly: \"skipper.teapot.org\",\n\n\nsets a Basic Authorization header and\n\n\nsends the modified request to https://target-to.auth-with.basic-auth.enterprise.com\n\n\nbaidu-path-match:\n\n\nused in case the request patch matches /baidu\n\n\nit will set the Host header to the proxy request\n\n\nit will set the path from /baidu to /s\n\n\nit will set the querystring to \"ws=godoc skipper\" and\n\n\nsends the modified request to http://baidu.com\n\n\ngoogle-wildcard-match:\n\n\nused as default if no other route matches\n\n\nit will set the path to /search\n\n\nit will set the querystring to \"q=godoc skipper\" and\n\n\nsends the modified request to https://www.google.com\n\n\nyandex-wildcard-if-cookie:\n\n\nused as default if a Cookie named \"yandex\" has the value \"true\"\n\n\nit will set the path to /search/\n\n\nit will set the querystring to \"text=godoc skipper\"\n\n\nit will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix \ntee\n) and drop the response and\n\n\nsends the modified request to https://yandex.ru\n\n\n\n\nMore examples you find in \neskip file format\n\ndescription, in \nfilters\n\nand in \npredicates\n.\n\n\nEskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):\n\n\n% curl localhost:9911/routes\n*\n  -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -\n inlineContent(\"{\\\"foo\\\": 3}\")\n  -\n \nshunt", 
            "title": "Eskip"
        }, 
        {
            "location": "/dataclients/eskip-file/#eskip-file", 
            "text": "Eskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The  file format eskip \nshows your route definitions in a clear way:  % cat example.eskip\nhello: Path(\"/hello\") -  \"https://www.example.org\"'  The  skipper project  has two\nbinaries, one is  skipper , the other is  eskip . Eskip \ncan be used to validate the syntax of your routes file before\nreloading a production server:  % eskip check example.eskip  To run skipper serving routes from an  eskip  file you have to use -routes-file  file  parameter:  % skipper -routes-file example.eskip  A more complicated example with different routes, matches, predicates  and filters  shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:  % cat complicated_example.eskip\nhost-header-match:\n         Host(\"^skipper.teapot.org$\")\n         -  setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -  \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaidu-path-match:\n        Path(\"/baidu\")\n        -  setRequestHeader(\"Host\", \"www.baidu.com\")\n        -  setPath(\"/s\")\n        -  setQuery(\"wd\", \"godoc skipper\")\n        -  \"http://www.baidu.com\";\ngoogle-wildcard-match:\n        *\n        -  setPath(\"/search\")\n        -  setQuery(\"q\", \"godoc skipper\")\n        -  \"https://www.google.com\";\nyandex-wildacard-if-cookie:\n        *   Cookie(\"yandex\", \"true\")\n        -  setPath(\"/search/\")\n        -  setQuery(\"text\", \"godoc skipper\")\n        -  tee(\"http://127.0.0.1:12345/\")\n        -  \"https://yandex.ru\";  The former example shows 4 routes: host-header-match,\nbaidu-path-match, google-wildcard-match and yandex-wildcard-if-cookie.   host-header-match:  used if HTTP host header is exactly: \"skipper.teapot.org\",  sets a Basic Authorization header and  sends the modified request to https://target-to.auth-with.basic-auth.enterprise.com  baidu-path-match:  used in case the request patch matches /baidu  it will set the Host header to the proxy request  it will set the path from /baidu to /s  it will set the querystring to \"ws=godoc skipper\" and  sends the modified request to http://baidu.com  google-wildcard-match:  used as default if no other route matches  it will set the path to /search  it will set the querystring to \"q=godoc skipper\" and  sends the modified request to https://www.google.com  yandex-wildcard-if-cookie:  used as default if a Cookie named \"yandex\" has the value \"true\"  it will set the path to /search/  it will set the querystring to \"text=godoc skipper\"  it will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix  tee ) and drop the response and  sends the modified request to https://yandex.ru   More examples you find in  eskip file format \ndescription, in  filters \nand in  predicates .  Eskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):  % curl localhost:9911/routes\n*\n  -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -  inlineContent(\"{\\\"foo\\\": 3}\")\n  -   shunt", 
            "title": "Eskip File"
        }, 
        {
            "location": "/dataclients/etcd/", 
            "text": "ETCD\n\n\nTODO", 
            "title": "Etcd"
        }, 
        {
            "location": "/dataclients/etcd/#etcd", 
            "text": "TODO", 
            "title": "ETCD"
        }, 
        {
            "location": "/dataclients/inkeeper-api/", 
            "text": "Inkeeper API\n\n\nTODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/inkeeper-api/#inkeeper-api", 
            "text": "TODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/kubernetes/", 
            "text": "Kubernetes\n\n\nSkipper's Kubernetes dataclient can be used, if you want to run skipper as\n\nkubernetes-ingress-controller\n.\nIt will get it's route information from provisioned\n\nIngress Objects\n.\nDetailed information you find in our \ngodoc for dataclient kubernetes\n.\n\n\nSkipper Features\n\n\nSkipper has the following main features:\n\n\n\n\nFilters - create, update, delete all kind of HTTP data\n\n\ncollection of base http manipulations\n: for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling\n\n\ncookie handling\n\n\ncircuitbreakers\n: consecutiveBreaker or rateBreaker\n\n\nratelimit\n: based on client or backend data\n\n\nShadow traffic: \ntee()\n\n\nPredicates - advanced matching capability\n\n\nURL Path match: \nPath(\"/foo\")\n\n\nHost header match: \nHost(\"^www.example.org$\")\n\n\nQuerystring\n: \nQueryParam(\"featureX\")\n\n\nCookie based\n: \nCookie(\"alpha\", /^enabled$/)\n\n\nsource whitelist\n: \nSource(\"1.2.3.4/24\")\n\n\ntime based interval\n\n\ntraffic by percentage\n supports also sticky sessions\n\n\nKubernetes integration\n\n\nAll Filters and Predicates can be used with 2 annotations\n\n\nPredicates: \nzalando.org/skipper-predicate\n\n\nFilters: \nzalando.org/skipper-filter\n\n\n\n\n\n\nmetrics\n\n\naccess logs\n\n\nBlue-Green deployments, with another Ingress annotation \nzalando.org/backend-weights\n, see Advanced Examples section\n\n\n\n\n3 Minutes Skipper in Kubernetes introduction\n\n\nYou should have a base understanding of \nKubernetes\n and\n\nIngress\n.\n\n\nPrerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.\n\n\nWe start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.\n\n\n% cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.9.115\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.9.115\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.115\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n        resources:\n          limits:\n            cpu: 200m\n            memory: 200Mi\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5\n\n\n\nWe now deploy a simple demo application serving html:\n\n\n% cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.117\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -\n inlineContent(\\\"\nbody style='color: white; background-color: green;'\nh1\nHello!\n/h1\n\\\") -\n \nshunt\n\"\n        ports:\n        - containerPort: 9090\n\n\n\nWe deploy a service type ClusterIP that we will select from ingress:\n\n\n% cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: sszuecs-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: sszuecs-demo\n\n\n\nTo deploy both, you have to run:\n\n\n% kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml\n\n\n\nNow we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:\n\n\n% cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo.\nmydomain.org\n\n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80\n\n\n\nTo deploy this ingress, you have to run:\n\n\n% kubectl create -f demo-ing.yaml\n\n\n\nSkipper will configure itself for the given ingress, such that you can test doing:\n\n\n% curl -v -H\"Host: skipper-demo.\nmydomain.org\n\" http://\nnodeip\n:9999/\n\n\n\nThe next question you may ask is: how to expose this to your customers?\n\n\nThe answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS \n.\n\nto your frontend loadbalancer IP that directs all traffic from \n.\n\nto all Kubernetes worker nodes on TCP port 9999.\n\n\nA more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example\n\nkube-aws-ingress-controller\n,\nand your DNS, \nexternal-dns\n\nautomatically.\n\n\nSkipper Ingress Annotations\n\n\n\n\n\n\n\n\nAnnotation\n\n\nexample data\n\n\nusage\n\n\n\n\n\n\n\n\n\n\nzalando.org/backend-weights\n\n\n{\"my-app-1\": 80, \"my-app-2\": 20}\n\n\ngreen-blue deployments\n\n\n\n\n\n\nzalando.org/skipper-filter\n\n\nconsecutiveBreaker(15)\n\n\narbitrary filters\n\n\n\n\n\n\nzalando.org/skipper-predicate\n\n\nQueryParam(\"version\", \"^alpha$\")\n\n\narbitrary predicates\n\n\n\n\n\n\nzalando.org/ratelimit\n\n\nratelimit(50, \"1m\")\n\n\ndeprecated, use zalando.org/skipper-filter instead\n\n\n\n\n\n\n\n\nBasic HTTP manipulations\n\n\nHTTP manipulations are done by using skipper filters.\nA basic example how to use skipper filters in ingress:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nAdd a request Header\n\n\nAdd a header in the request path to your backend.\n\n\nsetRequestHeader(\"X-Foo\", \"bar\")\n\n\n\nAdd a response Header\n\n\nAdd a header in the response path of your clients.\n\n\nsetResponseHeader(\"X-Foo\", \"bar\")\n\n\n\nSet the Path\n\n\nChange the path in the request path to your backend.\n\n\nsetPath(\"/newPath/\")\n\n\n\nSet the Querystring\n\n\nSet the Querystring in the request path to your backend.\n\n\nsetQuery(\"text\", \"godoc skipper\")\n\n\n\nRedirect\n\n\nCreate a redirect with HTTP code 301 to https://foo.example.org/.\n\n\nredirectTo(301, \"https://foo.example.org/\")\n\n\n\nCookies\n\n\nSet a Cookie in the request path to your backend.\n\n\nrequestCookie(\"test-session\", \"abc\")\n\n\n\nSet a Cookie in the response path of your clients.\n\n\nresponseCookie(\"test-session\", \"abc\", 31536000)\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\n\n// response cookie without HttpOnly:\njsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")\n\n\n\nAuthorization\n\n\nOur \nfilter auth\ngodoc\n\nshows how to use filters for authorization.\n\n\nBasic Auth\n\n\n% htpasswd -nbm myName myPassword\n\nbasicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")\n\n\n\nDiagnosis - Throttling - Latency\n\n\nFor diagnosis purpose there are filters that enables you to throttle\nthe bandwidth or add latency. For the full list of filters see our\n\ndiag filter godoc page\n.\n\n\nbandwidth(30) // incoming in kb/s\nbackendBandwidth(30) // outgoing in kb/s\nbackendLatency(120) // in ms\n\n\n\nFlowID to trace request flows\n\n\nTo trace request flows skipper can generate a unique Flow Id for\nevery HTTP request that it receives.\nSkipper sets the X-Flow-Id header to a unique value. Read more about\nthis in our \nflowid filter godoc\n.\n\n\n flowId(\"reuse\")\n\n\n\nBlue-Green deployments\n\n\nTo do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification. \nzalando.org/backend-weights\n\nis a hash map, which key relates to the \nserviceName\n of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.\n\n\nIn the following example \nmy-app-1\n service will get \n80%\n of the traffic\nand \nmy-app-2\n will get \n20%\n of the traffic:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /\n\n\n\nFilters\n\n\nFilters can modify http requests and responses. There are a plenty of\nthings you can do with them.\n\n\nCircuitbreaker\n\n\nConsecutive Breaker\n\n\nThe \nconsecutiveBreaker\n\nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments\n\ndocumented\n:\n\n\nconsecutiveBreaker(15)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRate Breaker\n\n\nThe \nrateBreaker\n\nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments\n\ndocumented\n.\n\n\nrateBreaker(30, 300)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRatelimits\n\n\nMore details you will find in \nratelimit package\n\nand \nkubernetes dataclient\n documentation.\n\n\nClient Ratelimits\n\n\nThe example shows 20 calls per hour per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nIf you need to rate limit service to service communication and\nyou use Authorization headers to protect your backend from your\nclients, then you can pass a 3 parameter to group clients by \"Authorization\nHeader\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nService Ratelimits\n\n\nThe example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nShadow Traffic\n\n\nIf you want to test a new replacement of a production service with\nproduction load, you can copy incoming requests to your new endpoint\nand ignore the responses from your new backend. This can be done by\nthe \ntee() and teenf() filters\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: teenf(\"https://app-new.example.org\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nPredicates\n\n\nPredicates\n\nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.\n\n\nYou can use all kinds of \npredicates\n\nwith \nfilters\n together.\n\n\nFeature Toggle\n\n\nFeature toggles are often implemented as query string to select a new\nfeature. Normally you would have to implement this in your\napplication, but Skipper can help you with that and you can select\nroutes with an ingress definition.\n\n\nYou create 2 ingresses that matches the same route, here host header\nmatch to \napp-default.example.org\n and one ingress has a defined query\nparameter to select the route to the alpha version deployment. If the\nquery string in the URL has \nversion=alpha\n set, for example\n\nhttps://app-default.example.org/mypath?version=alpha\n, the service\n\nalpha-svc\n will get the traffic, if not \nprod-svc\n.\n\n\nalpha-svc:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80\n\n\n\nprod-svc:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: prod-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: prod-svc\n          servicePort: 80\n\n\n\nIP Whitelisting\n\n\nThis ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nA/B test\n\n\nImplementing A/B testing is heavy. Skipper can help you to do\nthat. You need to have a traffic split somewhere and have your\ncustomers sticky to either A or B flavor of your application. Most\nlikely people would implement using cookies. Skipper can set a\n\ncookie with responseCookie()\n\nin a response to the client and the\n\ncookie predicate\n\ncan be used to match the route based on the cookie. Like this you can\nhave sticky sessions to either A or B for your clients.  This example\nshows to have 10% traffic using A and the rest using B.\n\n\n10% choice of setting the Cookie \"flavor\" to \"A\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Traffic(.1)\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80\n\n\n\nRest is setting Cookie \"flavor\" to \"B\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80\n\n\n\nTo be sticky, you have to create 2 ingress with predicate to match\nroutes with the cookie we set before. For \"A\" this would be:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80\n\n\n\nFor \"B\" this would be:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80\n\n\n\nChaining Filters and Predicates\n\n\nYou can set multiple filters in a chain similar to the \neskip format\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) \n Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -\n requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes", 
            "text": "Skipper's Kubernetes dataclient can be used, if you want to run skipper as kubernetes-ingress-controller .\nIt will get it's route information from provisioned Ingress Objects .\nDetailed information you find in our  godoc for dataclient kubernetes .", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#skipper-features", 
            "text": "Skipper has the following main features:   Filters - create, update, delete all kind of HTTP data  collection of base http manipulations : for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling  cookie handling  circuitbreakers : consecutiveBreaker or rateBreaker  ratelimit : based on client or backend data  Shadow traffic:  tee()  Predicates - advanced matching capability  URL Path match:  Path(\"/foo\")  Host header match:  Host(\"^www.example.org$\")  Querystring :  QueryParam(\"featureX\")  Cookie based :  Cookie(\"alpha\", /^enabled$/)  source whitelist :  Source(\"1.2.3.4/24\")  time based interval  traffic by percentage  supports also sticky sessions  Kubernetes integration  All Filters and Predicates can be used with 2 annotations  Predicates:  zalando.org/skipper-predicate  Filters:  zalando.org/skipper-filter    metrics  access logs  Blue-Green deployments, with another Ingress annotation  zalando.org/backend-weights , see Advanced Examples section", 
            "title": "Skipper Features"
        }, 
        {
            "location": "/dataclients/kubernetes/#3-minutes-skipper-in-kubernetes-introduction", 
            "text": "You should have a base understanding of  Kubernetes  and Ingress .  Prerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.  We start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.  % cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.9.115\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.9.115\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.115\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n        resources:\n          limits:\n            cpu: 200m\n            memory: 200Mi\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5  We now deploy a simple demo application serving html:  % cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.117\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -  inlineContent(\\\" body style='color: white; background-color: green;' h1 Hello! /h1 \\\") -   shunt \"\n        ports:\n        - containerPort: 9090  We deploy a service type ClusterIP that we will select from ingress:  % cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: sszuecs-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: sszuecs-demo  To deploy both, you have to run:  % kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml  Now we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:  % cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo. mydomain.org \n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80  To deploy this ingress, you have to run:  % kubectl create -f demo-ing.yaml  Skipper will configure itself for the given ingress, such that you can test doing:  % curl -v -H\"Host: skipper-demo. mydomain.org \" http:// nodeip :9999/  The next question you may ask is: how to expose this to your customers?  The answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS  . \nto your frontend loadbalancer IP that directs all traffic from  . \nto all Kubernetes worker nodes on TCP port 9999.  A more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example kube-aws-ingress-controller ,\nand your DNS,  external-dns \nautomatically.", 
            "title": "3 Minutes Skipper in Kubernetes introduction"
        }, 
        {
            "location": "/dataclients/kubernetes/#skipper-ingress-annotations", 
            "text": "Annotation  example data  usage      zalando.org/backend-weights  {\"my-app-1\": 80, \"my-app-2\": 20}  green-blue deployments    zalando.org/skipper-filter  consecutiveBreaker(15)  arbitrary filters    zalando.org/skipper-predicate  QueryParam(\"version\", \"^alpha$\")  arbitrary predicates    zalando.org/ratelimit  ratelimit(50, \"1m\")  deprecated, use zalando.org/skipper-filter instead", 
            "title": "Skipper Ingress Annotations"
        }, 
        {
            "location": "/dataclients/kubernetes/#basic-http-manipulations", 
            "text": "HTTP manipulations are done by using skipper filters.\nA basic example how to use skipper filters in ingress:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Basic HTTP manipulations"
        }, 
        {
            "location": "/dataclients/kubernetes/#add-a-request-header", 
            "text": "Add a header in the request path to your backend.  setRequestHeader(\"X-Foo\", \"bar\")", 
            "title": "Add a request Header"
        }, 
        {
            "location": "/dataclients/kubernetes/#add-a-response-header", 
            "text": "Add a header in the response path of your clients.  setResponseHeader(\"X-Foo\", \"bar\")", 
            "title": "Add a response Header"
        }, 
        {
            "location": "/dataclients/kubernetes/#set-the-path", 
            "text": "Change the path in the request path to your backend.  setPath(\"/newPath/\")", 
            "title": "Set the Path"
        }, 
        {
            "location": "/dataclients/kubernetes/#set-the-querystring", 
            "text": "Set the Querystring in the request path to your backend.  setQuery(\"text\", \"godoc skipper\")", 
            "title": "Set the Querystring"
        }, 
        {
            "location": "/dataclients/kubernetes/#redirect", 
            "text": "Create a redirect with HTTP code 301 to https://foo.example.org/.  redirectTo(301, \"https://foo.example.org/\")", 
            "title": "Redirect"
        }, 
        {
            "location": "/dataclients/kubernetes/#cookies", 
            "text": "Set a Cookie in the request path to your backend.  requestCookie(\"test-session\", \"abc\")  Set a Cookie in the response path of your clients.  responseCookie(\"test-session\", \"abc\", 31536000)\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\n\n// response cookie without HttpOnly:\njsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")", 
            "title": "Cookies"
        }, 
        {
            "location": "/dataclients/kubernetes/#authorization", 
            "text": "Our  filter auth\ngodoc \nshows how to use filters for authorization.", 
            "title": "Authorization"
        }, 
        {
            "location": "/dataclients/kubernetes/#basic-auth", 
            "text": "% htpasswd -nbm myName myPassword\n\nbasicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")", 
            "title": "Basic Auth"
        }, 
        {
            "location": "/dataclients/kubernetes/#diagnosis-throttling-latency", 
            "text": "For diagnosis purpose there are filters that enables you to throttle\nthe bandwidth or add latency. For the full list of filters see our diag filter godoc page .  bandwidth(30) // incoming in kb/s\nbackendBandwidth(30) // outgoing in kb/s\nbackendLatency(120) // in ms", 
            "title": "Diagnosis - Throttling - Latency"
        }, 
        {
            "location": "/dataclients/kubernetes/#flowid-to-trace-request-flows", 
            "text": "To trace request flows skipper can generate a unique Flow Id for\nevery HTTP request that it receives.\nSkipper sets the X-Flow-Id header to a unique value. Read more about\nthis in our  flowid filter godoc .   flowId(\"reuse\")", 
            "title": "FlowID to trace request flows"
        }, 
        {
            "location": "/dataclients/kubernetes/#blue-green-deployments", 
            "text": "To do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification.  zalando.org/backend-weights \nis a hash map, which key relates to the  serviceName  of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.  In the following example  my-app-1  service will get  80%  of the traffic\nand  my-app-2  will get  20%  of the traffic:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /", 
            "title": "Blue-Green deployments"
        }, 
        {
            "location": "/dataclients/kubernetes/#filters", 
            "text": "Filters can modify http requests and responses. There are a plenty of\nthings you can do with them.", 
            "title": "Filters"
        }, 
        {
            "location": "/dataclients/kubernetes/#circuitbreaker", 
            "text": "", 
            "title": "Circuitbreaker"
        }, 
        {
            "location": "/dataclients/kubernetes/#consecutive-breaker", 
            "text": "The  consecutiveBreaker \nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments documented :  consecutiveBreaker(15)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Consecutive Breaker"
        }, 
        {
            "location": "/dataclients/kubernetes/#rate-breaker", 
            "text": "The  rateBreaker \nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments documented .  rateBreaker(30, 300)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Rate Breaker"
        }, 
        {
            "location": "/dataclients/kubernetes/#ratelimits", 
            "text": "More details you will find in  ratelimit package \nand  kubernetes dataclient  documentation.", 
            "title": "Ratelimits"
        }, 
        {
            "location": "/dataclients/kubernetes/#client-ratelimits", 
            "text": "The example shows 20 calls per hour per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80  If you need to rate limit service to service communication and\nyou use Authorization headers to protect your backend from your\nclients, then you can pass a 3 parameter to group clients by \"Authorization\nHeader\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Client Ratelimits"
        }, 
        {
            "location": "/dataclients/kubernetes/#service-ratelimits", 
            "text": "The example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Service Ratelimits"
        }, 
        {
            "location": "/dataclients/kubernetes/#shadow-traffic", 
            "text": "If you want to test a new replacement of a production service with\nproduction load, you can copy incoming requests to your new endpoint\nand ignore the responses from your new backend. This can be done by\nthe  tee() and teenf() filters .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: teenf(\"https://app-new.example.org\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Shadow Traffic"
        }, 
        {
            "location": "/dataclients/kubernetes/#predicates", 
            "text": "Predicates \nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.  You can use all kinds of  predicates \nwith  filters  together.", 
            "title": "Predicates"
        }, 
        {
            "location": "/dataclients/kubernetes/#feature-toggle", 
            "text": "Feature toggles are often implemented as query string to select a new\nfeature. Normally you would have to implement this in your\napplication, but Skipper can help you with that and you can select\nroutes with an ingress definition.  You create 2 ingresses that matches the same route, here host header\nmatch to  app-default.example.org  and one ingress has a defined query\nparameter to select the route to the alpha version deployment. If the\nquery string in the URL has  version=alpha  set, for example https://app-default.example.org/mypath?version=alpha , the service alpha-svc  will get the traffic, if not  prod-svc .  alpha-svc:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80  prod-svc:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: prod-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: prod-svc\n          servicePort: 80", 
            "title": "Feature Toggle"
        }, 
        {
            "location": "/dataclients/kubernetes/#ip-whitelisting", 
            "text": "This ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "IP Whitelisting"
        }, 
        {
            "location": "/dataclients/kubernetes/#ab-test", 
            "text": "Implementing A/B testing is heavy. Skipper can help you to do\nthat. You need to have a traffic split somewhere and have your\ncustomers sticky to either A or B flavor of your application. Most\nlikely people would implement using cookies. Skipper can set a cookie with responseCookie() \nin a response to the client and the cookie predicate \ncan be used to match the route based on the cookie. Like this you can\nhave sticky sessions to either A or B for your clients.  This example\nshows to have 10% traffic using A and the rest using B.  10% choice of setting the Cookie \"flavor\" to \"A\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Traffic(.1)\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80  Rest is setting Cookie \"flavor\" to \"B\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80  To be sticky, you have to create 2 ingress with predicate to match\nroutes with the cookie we set before. For \"A\" this would be:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80  For \"B\" this would be:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80", 
            "title": "A/B test"
        }, 
        {
            "location": "/dataclients/kubernetes/#chaining-filters-and-predicates", 
            "text": "You can set multiple filters in a chain similar to the  eskip format .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)   Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -  requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Chaining Filters and Predicates"
        }, 
        {
            "location": "/dataclients/route-string/", 
            "text": "Route String\n\n\nRoute string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.\n\n\nServe text\n\n\nServe with \nContent-Type: text/plain; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nServe HTML with CSS\n\n\nServe with \nContent-Type: text/html; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nServe JSON\n\n\nServe with \nContent-Type: application/json; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n% skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#route-string", 
            "text": "Route string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#serve-text", 
            "text": "Serve with  Content-Type: text/plain; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '", 
            "title": "Serve text"
        }, 
        {
            "location": "/dataclients/route-string/#serve-html-with-css", 
            "text": "Serve with  Content-Type: text/html; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '", 
            "title": "Serve HTML with CSS"
        }, 
        {
            "location": "/dataclients/route-string/#serve-json", 
            "text": "Serve with  Content-Type: application/json; charset=utf-8  Example (Open your browser http://localhost:9090/):  % skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '", 
            "title": "Serve JSON"
        }
    ]
}