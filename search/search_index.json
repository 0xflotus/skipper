{
    "docs": [
        {
            "location": "/", 
            "text": "Architecture\n\n\nSkipper is written as library and has also 2 binaries, named \nskipper\n\nand \neskip\n.", 
            "title": "Architecture"
        }, 
        {
            "location": "/#architecture", 
            "text": "Skipper is written as library and has also 2 binaries, named  skipper \nand  eskip .", 
            "title": "Architecture"
        }, 
        {
            "location": "/deployments/", 
            "text": "Deployments and Data-Clients\n\n\nEdge HTTP Routing\n\n\nEdge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.\n\n\nOn the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.\n\n\nIn this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.\n\n\nTo support this scenario we have the \netcd dataclient\n.\n\n\nEtcd\n is a distributed database.\n\n\nTODO: why we use ETCD for this purpose\n\n\nKubernetes Ingress\n\n\nKubernetes Ingress\n is the\ncomponent responsible to route traffic into your\n\nKubernetes\n cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the\n\nkubernetes dataclient\n and is used in\nproduction since end of 2016.\n\n\nSkipper as ingress controller does not need to have any file\nconfiguration or anything external which configures skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.\n\n\nRead more about \nSkipper's kubernetes dataclient\n.\n\n\nInkeeper Routes API\n\n\nSkipper\n can read from an\n\nInkeeper API\n, if you like to\ncreate routes via an API.\nOur \nInkeeper API dataclient\n can be used\nas well. It was used in production in the past. (TODO: do we use it somewhere?)\n\n\nDemos / Talks\n\n\nIn demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe \nroute-string dataclient\n.\n\n\nSimple Routes File\n\n\nThe most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the \nEskip file dataclient\n is about.", 
            "title": "Deployments"
        }, 
        {
            "location": "/deployments/#deployments-and-data-clients", 
            "text": "", 
            "title": "Deployments and Data-Clients"
        }, 
        {
            "location": "/deployments/#edge-http-routing", 
            "text": "Edge HTTP routing is the first hit to your production HTTP\nloadbalancer. Skipper can serve this well and reliably in production since 2016.  On the edge you want to dispatch incoming HTTP requests to your\nbackends, which could be a microservice architecture.  In this deployment mode you might have 100k HTTP routes, which are\nused in production and modified by many parties.  To support this scenario we have the  etcd dataclient .  Etcd  is a distributed database.  TODO: why we use ETCD for this purpose", 
            "title": "Edge HTTP Routing"
        }, 
        {
            "location": "/deployments/#kubernetes-ingress", 
            "text": "Kubernetes Ingress  is the\ncomponent responsible to route traffic into your Kubernetes  cluster.\nAs deployer you can define an ingress object and an ingress controller\nwill make sure incoming traffic gets routed to her backend service as\ndefined. Skipper supports this scenario with the kubernetes dataclient  and is used in\nproduction since end of 2016.  Skipper as ingress controller does not need to have any file\nconfiguration or anything external which configures skipper. Skipper\nautomatically finds Ingress objects and configures routes\nautomatically, without reloading. The only requirement is to target\nall traffic you want to serve with Kubernetes to a loadbalancer pool\nof skippers. This is a clear advantage over other ingress controllers\nlike nginx, haproxy or envoy.  Read more about  Skipper's kubernetes dataclient .", 
            "title": "Kubernetes Ingress"
        }, 
        {
            "location": "/deployments/#inkeeper-routes-api", 
            "text": "Skipper  can read from an Inkeeper API , if you like to\ncreate routes via an API.\nOur  Inkeeper API dataclient  can be used\nas well. It was used in production in the past. (TODO: do we use it somewhere?)", 
            "title": "Inkeeper Routes API"
        }, 
        {
            "location": "/deployments/#demos-talks", 
            "text": "In demos you may want to show arbitrary hello world applications.\nYou can easily describe html or json output on the command line with\nthe  route-string dataclient .", 
            "title": "Demos / Talks"
        }, 
        {
            "location": "/deployments/#simple-routes-file", 
            "text": "The most static deployment that is known from apache, nginx or haproxy\nis write your routes into a file and start your http server.\nThis is what the  Eskip file dataclient  is about.", 
            "title": "Simple Routes File"
        }, 
        {
            "location": "/dataclients/eskip-file/", 
            "text": "Eskip File\n\n\nEskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The \nfile format eskip\n\nshows your route definitions in a clear way:\n\n\n% cat example.eskip\nhello: Path(\"/hello\") -\n \"https://www.example.org\"'\n\n\n\nThe \nskipper project\n has two\nbinaries, one is \nskipper\n, the other is \neskip\n.\n\nEskip\n\ncan be used to validate the syntax of your routes file before\nreloading a production server:\n\n\n% eskip check example.eskip\n\n\n\nTo run skipper serving routes from an \neskip\n file you have to use\n\n-routes-file \nfile\n parameter:\n\n\n% skipper -routes-file example.eskip\n\n\n\nA more complicated example with different routes, matches,\n\npredicates\n and\n\nfilters\n shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:\n\n\n% cat complicated_example.eskip\nhost-header-match:\n         Host(\"^skipper.teapot.org$\")\n         -\n setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -\n \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaidu-path-match:\n        Path(\"/baidu\")\n        -\n setRequestHeader(\"Host\", \"www.baidu.com\")\n        -\n setPath(\"/s\")\n        -\n setQuery(\"wd\", \"godoc skipper\")\n        -\n \"http://www.baidu.com\";\ngoogle-wildcard-match:\n        *\n        -\n setPath(\"/search\")\n        -\n setQuery(\"q\", \"godoc skipper\")\n        -\n \"https://www.google.com\";\nyandex-wildacard-if-cookie:\n        * \n Cookie(\"yandex\", \"true\")\n        -\n setPath(\"/search/\")\n        -\n setQuery(\"text\", \"godoc skipper\")\n        -\n tee(\"http://127.0.0.1:12345/\")\n        -\n \"https://yandex.ru\";\n\n\n\nThe former example shows 4 routes: host-header-match,\nbaidu-path-match, google-wildcard-match and yandex-wildcard-if-cookie.\n\n\n\n\nhost-header-match:\n\n\nused if HTTP host header is exactly: \"skipper.teapot.org\",\n\n\nsets a Basic Authorization header and\n\n\nsends the modified request to https://target-to.auth-with.basic-auth.enterprise.com\n\n\nbaidu-path-match:\n\n\nused in case the request patch matches /baidu\n\n\nit will set the Host header to the proxy request\n\n\nit will set the path from /baidu to /s\n\n\nit will set the querystring to \"ws=godoc skipper\" and\n\n\nsends the modified request to http://baidu.com\n\n\ngoogle-wildcard-match:\n\n\nused as default if no other route matches\n\n\nit will set the path to /search\n\n\nit will set the querystring to \"q=godoc skipper\" and\n\n\nsends the modified request to https://www.google.com\n\n\nyandex-wildcard-if-cookie:\n\n\nused as default if a Cookie named \"yandex\" has the value \"true\"\n\n\nit will set the path to /search/\n\n\nit will set the querystring to \"text=godoc skipper\"\n\n\nit will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix \ntee\n) and drop the response and\n\n\nsends the modified request to https://yandex.ru\n\n\n\n\nMore examples you find in \neskip file format\n\ndescription, in \nfilters\n\nand in \npredicates\n.\n\n\nEskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):\n\n\n% curl localhost:9911/routes\n*\n  -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -\n inlineContent(\"{\\\"foo\\\": 3}\")\n  -\n \nshunt", 
            "title": "Eskip"
        }, 
        {
            "location": "/dataclients/eskip-file/#eskip-file", 
            "text": "Eskip file dataclient can be used to serve static defined routes, read\nfrom an eskip file. The  file format eskip \nshows your route definitions in a clear way:  % cat example.eskip\nhello: Path(\"/hello\") -  \"https://www.example.org\"'  The  skipper project  has two\nbinaries, one is  skipper , the other is  eskip . Eskip \ncan be used to validate the syntax of your routes file before\nreloading a production server:  % eskip check example.eskip  To run skipper serving routes from an  eskip  file you have to use -routes-file  file  parameter:  % skipper -routes-file example.eskip  A more complicated example with different routes, matches, predicates  and filters  shows that\nyou can name your route and use preconditions and create, change, delete\nHTTP headers as you like:  % cat complicated_example.eskip\nhost-header-match:\n         Host(\"^skipper.teapot.org$\")\n         -  setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -  \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaidu-path-match:\n        Path(\"/baidu\")\n        -  setRequestHeader(\"Host\", \"www.baidu.com\")\n        -  setPath(\"/s\")\n        -  setQuery(\"wd\", \"godoc skipper\")\n        -  \"http://www.baidu.com\";\ngoogle-wildcard-match:\n        *\n        -  setPath(\"/search\")\n        -  setQuery(\"q\", \"godoc skipper\")\n        -  \"https://www.google.com\";\nyandex-wildacard-if-cookie:\n        *   Cookie(\"yandex\", \"true\")\n        -  setPath(\"/search/\")\n        -  setQuery(\"text\", \"godoc skipper\")\n        -  tee(\"http://127.0.0.1:12345/\")\n        -  \"https://yandex.ru\";  The former example shows 4 routes: host-header-match,\nbaidu-path-match, google-wildcard-match and yandex-wildcard-if-cookie.   host-header-match:  used if HTTP host header is exactly: \"skipper.teapot.org\",  sets a Basic Authorization header and  sends the modified request to https://target-to.auth-with.basic-auth.enterprise.com  baidu-path-match:  used in case the request patch matches /baidu  it will set the Host header to the proxy request  it will set the path from /baidu to /s  it will set the querystring to \"ws=godoc skipper\" and  sends the modified request to http://baidu.com  google-wildcard-match:  used as default if no other route matches  it will set the path to /search  it will set the querystring to \"q=godoc skipper\" and  sends the modified request to https://www.google.com  yandex-wildcard-if-cookie:  used as default if a Cookie named \"yandex\" has the value \"true\"  it will set the path to /search/  it will set the querystring to \"text=godoc skipper\"  it will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix  tee ) and drop the response and  sends the modified request to https://yandex.ru   More examples you find in  eskip file format \ndescription, in  filters \nand in  predicates .  Eskip file format is also used if you print your current routes in skipper,\nfor example (metrics listener required):  % curl localhost:9911/routes\n*\n  -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -  inlineContent(\"{\\\"foo\\\": 3}\")\n  -   shunt", 
            "title": "Eskip File"
        }, 
        {
            "location": "/dataclients/etcd/", 
            "text": "ETCD\n\n\nTODO", 
            "title": "Etcd"
        }, 
        {
            "location": "/dataclients/etcd/#etcd", 
            "text": "TODO", 
            "title": "ETCD"
        }, 
        {
            "location": "/dataclients/inkeeper-api/", 
            "text": "Inkeeper API\n\n\nTODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/inkeeper-api/#inkeeper-api", 
            "text": "TODO", 
            "title": "Inkeeper API"
        }, 
        {
            "location": "/dataclients/kubernetes/", 
            "text": "Kubernetes\n\n\nSkipper's Kubernetes dataclient can be used, if you want to run skipper as\n\nkubernetes-ingress-controller\n.\nIt will get it's route information from provisioned\n\nIngress Objects\n.\nDetailed information you find in our \ngodoc for dataclient kubernetes\n.\n\n\nKubernetes Ingress Controller deployment\n\n\nHow to \ninstall skipper ingress-controller\n for cluster operators.\n\n\nKubernetes Ingress Usage\n\n\nFind out more \nhow to use skipper ingress features\n for deployers.\n\n\nWhy to choose Skipper?\n\n\nKubernetes is a fast changing environment and traditional http routers\nare not made for frequently changing routing tables. Skipper is a http\nproxy made to apply updates very often. Skipper is used in\nproduction with more than 200.000 routing table entries.\nSkipper has Filters to change http data and Predicates to change the\nmatching rules, both can combined and chained. You can set these in\ningress.yaml files to build resiliency patterns like ratelimit or\ncircuitbreaker. You can also use them to build more highlevel\ndeployment patterns, for example feature toggles, shadow traffic or\nblue-green deployments.\n\n\nSkipper's main features:\n\n\n\n\nFilters - create, update, delete all kind of HTTP data\n\n\ncollection of base http manipulations\n: for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling\n\n\ncookie handling\n\n\ncircuitbreakers\n: consecutiveBreaker or rateBreaker\n\n\nratelimit\n: based on client or backend data\n\n\nShadow traffic: \ntee()\n\n\nPredicates - advanced matching capability\n\n\nURL Path match: \nPath(\"/foo\")\n\n\nHost header match: \nHost(\"^www.example.org$\")\n\n\nQuerystring\n: \nQueryParam(\"featureX\")\n\n\nCookie based\n: \nCookie(\"alpha\", /^enabled$/)\n\n\nsource whitelist\n: \nSource(\"1.2.3.4/24\")\n\n\ntime based interval\n\n\ntraffic by percentage\n supports also sticky sessions\n\n\nKubernetes integration\n\n\nAll Filters and Predicates can be used with 2 annotations\n\n\nPredicates: \nzalando.org/skipper-predicate\n\n\nFilters: \nzalando.org/skipper-filter\n\n\n\n\n\n\nmetrics\n\n\naccess logs\n\n\nBlue-Green deployments, with another Ingress annotation \nzalando.org/backend-weights", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes", 
            "text": "Skipper's Kubernetes dataclient can be used, if you want to run skipper as kubernetes-ingress-controller .\nIt will get it's route information from provisioned Ingress Objects .\nDetailed information you find in our  godoc for dataclient kubernetes .", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes-ingress-controller-deployment", 
            "text": "How to  install skipper ingress-controller  for cluster operators.", 
            "title": "Kubernetes Ingress Controller deployment"
        }, 
        {
            "location": "/dataclients/kubernetes/#kubernetes-ingress-usage", 
            "text": "Find out more  how to use skipper ingress features  for deployers.", 
            "title": "Kubernetes Ingress Usage"
        }, 
        {
            "location": "/dataclients/kubernetes/#why-to-choose-skipper", 
            "text": "Kubernetes is a fast changing environment and traditional http routers\nare not made for frequently changing routing tables. Skipper is a http\nproxy made to apply updates very often. Skipper is used in\nproduction with more than 200.000 routing table entries.\nSkipper has Filters to change http data and Predicates to change the\nmatching rules, both can combined and chained. You can set these in\ningress.yaml files to build resiliency patterns like ratelimit or\ncircuitbreaker. You can also use them to build more highlevel\ndeployment patterns, for example feature toggles, shadow traffic or\nblue-green deployments.  Skipper's main features:   Filters - create, update, delete all kind of HTTP data  collection of base http manipulations : for example manipulating Path, Querystring, ResponseHeader, RequestHeader and redirect handling  cookie handling  circuitbreakers : consecutiveBreaker or rateBreaker  ratelimit : based on client or backend data  Shadow traffic:  tee()  Predicates - advanced matching capability  URL Path match:  Path(\"/foo\")  Host header match:  Host(\"^www.example.org$\")  Querystring :  QueryParam(\"featureX\")  Cookie based :  Cookie(\"alpha\", /^enabled$/)  source whitelist :  Source(\"1.2.3.4/24\")  time based interval  traffic by percentage  supports also sticky sessions  Kubernetes integration  All Filters and Predicates can be used with 2 annotations  Predicates:  zalando.org/skipper-predicate  Filters:  zalando.org/skipper-filter    metrics  access logs  Blue-Green deployments, with another Ingress annotation  zalando.org/backend-weights", 
            "title": "Why to choose Skipper?"
        }, 
        {
            "location": "/dataclients/route-string/", 
            "text": "Route String\n\n\nRoute string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.\n\n\nServe text\n\n\nServe with \nContent-Type: text/plain; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"Hello, world!\") -\n \nshunt\n'\n\n\n\nServe HTML with CSS\n\n\nServe with \nContent-Type: text/html; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n $ skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n inlineContent(\"\nhtml\nbody style=\\\"background-color: orange;\\\"\n/body\n/html\n\") -\n \nshunt\n'\n\n\n\nServe JSON\n\n\nServe with \nContent-Type: application/json; charset=utf-8\n\n\nExample (Open your browser http://localhost:9090/):\n\n\n% skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'\n\n\n\nDocker Example (Open your browser http://localhost:9090/):\n\n\n $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -\n setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -\n inlineContent(\"{\\\"foo\\\": 3}\") -\n \nshunt\n'\n\n\n\nProxy to a given URL\n\n\nIf you just have to build a workaround and you do not want to use\nsocat to do a tcp proxy, but proxy http, you can do:\n\n\n% skipper -inline-routes '* -\n \"https://my-new-backend.example.org/\"'", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#route-string", 
            "text": "Route string dataclient can be used to create simple demo\napplications, for example if you want to show traffic switching or\nratelimiting or just need to serve some json in your demo.", 
            "title": "Route String"
        }, 
        {
            "location": "/dataclients/route-string/#serve-text", 
            "text": "Serve with  Content-Type: text/plain; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\"Hello, world!\") -   shunt '", 
            "title": "Serve text"
        }, 
        {
            "location": "/dataclients/route-string/#serve-html-with-css", 
            "text": "Serve with  Content-Type: text/html; charset=utf-8  Example (Open your browser http://localhost:9090/):   $ skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  inlineContent(\" html body style=\\\"background-color: orange;\\\" /body /html \") -   shunt '", 
            "title": "Serve HTML with CSS"
        }, 
        {
            "location": "/dataclients/route-string/#serve-json", 
            "text": "Serve with  Content-Type: application/json; charset=utf-8  Example (Open your browser http://localhost:9090/):  % skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '  Docker Example (Open your browser http://localhost:9090/):   $ docker run -p 9090:9090 -it registry.opensource.zalan.do/pathfinder/skipper:latest skipper -inline-routes '* -  setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\") -  inlineContent(\"{\\\"foo\\\": 3}\") -   shunt '", 
            "title": "Serve JSON"
        }, 
        {
            "location": "/dataclients/route-string/#proxy-to-a-given-url", 
            "text": "If you just have to build a workaround and you do not want to use\nsocat to do a tcp proxy, but proxy http, you can do:  % skipper -inline-routes '* -  \"https://my-new-backend.example.org/\"'", 
            "title": "Proxy to a given URL"
        }, 
        {
            "location": "/kubernetes/ingress-controller/", 
            "text": "Skipper Ingress Controller\n\n\nThis documentation is meant for for cluster operators and describes\nhow to install skipper as Ingress-Controller into your Kubernetes\nCluster.\n\n\nWhy you should use skipper as ingress controller?\n\n\nBaremetal loadbalancer perform really well, but the configuration is\nnot updated frequently and most of these installations are not meant\nto rapidly change. With introducing kubernetes this will change and\nthere is a need of rapid changing http routers. Skipper is designed\nfor rapidly changing it's routing tree.\n\n\nCloud loadbalancers are fine to scale and to change, but does not\nprovide many features. Skipper has advanced resiliency and deployment\nfeatures, that you can use to enhance your environment. For example\nratelimits, circuitbreakers, blue-green deployments, shadow traffic\nand \nmore\n.\n\n\nWhat is an Ingress-Controller\n\n\nIngress-controllers are serving http requests into a kubernetes\ncluster. Most of the time traffic will pass ingress got to a\nkubernetes service IP which will forward the packets to kubernetes PODs\nselected by the kubernetes service.\nFor having a successful ingress, you need to have a DNS name pointing\nto some stable IP addresses that act as a loadbalancer. In AWS, this\ncould be an ALB with DNS pointing to the ALB. The ALB can then point\nto an ingress-controller running on an EC2 node and uses Kubernetes\n\nhostnetwork\n port specification in the POD spec.\nIn datacenter, baremetal environments, you probably have a hardware\nloadbalancer or some haproxy or nginx setup, that serves most of your\nproduction traffic and DNS points to these endpoints.\n\n\nSkipper as ingress-controller in clouds, can be deployed behind the\ncloud loadbalancer. You would point your DNS entries to the cloud\nloadbalancer, for example automated using\n\nexternal-dns\n.\n\n\nTODO: add pictures here\n\n\nRequirements\n\n\nIn general for one endpoint you need, a DNS A/AAAA record pointing to\none or more loadbalancer IPs. Skipper is best used behind this\nloadbalancer to route and manipulate HTTP data.\n\n\nTODO\n\n\n3 Minutes Skipper in Kubernetes introduction\n\n\nYou should have a base understanding of \nKubernetes\n and\n\nIngress\n.\n\n\nPrerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.\n\n\nWe start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.\n\n\n% cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.9.115\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.9.115\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.115\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n        resources:\n          limits:\n            cpu: 200m\n            memory: 200Mi\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5\n\n\n\nWe now deploy a simple demo application serving html:\n\n\n% cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.117\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -\n inlineContent(\\\"\nbody style='color: white; background-color: green;'\nh1\nHello!\n/h1\n\\\") -\n \nshunt\n\"\n        ports:\n        - containerPort: 9090\n\n\n\nWe deploy a service type ClusterIP that we will select from ingress:\n\n\n% cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: sszuecs-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: sszuecs-demo\n\n\n\nTo deploy both, you have to run:\n\n\n% kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml\n\n\n\nNow we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:\n\n\n% cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo.\nmydomain.org\n\n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80\n\n\n\nTo deploy this ingress, you have to run:\n\n\n% kubectl create -f demo-ing.yaml\n\n\n\nSkipper will configure itself for the given ingress, such that you can test doing:\n\n\n% curl -v -H\"Host: skipper-demo.\nmydomain.org\n\" http://\nnodeip\n:9999/\n\n\n\nThe next question you may ask is: how to expose this to your customers?\n\n\nThe answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS \n*.\nmydomain.org\n\nto your frontend loadbalancer IP that directs all traffic from \n*.\nmydomain.org\n\nto all Kubernetes worker nodes on TCP port 9999.\n\n\nA more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example\n\nkube-aws-ingress-controller\n,\nand your DNS, \nexternal-dns\n\nautomatically.", 
            "title": "Ingress Controller Deployment"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#skipper-ingress-controller", 
            "text": "This documentation is meant for for cluster operators and describes\nhow to install skipper as Ingress-Controller into your Kubernetes\nCluster.", 
            "title": "Skipper Ingress Controller"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#why-you-should-use-skipper-as-ingress-controller", 
            "text": "Baremetal loadbalancer perform really well, but the configuration is\nnot updated frequently and most of these installations are not meant\nto rapidly change. With introducing kubernetes this will change and\nthere is a need of rapid changing http routers. Skipper is designed\nfor rapidly changing it's routing tree.  Cloud loadbalancers are fine to scale and to change, but does not\nprovide many features. Skipper has advanced resiliency and deployment\nfeatures, that you can use to enhance your environment. For example\nratelimits, circuitbreakers, blue-green deployments, shadow traffic\nand  more .", 
            "title": "Why you should use skipper as ingress controller?"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#what-is-an-ingress-controller", 
            "text": "Ingress-controllers are serving http requests into a kubernetes\ncluster. Most of the time traffic will pass ingress got to a\nkubernetes service IP which will forward the packets to kubernetes PODs\nselected by the kubernetes service.\nFor having a successful ingress, you need to have a DNS name pointing\nto some stable IP addresses that act as a loadbalancer. In AWS, this\ncould be an ALB with DNS pointing to the ALB. The ALB can then point\nto an ingress-controller running on an EC2 node and uses Kubernetes hostnetwork  port specification in the POD spec.\nIn datacenter, baremetal environments, you probably have a hardware\nloadbalancer or some haproxy or nginx setup, that serves most of your\nproduction traffic and DNS points to these endpoints.  Skipper as ingress-controller in clouds, can be deployed behind the\ncloud loadbalancer. You would point your DNS entries to the cloud\nloadbalancer, for example automated using external-dns .  TODO: add pictures here", 
            "title": "What is an Ingress-Controller"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#requirements", 
            "text": "In general for one endpoint you need, a DNS A/AAAA record pointing to\none or more loadbalancer IPs. Skipper is best used behind this\nloadbalancer to route and manipulate HTTP data.  TODO", 
            "title": "Requirements"
        }, 
        {
            "location": "/kubernetes/ingress-controller/#3-minutes-skipper-in-kubernetes-introduction", 
            "text": "You should have a base understanding of  Kubernetes  and Ingress .  Prerequisites: First you have to install skipper-ingress as for\nexample daemonset, create a deployment and a service.  We start to deploy skipper-ingress as a daemonset, use hostNetwork and\nexpose the TCP port 9999 on each Kubernetes worker node for incoming ingress\ntraffic.  % cat skipper-ingress-ds.yaml\napiVersion: extensions/v1beta1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.9.115\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.9.115\n        component: ingress\n      annotations:\n        scheduler.alpha.kubernetes.io/critical-pod: ''\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: master\n                operator: DoesNotExist\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.115\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-address=:9999\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n        resources:\n          limits:\n            cpu: 200m\n            memory: 200Mi\n          requests:\n            cpu: 25m\n            memory: 25Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5  We now deploy a simple demo application serving html:  % cat demo-deployment.yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/pathfinder/skipper:v0.9.117\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -  inlineContent(\\\" body style='color: white; background-color: green;' h1 Hello! /h1 \\\") -   shunt \"\n        ports:\n        - containerPort: 9090  We deploy a service type ClusterIP that we will select from ingress:  % cat demo-svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: sszuecs-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: sszuecs-demo  To deploy both, you have to run:  % kubectl create -f demo-deployment.yaml\n% kubectl create -f demo-svc.yaml  Now we have a skipper-ingress running as daemonset exposing the TCP\nport 9999 on each worker node, a backend application running with 2\nreplicas that serves some html on TCP port 9090, and we expose a\ncluster service on TCP port 80. Besides skipper-ingress, deployment\nand service can not be reached from outside the cluster. Now we expose\nthe application with Ingress to the external network:  % cat demo-ing.yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo. mydomain.org \n    http:\n      paths:\n      - backend:\n          serviceName: skipper-demo\n          servicePort: 80  To deploy this ingress, you have to run:  % kubectl create -f demo-ing.yaml  Skipper will configure itself for the given ingress, such that you can test doing:  % curl -v -H\"Host: skipper-demo. mydomain.org \" http:// nodeip :9999/  The next question you may ask is: how to expose this to your customers?  The answer depends on your setup and complexity requirements. In the\nsimplest case you could add one A record in your DNS  *. mydomain.org \nto your frontend loadbalancer IP that directs all traffic from  *. mydomain.org \nto all Kubernetes worker nodes on TCP port 9999.  A more complex setup we use in production and can be done with\nsomething that configures your frontend loadbalancer, for example kube-aws-ingress-controller ,\nand your DNS,  external-dns \nautomatically.", 
            "title": "3 Minutes Skipper in Kubernetes introduction"
        }, 
        {
            "location": "/kubernetes/ingress-usage/", 
            "text": "Skipper Ingress Usage\n\n\nThis documentation is meant for people deploying to Kubernetes\nClusters and describes to use Ingress and low level and high level\nfeatures Skipper provides\n\n\nSkipper Ingress Annotations\n\n\n\n\n\n\n\n\nAnnotation\n\n\nexample data\n\n\nusage\n\n\n\n\n\n\n\n\n\n\nzalando.org/backend-weights\n\n\n{\"my-app-1\": 80, \"my-app-2\": 20}\n\n\nblue-green deployments\n\n\n\n\n\n\nzalando.org/skipper-filter\n\n\nconsecutiveBreaker(15)\n\n\narbitrary filters\n\n\n\n\n\n\nzalando.org/skipper-predicate\n\n\nQueryParam(\"version\", \"^alpha$\")\n\n\narbitrary predicates\n\n\n\n\n\n\nzalando.org/ratelimit\n\n\nratelimit(50, \"1m\")\n\n\ndeprecated, use zalando.org/skipper-filter instead\n\n\n\n\n\n\n\n\nSupported Service types\n\n\nIngress backend definitions are services, which have different\n\nservice types\n.\n\n\n\n\n\n\n\n\nService type\n\n\nsupported\n\n\nworkaround\n\n\n\n\n\n\n\n\n\n\nClusterIP\n\n\nyes\n\n\n---\n\n\n\n\n\n\nNodePort\n\n\nyes\n\n\n---\n\n\n\n\n\n\nExternalName\n\n\nno, \nrelated issue\n\n\nuse deployment with routestring\n\n\n\n\n\n\nLoadBalancer\n\n\nno\n\n\nit should not, because kubernetes cloud-controller-manager will maintain it\n\n\n\n\n\n\n\n\nBasics\n\n\nHTTP Host header routing\n\n\nHTTP host header is defined within the rules \nhost\n section and this\nroute will match by http \nHost: app-default.example.org\n and route to\nendpoints selected by the Kubernetes service \napp-svc\n on port \n80\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nTo have 2 routes with different \nHost\n headers serving the same\nbackends, you have to specify 2 entries in the rules section, as\nkubernetes defined the ingress spec. This is often used in cases of\nmigrations from one domain to another one or migrations to or from\nbare metal datacenters to cloud providers or inter cloud or intra\ncloud providers migrations. Examples are AWS account migration, AWS to\nGCP migration, GCP to bare metal migration or bare metal to Alibaba\nCloud migration.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n  - host: foo.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nFilters and Predicates\n\n\n\n\nFilters\n can manipulate http data, which is not possible in the ingress spec.\n\n\nPredicates\n change the route matching, beyond normal ingress definitions\n\n\n\n\nThis example shows how to add predicates and filters:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: predicate1 \n predicate2 \n .. \n predicateN\n    zalando.org/skipper-filter: filter1 -\n filter2 -\n .. -\n filterN\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nFilters - Basic HTTP manipulations\n\n\nHTTP manipulations are done by using skipper filters. Changes can be\ndone in the request path, meaning request to your backend or in the\nresponse path to the client, which made the request.\n\n\nThe following examples can be used within \nzalando.org/skipper-filter\n\nannotation.\n\n\nAdd a request Header\n\n\nAdd a HTTP header in the request path to your backend.\n\n\nsetRequestHeader(\"X-Foo\", \"bar\")\n\n\n\nAdd a response Header\n\n\nAdd a HTTP header in the response path of your clients.\n\n\nsetResponseHeader(\"X-Foo\", \"bar\")\n\n\n\nSet the Path\n\n\nChange the path in the request path to your backend to \n/newPath/\n.\n\n\nsetPath(\"/newPath/\")\n\n\n\nSet the Querystring\n\n\nSet the Querystring in the request path to your backend to \n?text=godoc%20skipper\n.\n\n\nsetQuery(\"text\", \"godoc skipper\")\n\n\n\nRedirect\n\n\nCreate a redirect with HTTP code 301 to https://foo.example.org/.\n\n\nredirectTo(301, \"https://foo.example.org/\")\n\n\n\nCookies\n\n\nSet a Cookie in the request path to your backend.\n\n\nrequestCookie(\"test-session\", \"abc\")\n\n\n\nSet a Cookie in the response path of your clients.\n\n\nresponseCookie(\"test-session\", \"abc\", 31536000)\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\n\n// response cookie without HttpOnly:\njsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")\n\n\n\nAuthorization\n\n\nOur \nfilter auth godoc\n\nshows how to use filters for authorization.\n\n\nBasic Auth\n\n\n% htpasswd -nbm myName myPassword\n\nbasicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")\n\n\n\nBearer Token (OAuth/JWT)\n\n\nTBD\n\n\nDiagnosis - Throttling Bandwidth - Latency\n\n\nFor diagnosis purpose there are filters that enable you to throttle\nthe bandwidth or add latency. For the full list of filters see our\n\ndiag filter godoc page\n.\n\n\nbandwidth(30) // incoming in kb/s\nbackendBandwidth(30) // outgoing in kb/s\nbackendLatency(120) // in ms\n\n\n\nFlow Id to trace request flows\n\n\nTo trace request flows skipper can generate a unique Flow Id for every\nHTTP request that it receives. You can then find the trace of the\nrequest in all your access logs.  Skipper sets the X-Flow-Id header to\na unique value. Read more about this in our\n\nflowid filter godoc\n.\n\n\n flowId(\"reuse\")\n\n\n\nFilters - reliability features\n\n\nFilters can modify http requests and responses. There are plenty of\nthings you can do with them.\n\n\nCircuitbreaker\n\n\nConsecutive Breaker\n\n\nThe \nconsecutiveBreaker\n\nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments\n\ndocumented\n:\n\n\nconsecutiveBreaker(15)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRate Breaker\n\n\nThe \nrateBreaker\n\nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments\n\ndocumented\n.\n\n\nrateBreaker(30, 300)\n\n\n\nThe ingress spec would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nRatelimits\n\n\nThere are two kind of ratelimits:\n\n\n\n\nClient side ratelimits are used to slow down login enumeration\nattacks, that targets your login pages. This is a security protection\nfor DDOS or login attacks.\n\n\nService or backend side ratelimits are used to protect your\nservices due too much traffic. This can be used in an emergency\nsituation to make sure you calm down ingress traffic or in general if\nyou know how much calls per duration your backend is able to handle.\n\n\n\n\nRatelimits are enforced per route.\n\n\nMore details you will find in \nratelimit package\n\nand \nkubernetes dataclient\n documentation.\n\n\nClient Ratelimits\n\n\nThe example shows 20 calls per hour per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nIf you need to rate limit service to service communication and\nyou use Authorization headers to protect your backend from your\nclients, then you can pass a 3 parameter to group clients by \"Authorization\nHeader\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nService Ratelimits\n\n\nThe example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nShadow Traffic\n\n\nIf you want to test a new replacement of a production service with\nproduction load, you can copy incoming requests to your new endpoint\nand ignore the responses from your new backend. This can be done by\nthe \ntee() and teenf() filters\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: teenf(\"https://app-new.example.org\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nPredicates\n\n\nPredicates\n\nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.\n\n\nYou can use all kinds of \npredicates\n\nwith \nfilters\n together.\n\n\nFeature Toggle\n\n\nFeature toggles are often implemented as query string to select a new\nfeature. Normally you would have to implement this in your\napplication, but Skipper can help you with that and you can select\nroutes with an ingress definition.\n\n\nYou create 2 ingresses that matches the same route, here host header\nmatch to \napp-default.example.org\n and one ingress has a defined query\nparameter to select the route to the alpha version deployment. If the\nquery string in the URL has \nversion=alpha\n set, for example\n\nhttps://app-default.example.org/mypath?version=alpha\n, the service\n\nalpha-svc\n will get the traffic, if not \nprod-svc\n.\n\n\nalpha-svc:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80\n\n\n\nprod-svc:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: prod-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: prod-svc\n          servicePort: 80\n\n\n\nIP Whitelisting\n\n\nThis ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n\n\n\nA/B test\n\n\nImplementing A/B testing is heavy. Skipper can help you to do\nthat. You need to have a traffic split somewhere and have your\ncustomers sticky to either A or B flavor of your application. Most\nlikely people would implement using cookies. Skipper can set a\n\ncookie with responseCookie()\n\nin a response to the client and the\n\ncookie predicate\n\ncan be used to match the route based on the cookie. Like this you can\nhave sticky sessions to either A or B for your clients.  This example\nshows to have 10% traffic using A and the rest using B.\n\n\n10% choice of setting the Cookie \"flavor\" to \"A\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Traffic(.1)\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80\n\n\n\nRest is setting Cookie \"flavor\" to \"B\":\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80\n\n\n\nTo be sticky, you have to create 2 ingress with predicate to match\nroutes with the cookie we set before. For \"A\" this would be:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80\n\n\n\nFor \"B\" this would be:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80\n\n\n\nBlue-Green deployments\n\n\nTo do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification. \nzalando.org/backend-weights\n\nis a hash map, which key relates to the \nserviceName\n of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.\n\n\nIn the following example \nmy-app-1\n service will get \n80%\n of the traffic\nand \nmy-app-2\n will get \n20%\n of the traffic:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /\n\n\n\nChaining Filters and Predicates\n\n\nYou can set multiple filters in a chain similar to the \neskip format\n.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) \n Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -\n requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Ingress Usage"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#skipper-ingress-usage", 
            "text": "This documentation is meant for people deploying to Kubernetes\nClusters and describes to use Ingress and low level and high level\nfeatures Skipper provides", 
            "title": "Skipper Ingress Usage"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#skipper-ingress-annotations", 
            "text": "Annotation  example data  usage      zalando.org/backend-weights  {\"my-app-1\": 80, \"my-app-2\": 20}  blue-green deployments    zalando.org/skipper-filter  consecutiveBreaker(15)  arbitrary filters    zalando.org/skipper-predicate  QueryParam(\"version\", \"^alpha$\")  arbitrary predicates    zalando.org/ratelimit  ratelimit(50, \"1m\")  deprecated, use zalando.org/skipper-filter instead", 
            "title": "Skipper Ingress Annotations"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#supported-service-types", 
            "text": "Ingress backend definitions are services, which have different service types .     Service type  supported  workaround      ClusterIP  yes  ---    NodePort  yes  ---    ExternalName  no,  related issue  use deployment with routestring    LoadBalancer  no  it should not, because kubernetes cloud-controller-manager will maintain it", 
            "title": "Supported Service types"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#basics", 
            "text": "", 
            "title": "Basics"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#http-host-header-routing", 
            "text": "HTTP host header is defined within the rules  host  section and this\nroute will match by http  Host: app-default.example.org  and route to\nendpoints selected by the Kubernetes service  app-svc  on port  80 .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80  To have 2 routes with different  Host  headers serving the same\nbackends, you have to specify 2 entries in the rules section, as\nkubernetes defined the ingress spec. This is often used in cases of\nmigrations from one domain to another one or migrations to or from\nbare metal datacenters to cloud providers or inter cloud or intra\ncloud providers migrations. Examples are AWS account migration, AWS to\nGCP migration, GCP to bare metal migration or bare metal to Alibaba\nCloud migration.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80\n  - host: foo.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "HTTP Host header routing"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#filters-and-predicates", 
            "text": "Filters  can manipulate http data, which is not possible in the ingress spec.  Predicates  change the route matching, beyond normal ingress definitions   This example shows how to add predicates and filters:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: predicate1   predicate2   ..   predicateN\n    zalando.org/skipper-filter: filter1 -  filter2 -  .. -  filterN\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Filters and Predicates"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#filters-basic-http-manipulations", 
            "text": "HTTP manipulations are done by using skipper filters. Changes can be\ndone in the request path, meaning request to your backend or in the\nresponse path to the client, which made the request.  The following examples can be used within  zalando.org/skipper-filter \nannotation.", 
            "title": "Filters - Basic HTTP manipulations"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#add-a-request-header", 
            "text": "Add a HTTP header in the request path to your backend.  setRequestHeader(\"X-Foo\", \"bar\")", 
            "title": "Add a request Header"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#add-a-response-header", 
            "text": "Add a HTTP header in the response path of your clients.  setResponseHeader(\"X-Foo\", \"bar\")", 
            "title": "Add a response Header"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#set-the-path", 
            "text": "Change the path in the request path to your backend to  /newPath/ .  setPath(\"/newPath/\")", 
            "title": "Set the Path"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#set-the-querystring", 
            "text": "Set the Querystring in the request path to your backend to  ?text=godoc%20skipper .  setQuery(\"text\", \"godoc skipper\")", 
            "title": "Set the Querystring"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#redirect", 
            "text": "Create a redirect with HTTP code 301 to https://foo.example.org/.  redirectTo(301, \"https://foo.example.org/\")", 
            "title": "Redirect"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#cookies", 
            "text": "Set a Cookie in the request path to your backend.  requestCookie(\"test-session\", \"abc\")  Set a Cookie in the response path of your clients.  responseCookie(\"test-session\", \"abc\", 31536000)\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\n\n// response cookie without HttpOnly:\njsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")", 
            "title": "Cookies"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#authorization", 
            "text": "Our  filter auth godoc \nshows how to use filters for authorization.", 
            "title": "Authorization"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#basic-auth", 
            "text": "% htpasswd -nbm myName myPassword\n\nbasicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")", 
            "title": "Basic Auth"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#bearer-token-oauthjwt", 
            "text": "TBD", 
            "title": "Bearer Token (OAuth/JWT)"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#diagnosis-throttling-bandwidth-latency", 
            "text": "For diagnosis purpose there are filters that enable you to throttle\nthe bandwidth or add latency. For the full list of filters see our diag filter godoc page .  bandwidth(30) // incoming in kb/s\nbackendBandwidth(30) // outgoing in kb/s\nbackendLatency(120) // in ms", 
            "title": "Diagnosis - Throttling Bandwidth - Latency"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#flow-id-to-trace-request-flows", 
            "text": "To trace request flows skipper can generate a unique Flow Id for every\nHTTP request that it receives. You can then find the trace of the\nrequest in all your access logs.  Skipper sets the X-Flow-Id header to\na unique value. Read more about this in our flowid filter godoc .   flowId(\"reuse\")", 
            "title": "Flow Id to trace request flows"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#filters-reliability-features", 
            "text": "Filters can modify http requests and responses. There are plenty of\nthings you can do with them.", 
            "title": "Filters - reliability features"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#circuitbreaker", 
            "text": "", 
            "title": "Circuitbreaker"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#consecutive-breaker", 
            "text": "The  consecutiveBreaker \nfilter is a breaker for the ingress route that open if the backend failures\nfor the route reach a value of N (in this example N=15), where N is a\nmandatory argument of the filter and there are some more optional arguments documented :  consecutiveBreaker(15)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Consecutive Breaker"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#rate-breaker", 
            "text": "The  rateBreaker \nfilter is a breaker for the ingress route that open if the backend\nfailures for the route reach a value of N within a window of the last\nM requests, where N (in this example 30) and M (in this example 300)\nare mandatory arguments of the filter and there are some more optional arguments documented .  rateBreaker(30, 300)  The ingress spec would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Rate Breaker"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#ratelimits", 
            "text": "There are two kind of ratelimits:   Client side ratelimits are used to slow down login enumeration\nattacks, that targets your login pages. This is a security protection\nfor DDOS or login attacks.  Service or backend side ratelimits are used to protect your\nservices due too much traffic. This can be used in an emergency\nsituation to make sure you calm down ingress traffic or in general if\nyou know how much calls per duration your backend is able to handle.   Ratelimits are enforced per route.  More details you will find in  ratelimit package \nand  kubernetes dataclient  documentation.", 
            "title": "Ratelimits"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#client-ratelimits", 
            "text": "The example shows 20 calls per hour per client, based on\nX-Forwarded-For header or IP incase there is no X-Forwarded-For header\nset, are allowed to each skipper instance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80  If you need to rate limit service to service communication and\nyou use Authorization headers to protect your backend from your\nclients, then you can pass a 3 parameter to group clients by \"Authorization\nHeader\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: localRatelimit(20, \"1h\", \"auth\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Client Ratelimits"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#service-ratelimits", 
            "text": "The example shows 50 calls per minute are allowed to each skipper\ninstance for the given ingress.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Service Ratelimits"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#shadow-traffic", 
            "text": "If you want to test a new replacement of a production service with\nproduction load, you can copy incoming requests to your new endpoint\nand ignore the responses from your new backend. This can be done by\nthe  tee() and teenf() filters .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: teenf(\"https://app-new.example.org\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Shadow Traffic"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#predicates", 
            "text": "Predicates \nare influencing the route matching, which you might want to carefully\ntest before using it in production. This enables you to do feature\ntoggles or time based enabling endpoints.  You can use all kinds of  predicates \nwith  filters  together.", 
            "title": "Predicates"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#feature-toggle", 
            "text": "Feature toggles are often implemented as query string to select a new\nfeature. Normally you would have to implement this in your\napplication, but Skipper can help you with that and you can select\nroutes with an ingress definition.  You create 2 ingresses that matches the same route, here host header\nmatch to  app-default.example.org  and one ingress has a defined query\nparameter to select the route to the alpha version deployment. If the\nquery string in the URL has  version=alpha  set, for example https://app-default.example.org/mypath?version=alpha , the service alpha-svc  will get the traffic, if not  prod-svc .  alpha-svc:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: alpha-svc\n          servicePort: 80  prod-svc:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: prod-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: prod-svc\n          servicePort: 80", 
            "title": "Feature Toggle"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#ip-whitelisting", 
            "text": "This ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "IP Whitelisting"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#ab-test", 
            "text": "Implementing A/B testing is heavy. Skipper can help you to do\nthat. You need to have a traffic split somewhere and have your\ncustomers sticky to either A or B flavor of your application. Most\nlikely people would implement using cookies. Skipper can set a cookie with responseCookie() \nin a response to the client and the cookie predicate \ncan be used to match the route based on the cookie. Like this you can\nhave sticky sessions to either A or B for your clients.  This example\nshows to have 10% traffic using A and the rest using B.  10% choice of setting the Cookie \"flavor\" to \"A\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Traffic(.1)\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"A\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80  Rest is setting Cookie \"flavor\" to \"B\":  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80  To be sticky, you have to create 2 ingress with predicate to match\nroutes with the cookie we set before. For \"A\" this would be:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: a-app-svc\n          servicePort: 80  For \"B\" this would be:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: b-app-svc\n          servicePort: 80", 
            "title": "A/B test"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#blue-green-deployments", 
            "text": "To do blue-green deployments you have to have control over traffic\nswitching. Skipper gives you the opportunity to set weights to backend\nservices in your ingress specification.  zalando.org/backend-weights \nis a hash map, which key relates to the  serviceName  of the backend\nand the value is the weight of traffic you want to send to the\nparticular backend. It works for more than 2 backends, but for\nsimplicity this example shows 2 backends, which should be the default\ncase for supporting blue-green deployments.  In the following example  my-app-1  service will get  80%  of the traffic\nand  my-app-2  will get  20%  of the traffic:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: my-app-1\n          servicePort: http\n        path: /\n      - backend:\n          serviceName: my-app-2\n          servicePort: http\n        path: /", 
            "title": "Blue-Green deployments"
        }, 
        {
            "location": "/kubernetes/ingress-usage/#chaining-filters-and-predicates", 
            "text": "You can set multiple filters in a chain similar to the  eskip format .  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)   Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n    zalando.org/skipper-filter: localRatelimit(50, \"10m\") -  requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          serviceName: app-svc\n          servicePort: 80", 
            "title": "Chaining Filters and Predicates"
        }, 
        {
            "location": "/scripts/", 
            "text": "Lua filter scripts\n\n\nLUA\n scripts can be used as filters in skipper. The\ncurrent implementation supports \nLua 5.1\n.\n\n\nRoute filters\n\n\nThe lua scripts can be added to a route description with the lua() filter,\nthe first parameter for the filter is the script. This can be either a file\nname (ending with \n.lua\n) or inline code, e.g. as\n\n file \nlua(\"/path/to/file.lua\")\n - if a file path is not absolute, the path\n is relative to skipper's working directory.\n\n inline \nlua(\"function request(c, p); print(c.request.url); end\")\n\n\nAny other additional parameters for the filter must be \nkey=value\n strings.\nThese will be passed as table to the called functions as second parameter.\n\nNOTE\n: Any parameter starting with \"lua-\" should not be used to pass\nvalues for the script - those will be used for configuring the filter.\n\n\nScript requirements\n\n\nA filter script needs at least one global function: \nrequest\n or \nresponse\n.\nIf present, they are called with a skipper filter context and the params passed\nin the route as table like\n\n\n-- route looks like\n--\n-- any: * -\n lua(\n./test.lua\n, \nmyparam=foo\n, \nother=bar\n) -\n \nshunt\n\n--\nfunction request(ctx, params)\n    print(ctx.request.method .. \n \n .. ctx.request.url .. \n -\n \n .. params.myparam)\nend\n\n\n\n\nAvailable lua modules\n\n\nBesides the \nstandard modules\n - except\nfor \ndebug\n - the following modules have been preloaded and can be used with e.g.\n\nlocal http = require(\"http\")\n, see also the examples below\n\n \nhttp\n \ngluahttp\n - TODO: configurable\n with something different than \nhttp.Client{}\n\n\n \nurl\n  \ngluaurl\n\n\n \njson\n \ngopher-json\n\n\n \nbase64\n \nlua base64\n\n\nFor differences between the standard modules and the gopher-lua implementation\ncheck the \ngopher-lua documentation\n.\n\n\nAny other module can be loaded in non-byte code form from the lua path (by default\nfor \nrequire(\"mod\")\n this is \n./mod.lua\n, \n/usr/local/share/lua/5.1/mod.lua\n and\n\n/usr/local/share/lua/5.1/mod/init.lua\n).\n\n\nLua states\n\n\nThere is no guarantee that the \nrequest()\n and \nresponse()\n functions of a\nlua script run in the same lua state during one request. Setting a variable\nin the request and accessing it in the response will most likely fail and lead\nto hard debuggable errors. Use the \nctx.state_bag\n to propagate values from\n\nrequest\n to \nresponse\n - and any other filter in the chain.\n\n\nRequest\n\n\nThe \nrequest()\n function is run for an incoming request.\n\n\nHeaders\n\n\nRequest headers can be accessed by accessing the \nctx.request.header\n map like\n\n\nua = ctx.request.header[\nuser-agent\n]\n\n\n\n\nHeader names are normalized by the \nnet/http\n go module\n\nlike usual\n. Setting a\nheader is done by assigning to the headers map. Setting a header to \nnil\n or\nan empty string deletes the header - setting to \nnil\n is preferred.\n\n\nctx.request.header[\nuser-agent\n] = \nskipper.lua/0.0.1\n\nctx.request.header[\nAuthorization\n] = nil -- delete authorization header\n\n\n\n\nResponse headers work the same way by accessing / assigning to\n\nctx.response.header\n - this is of course only valid in the \nresponse()\n phase.\n\n\nOther request fields\n\n\n\n\nbackend_url\n - (read only) returns the backend url specified in the route\n  or an empty value in case it's a shunt or loopback\n\n\noutgoing_host\n - (read/write) the host that will be set for the outgoing\n  proxy request as the 'Host' header.\n\n\nremote_addr\n - (read only) the remote host, usually IP:port\n\n\ncontent_length\n - (read only) content length\n\n\nproto\n - (read only) something like \"HTTP/1.1\"\n\n\nmethod\n - (read only) request method, e.g. \"GET\" or \"POST\"\n\n\nurl\n - (read/write) request URL as string\n\n\n\n\nServing requests from lua\n\n\nRequests can be served with \nctx.serve(table)\n, you must return after this\ncall. Possible keys for the table:\n  * \nstatus_code\n (number) - required (but currently not enforced)\n  * \nheader\n (table)\n  * \nbody\n (string)\n\n\nSee also \nredirect\n and \ninternal server error\n\nexamples below\n\n\nStateBag\n\n\nThe state bag can be used to pass values from one filter to another in the same\nchain. It is shared by all filters in one request.\n\n\nfunction request(ctx, params)\n    -- the value of \nmykey\n will be available to all filters in the chain now:\n    ctx.state_bag[\nmykey\n] = \nfoo\n\nend\n\nfunction response(ctx, params)\n    print(ctx.state_bag[\nmykey\n])\nend\n\n\n\n\nExamples\n\n\nNote: the examples serve as examples. If there is a go based plugin available,\nuse that instead. The overhead of calling lua is 4-5 times slower than pure go.\n\n\nOAuth2 token as basic auth password\n\n\nlocal base64 = require(\nbase64\n)\n\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[\nAuthorization\n], \n^%s*[Bb]earer%s+\n, \n, 1)\n    user = ctx.request.header[\nx-username\n]\n    if user == \n then\n        user = params.username\n    end\n    ctx.request.header[\nAuthorization\n] = \nBasic \n .. base64.encode(user .. \n:\n  .. token)\n    -- print(ctx.request.header[\nAuthorization\n])\nend\n\n\n\n\nvalidate token\n\n\nlocal http = require(\nhttp\n)\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[\nAuthorization\n], \n^%s*[Bb]earer%s+\n, \n, 1)\n    if token == \n then\n        ctx.serve({status_code=401, body=\nMissing Token\n})\n        return\n    end\n\n    res, err = http.get(\nhttps://auth.example.com/oauth2/tokeninfo?access_token=\n..token)\n    if err ~= nil then\n        print(\nFailed to get tokeninfo: \n .. err)\n        ctx.serve({status_code=401, body=\nFailed to validate token: \n..err})\n        return\n    end\n    if res.status_code ~= 200 then\n        ctx.serve({status_code=401, body=\nInvalid token\n})\n        return\n    end\nend\n\n\n\n\nstrip query\n\n\nfunction request(ctx, params)\n    ctx.request.url = string.gsub(ctx.request.url, \n%?.*$\n, \n)\n    -- print(\nURL=\n..ctx.request.url)\nend\n\n\n\n\nredirect\n\n\nfunction request(ctx, params)\n    ctx.serve({\n        status_code=302,\n        header={\n            location=\nhttp://www.example.org/\n,\n        },\n    })\nend\n\n\n\n\ninternal server error\n\n\nfunction request(ctx, params)\n    -- let 10% of all requests fail with 500\n    if math.random() \n 0.1 then\n        ctx.serve({\n            status_code=500,\n            body=\nInternal Server Error.\\n\n,\n        })\n    end\nend\n\n\n\n\nBenchmark\n\n\nredirectTo vs lua redirect\n\n\nSee skptesting/benchmark-lua.sh\n\n\nRoute for \"skipper\" is \n* -\n redirectTo(\"http://localhost:9980\") -\n \nshunt\n,\nroute for \"lua\" is \n* -\n lua(\"function request(c,p); c.serve({status_code=302, header={location='http://localhost:9980'}});end\") -\n \nshunt\n\n\n[benchmarking skipper]\nRunning 12s test @ http://127.0.0.1:9990/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     6.75ms   14.22ms 260.28ms   92.19%\n    Req/Sec    23.87k     2.93k   32.22k    70.42%\n  572695 requests in 12.06s, 100.49MB read\n  Non-2xx or 3xx responses: 572695\nRequests/sec:  47474.31\nTransfer/sec:      8.33MB\n[benchmarking skipper done]\n\n[benchmarking lua]\nRunning 12s test @ http://127.0.0.1:9991/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    38.31ms   53.48ms 580.80ms   83.69%\n    Req/Sec     5.44k     1.03k    8.23k    71.25%\n  130123 requests in 12.01s, 20.97MB read\nRequests/sec:  10831.94\nTransfer/sec:      1.75MB\n[benchmarking lua done]\n\n\n\n\nThe benchmark was run with the default pool size of \nscript.InitialPoolSize = 3; script.MaxPoolSize = 10\n.\nWith \nscript.InitialPoolSize = 128; script.MaxPoolSize = 128\n (tweaked for this benchmark) you get about 12k req/s in lua.\n\n\nSimilar results are achieved when testing \nstripQuery()\n vs the lua version from above.", 
            "title": "Scripts"
        }, 
        {
            "location": "/scripts/#lua-filter-scripts", 
            "text": "LUA  scripts can be used as filters in skipper. The\ncurrent implementation supports  Lua 5.1 .", 
            "title": "Lua filter scripts"
        }, 
        {
            "location": "/scripts/#route-filters", 
            "text": "The lua scripts can be added to a route description with the lua() filter,\nthe first parameter for the filter is the script. This can be either a file\nname (ending with  .lua ) or inline code, e.g. as  file  lua(\"/path/to/file.lua\")  - if a file path is not absolute, the path\n is relative to skipper's working directory.  inline  lua(\"function request(c, p); print(c.request.url); end\")  Any other additional parameters for the filter must be  key=value  strings.\nThese will be passed as table to the called functions as second parameter. NOTE : Any parameter starting with \"lua-\" should not be used to pass\nvalues for the script - those will be used for configuring the filter.", 
            "title": "Route filters"
        }, 
        {
            "location": "/scripts/#script-requirements", 
            "text": "A filter script needs at least one global function:  request  or  response .\nIf present, they are called with a skipper filter context and the params passed\nin the route as table like  -- route looks like\n--\n-- any: * -  lua( ./test.lua ,  myparam=foo ,  other=bar ) -   shunt \n--\nfunction request(ctx, params)\n    print(ctx.request.method ..     .. ctx.request.url ..   -    .. params.myparam)\nend", 
            "title": "Script requirements"
        }, 
        {
            "location": "/scripts/#available-lua-modules", 
            "text": "Besides the  standard modules  - except\nfor  debug  - the following modules have been preloaded and can be used with e.g. local http = require(\"http\") , see also the examples below   http   gluahttp  - TODO: configurable\n with something different than  http.Client{}    url    gluaurl    json   gopher-json    base64   lua base64  For differences between the standard modules and the gopher-lua implementation\ncheck the  gopher-lua documentation .  Any other module can be loaded in non-byte code form from the lua path (by default\nfor  require(\"mod\")  this is  ./mod.lua ,  /usr/local/share/lua/5.1/mod.lua  and /usr/local/share/lua/5.1/mod/init.lua ).", 
            "title": "Available lua modules"
        }, 
        {
            "location": "/scripts/#lua-states", 
            "text": "There is no guarantee that the  request()  and  response()  functions of a\nlua script run in the same lua state during one request. Setting a variable\nin the request and accessing it in the response will most likely fail and lead\nto hard debuggable errors. Use the  ctx.state_bag  to propagate values from request  to  response  - and any other filter in the chain.", 
            "title": "Lua states"
        }, 
        {
            "location": "/scripts/#request", 
            "text": "The  request()  function is run for an incoming request.", 
            "title": "Request"
        }, 
        {
            "location": "/scripts/#headers", 
            "text": "Request headers can be accessed by accessing the  ctx.request.header  map like  ua = ctx.request.header[ user-agent ]  Header names are normalized by the  net/http  go module like usual . Setting a\nheader is done by assigning to the headers map. Setting a header to  nil  or\nan empty string deletes the header - setting to  nil  is preferred.  ctx.request.header[ user-agent ] =  skipper.lua/0.0.1 \nctx.request.header[ Authorization ] = nil -- delete authorization header  Response headers work the same way by accessing / assigning to ctx.response.header  - this is of course only valid in the  response()  phase.", 
            "title": "Headers"
        }, 
        {
            "location": "/scripts/#other-request-fields", 
            "text": "backend_url  - (read only) returns the backend url specified in the route\n  or an empty value in case it's a shunt or loopback  outgoing_host  - (read/write) the host that will be set for the outgoing\n  proxy request as the 'Host' header.  remote_addr  - (read only) the remote host, usually IP:port  content_length  - (read only) content length  proto  - (read only) something like \"HTTP/1.1\"  method  - (read only) request method, e.g. \"GET\" or \"POST\"  url  - (read/write) request URL as string", 
            "title": "Other request fields"
        }, 
        {
            "location": "/scripts/#serving-requests-from-lua", 
            "text": "Requests can be served with  ctx.serve(table) , you must return after this\ncall. Possible keys for the table:\n  *  status_code  (number) - required (but currently not enforced)\n  *  header  (table)\n  *  body  (string)  See also  redirect  and  internal server error \nexamples below", 
            "title": "Serving requests from lua"
        }, 
        {
            "location": "/scripts/#statebag", 
            "text": "The state bag can be used to pass values from one filter to another in the same\nchain. It is shared by all filters in one request.  function request(ctx, params)\n    -- the value of  mykey  will be available to all filters in the chain now:\n    ctx.state_bag[ mykey ] =  foo \nend\n\nfunction response(ctx, params)\n    print(ctx.state_bag[ mykey ])\nend", 
            "title": "StateBag"
        }, 
        {
            "location": "/scripts/#examples", 
            "text": "Note: the examples serve as examples. If there is a go based plugin available,\nuse that instead. The overhead of calling lua is 4-5 times slower than pure go.", 
            "title": "Examples"
        }, 
        {
            "location": "/scripts/#oauth2-token-as-basic-auth-password", 
            "text": "local base64 = require( base64 )\n\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[ Authorization ],  ^%s*[Bb]earer%s+ ,  , 1)\n    user = ctx.request.header[ x-username ]\n    if user ==   then\n        user = params.username\n    end\n    ctx.request.header[ Authorization ] =  Basic   .. base64.encode(user ..  :   .. token)\n    -- print(ctx.request.header[ Authorization ])\nend", 
            "title": "OAuth2 token as basic auth password"
        }, 
        {
            "location": "/scripts/#validate-token", 
            "text": "local http = require( http )\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[ Authorization ],  ^%s*[Bb]earer%s+ ,  , 1)\n    if token ==   then\n        ctx.serve({status_code=401, body= Missing Token })\n        return\n    end\n\n    res, err = http.get( https://auth.example.com/oauth2/tokeninfo?access_token= ..token)\n    if err ~= nil then\n        print( Failed to get tokeninfo:   .. err)\n        ctx.serve({status_code=401, body= Failed to validate token:  ..err})\n        return\n    end\n    if res.status_code ~= 200 then\n        ctx.serve({status_code=401, body= Invalid token })\n        return\n    end\nend", 
            "title": "validate token"
        }, 
        {
            "location": "/scripts/#strip-query", 
            "text": "function request(ctx, params)\n    ctx.request.url = string.gsub(ctx.request.url,  %?.*$ ,  )\n    -- print( URL= ..ctx.request.url)\nend", 
            "title": "strip query"
        }, 
        {
            "location": "/scripts/#redirect", 
            "text": "function request(ctx, params)\n    ctx.serve({\n        status_code=302,\n        header={\n            location= http://www.example.org/ ,\n        },\n    })\nend", 
            "title": "redirect"
        }, 
        {
            "location": "/scripts/#internal-server-error", 
            "text": "function request(ctx, params)\n    -- let 10% of all requests fail with 500\n    if math.random()   0.1 then\n        ctx.serve({\n            status_code=500,\n            body= Internal Server Error.\\n ,\n        })\n    end\nend", 
            "title": "internal server error"
        }, 
        {
            "location": "/scripts/#benchmark", 
            "text": "", 
            "title": "Benchmark"
        }, 
        {
            "location": "/scripts/#redirectto-vs-lua-redirect", 
            "text": "See skptesting/benchmark-lua.sh  Route for \"skipper\" is  * -  redirectTo(\"http://localhost:9980\") -   shunt ,\nroute for \"lua\" is  * -  lua(\"function request(c,p); c.serve({status_code=302, header={location='http://localhost:9980'}});end\") -   shunt  [benchmarking skipper]\nRunning 12s test @ http://127.0.0.1:9990/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     6.75ms   14.22ms 260.28ms   92.19%\n    Req/Sec    23.87k     2.93k   32.22k    70.42%\n  572695 requests in 12.06s, 100.49MB read\n  Non-2xx or 3xx responses: 572695\nRequests/sec:  47474.31\nTransfer/sec:      8.33MB\n[benchmarking skipper done]\n\n[benchmarking lua]\nRunning 12s test @ http://127.0.0.1:9991/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    38.31ms   53.48ms 580.80ms   83.69%\n    Req/Sec     5.44k     1.03k    8.23k    71.25%\n  130123 requests in 12.01s, 20.97MB read\nRequests/sec:  10831.94\nTransfer/sec:      1.75MB\n[benchmarking lua done]  The benchmark was run with the default pool size of  script.InitialPoolSize = 3; script.MaxPoolSize = 10 .\nWith  script.InitialPoolSize = 128; script.MaxPoolSize = 128  (tweaked for this benchmark) you get about 12k req/s in lua.  Similar results are achieved when testing  stripQuery()  vs the lua version from above.", 
            "title": "redirectTo vs lua redirect"
        }, 
        {
            "location": "/operations/", 
            "text": "Operations\n\n\nThis is the work in progress operations guide for showing information,\nwhich are relevant for production use.\n\n\nSkipper is proven to scale with number of routes beyond 200.000 routes\nper instance. Skipper is running with peaks to 45.000 http requests\nper second using multiple instances.\n\n\nConnection Options\n\n\nSkipper's connection options are allowing you to set Go's \nhttp.Server\n\nOptions on the client side and \nhttp.Transport\n on the backend side.\n\n\n\"It is recommended to read\n\nthis blog post about net http timeouts\n\nin order to better understand the impact of these settings.\n\n\nBackend\n\n\nBackend is the side skipper opens a client connection to.\n\n\nClosing idle connections is required for DNS failover, because Go's\n\nhttp.Transport\n caches\nDNS lookups and needs to create new connections for doing so. Skipper\nwill start a goroutine and use the specified\n\ntime.Duration\n to call\nCloseIdleConnections() on that\n\nhttp.Transport\n.\n\n\n-close-idle-conns-period string\n    period of closing all idle connections in seconds or as a\n    duration string. Not closing when less than 0 (default \"20\")\n\n\n\nThis will set MaxIdleConnsPerHost on the\n\nhttp.Transport\n to limit\nthe number of idle connections per backend such that we do not run out\nof sockets.\n\n\n-idle-conns-num int\n    maximum idle connections per backend host (default 64)\n\n\n\nThis will set MaxIdleConns on the\n\nhttp.Transport\n to limit\nthe number for all backends such that we do not run out of sockets.\n\n\n-max-idle-connection-backend int\n    sets the maximum idle connections for all backend connections\n\n\n\nThis will set TLSHandshakeTimeout on the\n\nhttp.Transport\n to have\ntimeouts based on TLS connections.\n\n\n-tls-timeout-backend duration\n    sets the TLS handshake timeout for backend connections (default 1m0s)\n\n\n\nThis will set Timeout on\n\nnet.Dialer\n that is the\nimplementation of DialContext, which is the TCP connection pool used in the\n\nhttp.Transport\n.\n\n\n-timeout-backend duration\n    sets the TCP client connection timeout for backend connections (default 1m0s)\n\n\n\nThis will set KeepAlive on\n\nnet.Dialer\n that is the\nimplementation of DialContext, which is the TCP connection pool used in the\n\nhttp.Transport\n.\n\n\n-keepalive-backend duration\n    sets the keepalive for backend connections (default 30s)\n\n\n\nThis will set DualStack (IPv4 and IPv6) on\n\nnet.Dialer\n that is the\nimplementation of DialContext, which is the TCP connection pool used in the\n\nhttp.Transport\n.\n\n\n-enable-dualstack-backend\n    enables DualStack for backend connections (default true)\n\n\n\nClient\n\n\nClient is the side skipper gets incoming calls from.\nHere we can set timeouts in different parts of the http connection.\n\n\nThis will set ReadTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-read-timeout-server duration\n    set ReadTimeout for http server connections (default 5m0s)\n\n\n\nThis will set ReadHeaderTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-read-header-timeout-server duration\n    set ReadHeaderTimeout for http server connections (default 1m0s)\n\n\n\nThis will set WriteTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-write-timeout-server duration\n    set WriteTimeout for http server connections (default 1m0s)\n\n\n\nThis will set IdleTimeout in\n\nhttp.Server\n handling\nincoming calls from your clients.\n\n\n-idle-timeout-server duration\n    maximum idle connections per backend host (default 1m0s)\n\n\n\nThis will set MaxHeaderBytes in\n\nhttp.Server\n to limit the\nsize of the http header from your clients.\n\n\n-max-header-bytes int\n    set MaxHeaderBytes for http server connections (default 1048576)\n\n\n\nMonitoring\n\n\nMonitoring is one of the most important things you need to run in\nproduction and skipper has a \ngodoc page\n\nfor the \nmetrics package\n,\ndescribing options and most keys you will find in the metrics handler\nendpoint. The default is listening on \n:9911/metrics\n. You can modify\nthe listen port with the \n-support-listener\n flag.\n\n\nPrometheus\n\n\nIn case you want to get metrics in \nPrometheus\n format exposed, use this\noption to enable it:\n\n\n-enable-prometheus-metrics\n\n\n\nIt will return \nPrometheus\n metrics on the\ncommon metrics endpoint :9911/metrics.\n\n\nConnection metrics\n\n\nThis option will enable known loadbalancer connections metrics, like\ncounters for active and new connections. This feature sets a metrics\ncallback on \nhttp.Server\n and\nuses a counter to collect\n\nhttp.ConnState\n.\n\n\n-enable-connection-metrics\n    enables connection metrics for http server connections\n\n\n\nIt will expose them in /metrics, for example json structure looks like this example:\n\n\n{\n  \"counters\": {\n    \"skipper.lb-conn-active\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-closed\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-idle\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-new\": {\n      \"count\": 6\n    }\n  },\n  /* stripped a lot of metrics here */\n}\n\n\n\nApplication metrics\n\n\nApplication metrics for your proxied applications you can enable with the option:\n\n\n-serve-host-metrics\n    enables reporting total serve time metrics for each host\n\n\n\nThis will make sure you will get stats for each \"Host\" header as \"timers\":\n\n\n\"timers\": {\n  \"skipper.servehost.app1_example_com.GET.200\": {\n    \"15m.rate\": 0.06830666203045982,\n    \"1m.rate\": 2.162612637718806e-06,\n    \"5m.rate\": 0.008312609284452856,\n    \"75%\": 236603815,\n    \"95%\": 236603815,\n    \"99%\": 236603815,\n    \"99.9%\": 236603815,\n    \"count\": 3,\n    \"max\": 236603815,\n    \"mean\": 116515451.66666667,\n    \"mean.rate\": 0.0030589345776699827,\n    \"median\": 91273391,\n    \"min\": 21669149,\n    \"stddev\": 89543653.71950394\n  },\n  \"skipper.servehost.app1_example_com.GET.304\": {\n    \"15m.rate\": 0.3503336738177459,\n    \"1m.rate\": 0.07923086447313292,\n    \"5m.rate\": 0.27019839341602214,\n    \"75%\": 99351895.25,\n    \"95%\": 105381847,\n    \"99%\": 105381847,\n    \"99.9%\": 105381847,\n    \"count\": 4,\n    \"max\": 105381847,\n    \"mean\": 47621612,\n    \"mean.rate\": 0.03087161486272533,\n    \"median\": 41676170.5,\n    \"min\": 1752260,\n    \"stddev\": 46489302.203724876\n  },\n  \"skipper.servehost.app1_example_com.GET.401\": {\n    \"15m.rate\": 0.16838468990057648,\n    \"1m.rate\": 0.01572861413072501,\n    \"5m.rate\": 0.1194724817779537,\n    \"75%\": 91094832,\n    \"95%\": 91094832,\n    \"99%\": 91094832,\n    \"99.9%\": 91094832,\n    \"count\": 2,\n    \"max\": 91094832,\n    \"mean\": 58090623,\n    \"mean.rate\": 0.012304914018033056,\n    \"median\": 58090623,\n    \"min\": 25086414,\n    \"stddev\": 33004209\n  }\n},\n\n\n\nTo change the sampling type of how metrics are handled from\n\nuniform\n\nto \nexponential decay\n,\nyou can use the following option, which is better for not so huge\nutilized applications (less than 100 requests per second):\n\n\n-metrics-exp-decay-sample\n    use exponentially decaying sample in metrics\n\n\n\nGo metrics\n\n\nMetrics from the\n\ngo runtime memstats\n\nare exposed from skipper to the metrics endpoint, default listener\n:9911, on path /metrics :\n\n\n\"gauges\": {\n  \"skipper.runtime.MemStats.Alloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.BuckHashSys\": {\n    \"value\": 1452675\n  },\n  \"skipper.runtime.MemStats.DebugGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.EnableGC\": {\n    \"value\": 1\n  },\n  \"skipper.runtime.MemStats.Frees\": {\n    \"value\": 121\n  },\n  \"skipper.runtime.MemStats.HeapAlloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.HeapIdle\": {\n    \"value\": 778240\n  },\n  \"skipper.runtime.MemStats.HeapInuse\": {\n    \"value\": 4988928\n  },\n  \"skipper.runtime.MemStats.HeapObjects\": {\n    \"value\": 24005\n  },\n  \"skipper.runtime.MemStats.HeapReleased\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.HeapSys\": {\n    \"value\": 5767168\n  },\n  \"skipper.runtime.MemStats.LastGC\": {\n    \"value\": 1516098381155094500\n  },\n  \"skipper.runtime.MemStats.Lookups\": {\n    \"value\": 2\n  },\n  \"skipper.runtime.MemStats.MCacheInuse\": {\n    \"value\": 6944\n  },\n  \"skipper.runtime.MemStats.MCacheSys\": {\n    \"value\": 16384\n  },\n  \"skipper.runtime.MemStats.MSpanInuse\": {\n    \"value\": 77368\n  },\n  \"skipper.runtime.MemStats.MSpanSys\": {\n    \"value\": 81920\n  },\n  \"skipper.runtime.MemStats.Mallocs\": {\n    \"value\": 1459\n  },\n  \"skipper.runtime.MemStats.NextGC\": {\n    \"value\": 4194304\n  },\n  \"skipper.runtime.MemStats.NumGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.PauseTotalNs\": {\n    \"value\": 683352\n  },\n  \"skipper.runtime.MemStats.StackInuse\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.StackSys\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.Sys\": {\n    \"value\": 9246968\n  },\n  \"skipper.runtime.MemStats.TotalAlloc\": {\n    \"value\": 35127624\n  },\n  \"skipper.runtime.NumCgoCall\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.NumGoroutine\": {\n    \"value\": 11\n  },\n  \"skipper.runtime.NumThread\": {\n    \"value\": 9\n  }\n},\n\"histograms\": {\n  \"skipper.runtime.MemStats.PauseNs\": {\n    \"75%\": 82509.25,\n    \"95%\": 132609,\n    \"99%\": 132609,\n    \"99.9%\": 132609,\n    \"count\": 12,\n    \"max\": 132609,\n    \"mean\": 56946,\n    \"median\": 39302.5,\n    \"min\": 28749,\n    \"stddev\": 31567.015005117817\n  }\n\n\n\n}\n\n\nDataclient\n\n\nDataclients poll some kind of data source for routes. To change the\ntimeout for calls that polls a dataclient, which could be the\nkubernetes API, use the following option:\n\n\n-source-poll-timeout int\n    polling timeout of the routing data sources, in milliseconds (default 3000)\n\n\n\nRouting table information\n\n\nSkipper allows you to get some runtime insights. You can get the\ncurrent routing table from skipper with in the\n\neskip file format\n:\n\n\n% curl localhost:9911/routes\n*\n  -\n \"http://localhost:12345/\"\n\n\n\nYou also can get the number of routes \nX-Count\n and the UNIX timestamp\nof the last route table update \nX-Timestamp\n, using a HEAD request:\n\n\n% curl -I localhost:9911/routes\nHTTP/1.1 200 OK\nContent-Type: text/plain\nX-Count: 1\nX-Timestamp: 1517777628\nDate: Sun, 04 Feb 2018 20:54:31 GMT", 
            "title": "Operations"
        }, 
        {
            "location": "/operations/#operations", 
            "text": "This is the work in progress operations guide for showing information,\nwhich are relevant for production use.  Skipper is proven to scale with number of routes beyond 200.000 routes\nper instance. Skipper is running with peaks to 45.000 http requests\nper second using multiple instances.", 
            "title": "Operations"
        }, 
        {
            "location": "/operations/#connection-options", 
            "text": "Skipper's connection options are allowing you to set Go's  http.Server \nOptions on the client side and  http.Transport  on the backend side.  \"It is recommended to read this blog post about net http timeouts \nin order to better understand the impact of these settings.", 
            "title": "Connection Options"
        }, 
        {
            "location": "/operations/#backend", 
            "text": "Backend is the side skipper opens a client connection to.  Closing idle connections is required for DNS failover, because Go's http.Transport  caches\nDNS lookups and needs to create new connections for doing so. Skipper\nwill start a goroutine and use the specified time.Duration  to call\nCloseIdleConnections() on that http.Transport .  -close-idle-conns-period string\n    period of closing all idle connections in seconds or as a\n    duration string. Not closing when less than 0 (default \"20\")  This will set MaxIdleConnsPerHost on the http.Transport  to limit\nthe number of idle connections per backend such that we do not run out\nof sockets.  -idle-conns-num int\n    maximum idle connections per backend host (default 64)  This will set MaxIdleConns on the http.Transport  to limit\nthe number for all backends such that we do not run out of sockets.  -max-idle-connection-backend int\n    sets the maximum idle connections for all backend connections  This will set TLSHandshakeTimeout on the http.Transport  to have\ntimeouts based on TLS connections.  -tls-timeout-backend duration\n    sets the TLS handshake timeout for backend connections (default 1m0s)  This will set Timeout on net.Dialer  that is the\nimplementation of DialContext, which is the TCP connection pool used in the http.Transport .  -timeout-backend duration\n    sets the TCP client connection timeout for backend connections (default 1m0s)  This will set KeepAlive on net.Dialer  that is the\nimplementation of DialContext, which is the TCP connection pool used in the http.Transport .  -keepalive-backend duration\n    sets the keepalive for backend connections (default 30s)  This will set DualStack (IPv4 and IPv6) on net.Dialer  that is the\nimplementation of DialContext, which is the TCP connection pool used in the http.Transport .  -enable-dualstack-backend\n    enables DualStack for backend connections (default true)", 
            "title": "Backend"
        }, 
        {
            "location": "/operations/#client", 
            "text": "Client is the side skipper gets incoming calls from.\nHere we can set timeouts in different parts of the http connection.  This will set ReadTimeout in http.Server  handling\nincoming calls from your clients.  -read-timeout-server duration\n    set ReadTimeout for http server connections (default 5m0s)  This will set ReadHeaderTimeout in http.Server  handling\nincoming calls from your clients.  -read-header-timeout-server duration\n    set ReadHeaderTimeout for http server connections (default 1m0s)  This will set WriteTimeout in http.Server  handling\nincoming calls from your clients.  -write-timeout-server duration\n    set WriteTimeout for http server connections (default 1m0s)  This will set IdleTimeout in http.Server  handling\nincoming calls from your clients.  -idle-timeout-server duration\n    maximum idle connections per backend host (default 1m0s)  This will set MaxHeaderBytes in http.Server  to limit the\nsize of the http header from your clients.  -max-header-bytes int\n    set MaxHeaderBytes for http server connections (default 1048576)", 
            "title": "Client"
        }, 
        {
            "location": "/operations/#monitoring", 
            "text": "Monitoring is one of the most important things you need to run in\nproduction and skipper has a  godoc page \nfor the  metrics package ,\ndescribing options and most keys you will find in the metrics handler\nendpoint. The default is listening on  :9911/metrics . You can modify\nthe listen port with the  -support-listener  flag.", 
            "title": "Monitoring"
        }, 
        {
            "location": "/operations/#prometheus", 
            "text": "In case you want to get metrics in  Prometheus  format exposed, use this\noption to enable it:  -enable-prometheus-metrics  It will return  Prometheus  metrics on the\ncommon metrics endpoint :9911/metrics.", 
            "title": "Prometheus"
        }, 
        {
            "location": "/operations/#connection-metrics", 
            "text": "This option will enable known loadbalancer connections metrics, like\ncounters for active and new connections. This feature sets a metrics\ncallback on  http.Server  and\nuses a counter to collect http.ConnState .  -enable-connection-metrics\n    enables connection metrics for http server connections  It will expose them in /metrics, for example json structure looks like this example:  {\n  \"counters\": {\n    \"skipper.lb-conn-active\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-closed\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-idle\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-new\": {\n      \"count\": 6\n    }\n  },\n  /* stripped a lot of metrics here */\n}", 
            "title": "Connection metrics"
        }, 
        {
            "location": "/operations/#application-metrics", 
            "text": "Application metrics for your proxied applications you can enable with the option:  -serve-host-metrics\n    enables reporting total serve time metrics for each host  This will make sure you will get stats for each \"Host\" header as \"timers\":  \"timers\": {\n  \"skipper.servehost.app1_example_com.GET.200\": {\n    \"15m.rate\": 0.06830666203045982,\n    \"1m.rate\": 2.162612637718806e-06,\n    \"5m.rate\": 0.008312609284452856,\n    \"75%\": 236603815,\n    \"95%\": 236603815,\n    \"99%\": 236603815,\n    \"99.9%\": 236603815,\n    \"count\": 3,\n    \"max\": 236603815,\n    \"mean\": 116515451.66666667,\n    \"mean.rate\": 0.0030589345776699827,\n    \"median\": 91273391,\n    \"min\": 21669149,\n    \"stddev\": 89543653.71950394\n  },\n  \"skipper.servehost.app1_example_com.GET.304\": {\n    \"15m.rate\": 0.3503336738177459,\n    \"1m.rate\": 0.07923086447313292,\n    \"5m.rate\": 0.27019839341602214,\n    \"75%\": 99351895.25,\n    \"95%\": 105381847,\n    \"99%\": 105381847,\n    \"99.9%\": 105381847,\n    \"count\": 4,\n    \"max\": 105381847,\n    \"mean\": 47621612,\n    \"mean.rate\": 0.03087161486272533,\n    \"median\": 41676170.5,\n    \"min\": 1752260,\n    \"stddev\": 46489302.203724876\n  },\n  \"skipper.servehost.app1_example_com.GET.401\": {\n    \"15m.rate\": 0.16838468990057648,\n    \"1m.rate\": 0.01572861413072501,\n    \"5m.rate\": 0.1194724817779537,\n    \"75%\": 91094832,\n    \"95%\": 91094832,\n    \"99%\": 91094832,\n    \"99.9%\": 91094832,\n    \"count\": 2,\n    \"max\": 91094832,\n    \"mean\": 58090623,\n    \"mean.rate\": 0.012304914018033056,\n    \"median\": 58090623,\n    \"min\": 25086414,\n    \"stddev\": 33004209\n  }\n},  To change the sampling type of how metrics are handled from uniform \nto  exponential decay ,\nyou can use the following option, which is better for not so huge\nutilized applications (less than 100 requests per second):  -metrics-exp-decay-sample\n    use exponentially decaying sample in metrics", 
            "title": "Application metrics"
        }, 
        {
            "location": "/operations/#go-metrics", 
            "text": "Metrics from the go runtime memstats \nare exposed from skipper to the metrics endpoint, default listener\n:9911, on path /metrics :  \"gauges\": {\n  \"skipper.runtime.MemStats.Alloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.BuckHashSys\": {\n    \"value\": 1452675\n  },\n  \"skipper.runtime.MemStats.DebugGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.EnableGC\": {\n    \"value\": 1\n  },\n  \"skipper.runtime.MemStats.Frees\": {\n    \"value\": 121\n  },\n  \"skipper.runtime.MemStats.HeapAlloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.HeapIdle\": {\n    \"value\": 778240\n  },\n  \"skipper.runtime.MemStats.HeapInuse\": {\n    \"value\": 4988928\n  },\n  \"skipper.runtime.MemStats.HeapObjects\": {\n    \"value\": 24005\n  },\n  \"skipper.runtime.MemStats.HeapReleased\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.HeapSys\": {\n    \"value\": 5767168\n  },\n  \"skipper.runtime.MemStats.LastGC\": {\n    \"value\": 1516098381155094500\n  },\n  \"skipper.runtime.MemStats.Lookups\": {\n    \"value\": 2\n  },\n  \"skipper.runtime.MemStats.MCacheInuse\": {\n    \"value\": 6944\n  },\n  \"skipper.runtime.MemStats.MCacheSys\": {\n    \"value\": 16384\n  },\n  \"skipper.runtime.MemStats.MSpanInuse\": {\n    \"value\": 77368\n  },\n  \"skipper.runtime.MemStats.MSpanSys\": {\n    \"value\": 81920\n  },\n  \"skipper.runtime.MemStats.Mallocs\": {\n    \"value\": 1459\n  },\n  \"skipper.runtime.MemStats.NextGC\": {\n    \"value\": 4194304\n  },\n  \"skipper.runtime.MemStats.NumGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.PauseTotalNs\": {\n    \"value\": 683352\n  },\n  \"skipper.runtime.MemStats.StackInuse\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.StackSys\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.Sys\": {\n    \"value\": 9246968\n  },\n  \"skipper.runtime.MemStats.TotalAlloc\": {\n    \"value\": 35127624\n  },\n  \"skipper.runtime.NumCgoCall\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.NumGoroutine\": {\n    \"value\": 11\n  },\n  \"skipper.runtime.NumThread\": {\n    \"value\": 9\n  }\n},\n\"histograms\": {\n  \"skipper.runtime.MemStats.PauseNs\": {\n    \"75%\": 82509.25,\n    \"95%\": 132609,\n    \"99%\": 132609,\n    \"99.9%\": 132609,\n    \"count\": 12,\n    \"max\": 132609,\n    \"mean\": 56946,\n    \"median\": 39302.5,\n    \"min\": 28749,\n    \"stddev\": 31567.015005117817\n  }  }", 
            "title": "Go metrics"
        }, 
        {
            "location": "/operations/#dataclient", 
            "text": "Dataclients poll some kind of data source for routes. To change the\ntimeout for calls that polls a dataclient, which could be the\nkubernetes API, use the following option:  -source-poll-timeout int\n    polling timeout of the routing data sources, in milliseconds (default 3000)", 
            "title": "Dataclient"
        }, 
        {
            "location": "/operations/#routing-table-information", 
            "text": "Skipper allows you to get some runtime insights. You can get the\ncurrent routing table from skipper with in the eskip file format :  % curl localhost:9911/routes\n*\n  -  \"http://localhost:12345/\"  You also can get the number of routes  X-Count  and the UNIX timestamp\nof the last route table update  X-Timestamp , using a HEAD request:  % curl -I localhost:9911/routes\nHTTP/1.1 200 OK\nContent-Type: text/plain\nX-Count: 1\nX-Timestamp: 1517777628\nDate: Sun, 04 Feb 2018 20:54:31 GMT", 
            "title": "Routing table information"
        }
    ]
}